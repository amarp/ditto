diff -Naur src_dot_original/acinclude.m4 src/acinclude.m4
--- src_dot_original/acinclude.m4	2008-08-10 16:53:18.000000000 -0400
+++ src/acinclude.m4	2008-08-10 16:51:18.000000000 -0400
@@ -1461,7 +1461,7 @@
 	sfs_gnu_CXXWFLAGS="$sfs_gnu_WFLAGS"
 	;;
     linux*|freebsd*)
-	sfs_gnu_WFLAGS="-Wall -Werror"
+	sfs_gnu_WFLAGS="-Wall"
 	sfs_gnu_CXXWFLAGS="$sfs_gnu_WFLAGS"
 	;;
     *)
diff -Naur src_dot_original/build_chunk_sizes.sh src/build_chunk_sizes.sh
--- src_dot_original/build_chunk_sizes.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/build_chunk_sizes.sh	2008-08-09 15:39:12.000000000 -0400
@@ -0,0 +1,132 @@
+#!/bin/bash
+
+
+function usage 
+{
+  echo 
+  echo $0 "<install directory> <sfslite install dir>"
+  echo "e.g.: $0 /home/aphanish/life/research/dist/ditto/install /home/aphanish/life/research/dist/ditto/dot_snap_20070206/sfslite"
+  echo	
+}
+
+function intro
+{
+  echo "This script will be build and install dot binaries"
+  echo "using 8K,16K, and 32K chunk sizes."
+  echo "Binaries will be installed as ..."
+  echo $dot_8K
+  echo $dot_16K
+  echo $dot_32K
+  echo "sfslite installation to be used is " $sfslite_dir
+}
+
+function rm_dot_installs
+{
+ rm -f -r $dot_8K
+ rm -f -r $dot_16K
+ rm -f -r $dot_32K
+}
+
+function initialize_dot_installs
+{
+  dot_8K=$install_dir/dot_8K
+  dot_16K=$install_dir/dot_16K
+  dot_32K=$install_dir/dot_32K
+}
+
+function check_usage 
+{
+  if [ $# -ne 2 ]; then
+    usage;
+    exit;	
+  fi
+}
+
+function build_dot_8K
+{
+  make clean && make distclean
+  cp gtcd/chunkerPlugin_8K.h gtcd/chunkerPlugin.h
+  cp gtcd/chunker/chunkAlg_fixed_8K.h gtcd/chunker/chunkAlg_fixed.h
+  autoreconf -i -s 
+  ./configure --with-sfs=$sfslite_dir --prefix=$dot_8K
+  make 
+  make install
+  mv $dot_8K/bin/sniffTcp $dot_8K/bin/sniffTcp_8K
+  mv $dot_8K/sbin/gtcd $dot_8K/sbin/gtcd_8K
+}
+
+function build_dot_16K
+{
+  make clean && make distclean
+  cp gtcd/chunkerPlugin_16K.h gtcd/chunkerPlugin.h
+  cp gtcd/chunker/chunkAlg_fixed_16K.h gtcd/chunker/chunkAlg_fixed.h
+  autoreconf -i -s
+  ./configure --with-sfs=$sfslite_dir --prefix=$dot_16K
+  make
+  make install
+  mv $dot_16K/bin/sniffTcp $dot_16K/bin/sniffTcp_16K
+  mv $dot_16K/sbin/gtcd $dot_16K/sbin/gtcd_16K
+}
+
+function build_dot_32K
+{
+  make clean && make distclean
+  cp gtcd/chunkerPlugin_32K.h gtcd/chunkerPlugin.h
+  cp gtcd/chunker/chunkAlg_fixed_32K.h gtcd/chunker/chunkAlg_fixed.h
+  autoreconf -i -s
+  ./configure --with-sfs=$sfslite_dir --prefix=$dot_32K
+  make
+  make install
+  mv $dot_32K/bin/sniffTcp $dot_32K/bin/sniffTcp_32K
+  mv $dot_32K/sbin/gtcd $dot_32K/sbin/gtcd_32K
+}
+
+
+function reset_dot_sources
+{
+  make clean && make distclean
+  cp gtcd/chunkerPlugin_16K.h gtcd/chunkerPlugin.h
+  cp gtcd/chunker/chunkAlg_fixed_16K.h gtcd/chunker/chunkAlg_fixed.h
+}
+
+
+function copy_emulab_header
+{
+  cp gtcd/testbed_emulab.h gtcd/testbed.h
+}
+
+
+function copy_map_header
+{
+  cp gtcd/testbed_map.h gtcd/testbed.h
+}
+
+
+check_usage $1 $2;
+install_dir=$1
+sfslite_dir=$2
+
+# emulab
+install_dir=$1/emulab
+initialize_dot_installs;
+intro;
+rm_dot_installs;
+copy_emulab_header;
+build_dot_8K;
+build_dot_16K;
+build_dot_32K;
+reset_dot_sources;
+
+# map
+install_dir=$1/map
+initialize_dot_installs;
+intro;
+rm_dot_installs;
+copy_map_header;
+build_dot_8K;
+build_dot_16K;
+build_dot_32K;
+reset_dot_sources;
+
+exit;
+
diff -Naur src_dot_original/configure.ac src/configure.ac
--- src_dot_original/configure.ac	2007-02-06 17:37:00.000000000 -0500
+++ src/configure.ac	2008-06-18 20:05:04.000000000 -0400
@@ -66,8 +66,10 @@
 		 gtcd/xfer/Makefile
                  gtcd/chunker/Makefile
 		 gtcd/storage/Makefile
+		 gtcd/sniffer/Makefile
                  gtcd/Makefile
 		 gcp/Makefile
-		 cdht/Makefile
-		 mailfilter/Makefile])
+		 sniffer/Makefile
+		 ideal-sniffer/Makefile
+		 cdht/Makefile])
 AC_OUTPUT
diff -Naur src_dot_original/gcp/Makefile.am src/gcp/Makefile.am
--- src_dot_original/gcp/Makefile.am	2007-02-06 17:36:56.000000000 -0500
+++ src/gcp/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -1,5 +1,5 @@
 $(PROGRAMS): $(LDEPS) $(LIBGTC)
-
+AM_LDFLAGS = -all-static
 bin_PROGRAMS = gcp
 noinst_HEADERS = gcp.h gcp_prot.h
 
diff -Naur src_dot_original/gtcd/chunker/chunkAlg_fixed_16K.h src/gtcd/chunker/chunkAlg_fixed_16K.h
--- src_dot_original/gtcd/chunker/chunkAlg_fixed_16K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunker/chunkAlg_fixed_16K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKALG_FIXED_H_
+#define _CHUNKALG_FIXED_H_
+
+#include "chunkAlg.h"
+
+#define CHUNK_SIZE 16384 //16K
+
+class chunkAlg_fixed : public chunkAlg {
+private:
+    unsigned int _bytes_left;
+
+public:
+    chunkAlg_fixed();
+    ~chunkAlg_fixed();
+
+    void stop();
+    ptr<vec<unsigned int> > chunk_data (const unsigned char *data, 
+                                        size_t size);
+    ptr<vec<unsigned int> > chunk_data (suio *in_data);
+
+};
+
+#endif /* _CHUNKALG_FIXED_H_ */
diff -Naur src_dot_original/gtcd/chunker/chunkAlg_fixed_32K.h src/gtcd/chunker/chunkAlg_fixed_32K.h
--- src_dot_original/gtcd/chunker/chunkAlg_fixed_32K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunker/chunkAlg_fixed_32K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKALG_FIXED_H_
+#define _CHUNKALG_FIXED_H_
+
+#include "chunkAlg.h"
+
+#define CHUNK_SIZE 32768 // 32K
+
+class chunkAlg_fixed : public chunkAlg {
+private:
+    unsigned int _bytes_left;
+
+public:
+    chunkAlg_fixed();
+    ~chunkAlg_fixed();
+
+    void stop();
+    ptr<vec<unsigned int> > chunk_data (const unsigned char *data, 
+                                        size_t size);
+    ptr<vec<unsigned int> > chunk_data (suio *in_data);
+
+};
+
+#endif /* _CHUNKALG_FIXED_H_ */
diff -Naur src_dot_original/gtcd/chunker/chunkAlg_fixed_8K.h src/gtcd/chunker/chunkAlg_fixed_8K.h
--- src_dot_original/gtcd/chunker/chunkAlg_fixed_8K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunker/chunkAlg_fixed_8K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKALG_FIXED_H_
+#define _CHUNKALG_FIXED_H_
+
+#include "chunkAlg.h"
+
+#define CHUNK_SIZE 8192 // 8K
+
+class chunkAlg_fixed : public chunkAlg {
+private:
+    unsigned int _bytes_left;
+
+public:
+    chunkAlg_fixed();
+    ~chunkAlg_fixed();
+
+    void stop();
+    ptr<vec<unsigned int> > chunk_data (const unsigned char *data, 
+                                        size_t size);
+    ptr<vec<unsigned int> > chunk_data (suio *in_data);
+
+};
+
+#endif /* _CHUNKALG_FIXED_H_ */
diff -Naur src_dot_original/gtcd/chunker/chunkAlg_fixed.h src/gtcd/chunker/chunkAlg_fixed.h
--- src_dot_original/gtcd/chunker/chunkAlg_fixed.h	2008-08-10 17:01:44.000000000 -0400
+++ src/gtcd/chunker/chunkAlg_fixed.h	2008-06-18 20:05:04.000000000 -0400
@@ -9,7 +9,7 @@
 
 #include "chunkAlg.h"
 
-#define CHUNK_SIZE 16384 //40960
+#define CHUNK_SIZE 16384 //16K
 
 class chunkAlg_fixed : public chunkAlg {
 private:
diff -Naur src_dot_original/gtcd/chunkerPlugin_16K.h src/gtcd/chunkerPlugin_16K.h
--- src_dot_original/gtcd/chunkerPlugin_16K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunkerPlugin_16K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKERPLUGIN_H_
+#define _CHUNKERPLUGIN_H_
+
+#include "storagePlugin.h"
+
+#define CHUNK_SIZE 16384 //16K
+
+class chunkerPlugin {
+public:
+    virtual bool init(dot_sId *id_out) = 0;
+    virtual void put_object(dot_sId id_in, const void *buf, size_t len, cbs cb) = 0;
+    /* callback:  errstring, null if no error */
+    virtual void commit_object(dot_sId id_in, commit_cb cb) = 0;
+    virtual bool release_object(ref<dot_oid> id_in) = 0;
+
+    virtual ~chunkerPlugin() {}
+};
+
+#endif /* _CHUNKERPLUGIN_H_ */
diff -Naur src_dot_original/gtcd/chunkerPlugin_32K.h src/gtcd/chunkerPlugin_32K.h
--- src_dot_original/gtcd/chunkerPlugin_32K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunkerPlugin_32K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKERPLUGIN_H_
+#define _CHUNKERPLUGIN_H_
+
+#include "storagePlugin.h"
+
+#define CHUNK_SIZE 32768 // 32K
+
+class chunkerPlugin {
+public:
+    virtual bool init(dot_sId *id_out) = 0;
+    virtual void put_object(dot_sId id_in, const void *buf, size_t len, cbs cb) = 0;
+    /* callback:  errstring, null if no error */
+    virtual void commit_object(dot_sId id_in, commit_cb cb) = 0;
+    virtual bool release_object(ref<dot_oid> id_in) = 0;
+
+    virtual ~chunkerPlugin() {}
+};
+
+#endif /* _CHUNKERPLUGIN_H_ */
diff -Naur src_dot_original/gtcd/chunkerPlugin_8K.h src/gtcd/chunkerPlugin_8K.h
--- src_dot_original/gtcd/chunkerPlugin_8K.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/chunkerPlugin_8K.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2005-2006 Carnegie Mellon University and Intel Corporation.
+ * All rights reserved.
+ * See the file "LICENSE" for licensing terms.
+ */
+
+#ifndef _CHUNKERPLUGIN_H_
+#define _CHUNKERPLUGIN_H_
+
+#include "storagePlugin.h"
+
+#define CHUNK_SIZE 8192 // 8K
+
+class chunkerPlugin {
+public:
+    virtual bool init(dot_sId *id_out) = 0;
+    virtual void put_object(dot_sId id_in, const void *buf, size_t len, cbs cb) = 0;
+    /* callback:  errstring, null if no error */
+    virtual void commit_object(dot_sId id_in, commit_cb cb) = 0;
+    virtual bool release_object(ref<dot_oid> id_in) = 0;
+
+    virtual ~chunkerPlugin() {}
+};
+
+#endif /* _CHUNKERPLUGIN_H_ */
diff -Naur src_dot_original/gtcd/chunkerPlugin.h src/gtcd/chunkerPlugin.h
--- src_dot_original/gtcd/chunkerPlugin.h	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/chunkerPlugin.h	2008-06-18 20:05:04.000000000 -0400
@@ -9,7 +9,7 @@
 
 #include "storagePlugin.h"
 
-#define CHUNK_SIZE 16384 //40960
+#define CHUNK_SIZE 16384 //16K
 
 class chunkerPlugin {
 public:
diff -Naur src_dot_original/gtcd/configfile.cc src/gtcd/configfile.cc
--- src_dot_original/gtcd/configfile.cc	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/configfile.cc	2008-06-18 20:05:04.000000000 -0400
@@ -6,13 +6,13 @@
 
 #include "configfile.h"
 
-enum config_state_t { CONFIG_NONE, CONFIG_STORAGE, CONFIG_XFER };
+enum config_state_t { CONFIG_NONE, CONFIG_STORAGE, CONFIG_XFER, CONFIG_ROUTING, CONFIG_SNIFFER };
 
 bool
 parse_config(str file, vec<str> *sp_list, vec<str> *xp_list)
 {
     assert(sp_list);
-    assert(xp_list);
+    assert(xp_list); 
 
     if (!file) {
         warn << "No config file specified!\n";
@@ -26,6 +26,8 @@
     enum config_state_t state = CONFIG_NONE;
     bool saw_storage = false;
     bool saw_xfer = false;
+    bool saw_routing = false;
+    bool saw_sniffer = false;
     bool errors = false;
 
     while (pa.getline(&av, &line)) {
@@ -49,6 +51,26 @@
                 saw_xfer = true;
             }
         }
+        else if (!strcasecmp(av[0], "[routing]")) {
+            if (saw_routing) {
+                errors = true;
+                warn << file << ":" << line << ": Duplicate [routing] section\n";
+            }
+            else {
+                state = CONFIG_ROUTING;
+                saw_routing = true;
+            }
+        }
+        else if (!strcasecmp(av[0], "[sniffer]")) {
+            if (saw_sniffer) {
+                errors = true;
+                warn << file << ":" << line << ": Duplicate [sniffer] section\n";
+            }
+            else {
+                state = CONFIG_SNIFFER;
+                saw_sniffer = true;
+            }
+        }
         else {
             if (state == CONFIG_NONE) {
                 errors = true;
@@ -67,7 +89,6 @@
                     sp_list->push_back("");
 		    sp_list->push_back("");
 		}
-		    
             }
             else if (state == CONFIG_XFER) {
                 xp_list->push_back(av.pop_front());
@@ -83,7 +104,10 @@
 		    xp_list->push_back("");
 		}
             }
-        }
+            else if (state == CONFIG_ROUTING) {
+	      // do nothing
+	    }
+	}
     }
 
     if (!saw_storage) {
@@ -100,3 +124,100 @@
 
     return errors;
 }
+
+//#define USE_LOOPBACK_ROUTING
+bool 
+parse_config_routing_info (str file, vec<str> *routing_list)
+{
+  assert (routing_list);
+
+  if (!file) {
+    warn << "No config file specified \n";
+    return true;
+  }
+  parseargs pa(file);
+  int line;
+  vec<str> av;
+  
+  enum config_state_t state = CONFIG_NONE;
+  bool saw_routing = false;
+  bool errors = false;
+#ifdef USE_LOOPBACK_ROUTING
+  char *routing_info_header = "[routing]";
+#else 
+  char *routing_info_header = "Destination";
+#endif 
+  while (pa.getline(&av, &line)) {
+    if (!strcasecmp(av[0], routing_info_header)) {
+      if (saw_routing) {
+	errors = true;
+	warn << file << ":" << line << ": Duplicate routing information \n";
+      }
+      else {
+	state = CONFIG_ROUTING;
+	saw_routing = true;
+      }
+    }
+    else {
+      if (state == CONFIG_ROUTING) {
+	while (av.size ())
+	  routing_list->push_back(av.pop_front());
+      }
+    } 
+  }
+  if (!saw_routing) {
+    warn << file << ": Missing routing information \n";
+    errors = true;
+  }
+  if (errors) 
+    warn << "Errors processing file :" << file << "\n";
+  
+  return errors;
+}
+
+bool 
+parse_config_sniffer_info (str file, vec<str> *sniffer_unix_socket_list)
+{
+  assert (sniffer_unix_socket_list);
+
+  if (!file) {
+    warn << "No config file specified \n";
+    return true;
+  }
+  parseargs pa(file);
+  int line;
+  vec<str> av;
+  
+  enum config_state_t state = CONFIG_NONE;
+  bool saw_sniffer = false;
+  bool errors = false;
+
+  while (pa.getline(&av, &line)) {
+    if (!strcasecmp(av[0], "[sniffer]")) {
+      if (saw_sniffer) {
+	errors = true;
+	warn << file << ":" << line << ": Duplicate [sniffer] section\n";
+      }
+      else {
+	state = CONFIG_SNIFFER;
+	saw_sniffer = true;
+      }
+    }
+    else { 
+      if (state == CONFIG_SNIFFER) {
+	sniffer_unix_socket_list->push_back(av.pop_front());
+	sniffer_unix_socket_list->push_back(av.pop_front());
+        break;
+      }
+    }
+  }
+  
+  if (!saw_sniffer) {
+    warn << file << ": Missing [sniffer] section\n";
+    errors = true;
+  }
+  if (errors)
+    warn << "Errors processing file: " << file << "\n";
+  
+  return errors;
+}
diff -Naur src_dot_original/gtcd/configfile.h src/gtcd/configfile.h
--- src_dot_original/gtcd/configfile.h	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/configfile.h	2008-06-18 20:05:04.000000000 -0400
@@ -9,3 +9,9 @@
 
 bool
 parse_config(str file, vec<str> *sp_list, vec<str> *xp_list);
+
+bool 
+parse_config_routing_info(str file, vec<str> *routing_list);
+
+bool 
+parse_config_sniffer_info(str file, vec<str> *sniffer_unix_socket_list);
diff -Naur src_dot_original/gtcd/gtcd.h src/gtcd/gtcd.h
--- src_dot_original/gtcd/gtcd.h	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/gtcd.h	2008-06-18 20:05:04.000000000 -0400
@@ -15,6 +15,7 @@
 #include "chunkerPlugin.h"
 #include "xferPlugin.h"
 #include "storagePlugin.h"
+#include "snifferPlugin.h"
 #include "util.h"
 #include "tame.h"
 
@@ -85,11 +86,13 @@
 
 int parse_hint(str hint, str protocol, hint_res *res);
 int make_hint(hint_res ip, str protocol, oid_hint *op);
+void compute_chunk_id (ref <suio> data, unsigned char *digest, unsigned int *diglen);
 
 class storagePlugin;
 class xferPlugin;
 class chunkerPlugin;
 class xferPlugin_portable;
+class snifferPlugin;
 
 /* The main gtcd.  Only one of these is created for an entire gtcd.
  * a "class gtcd" is then instantiated per connection.
@@ -101,15 +104,23 @@
     xferPlugin *xp;
     xferPlugin_portable *pp;
     chunkerPlugin *cp;
-
-    gtcd_main() 
-        : sp(NULL), xp(NULL), pp(NULL), cp(NULL)
+    snifferPlugin *snp;
+    
+    str configFile;
+
+    bool no_dot_proxy;
+    str first_octet_mask;
+
+  gtcd_main(str conf_file)
+      : sp(NULL), xp(NULL), pp(NULL), cp(NULL), 
+        snp(NULL), configFile(conf_file), no_dot_proxy(false), first_octet_mask("")
     { }
 
     void set_xferPlugin(xferPlugin *p) { xp = p; }
     void set_storagePlugin(storagePlugin *p) { sp = p; }
     void set_xferPlugin_portable(xferPlugin_portable *p) { pp = p; }
     void set_chunkerPlugin(chunkerPlugin *p) { cp = p; }
+    void set_snifferPlugin (snifferPlugin *p) { snp = p; }
 };
 
 /* gtcd.cc */
@@ -166,6 +177,8 @@
     void fetch_data(dot_xferId xferId);
     void xp_fetch_data_cb(dot_xferId xferId, str s, ptr<desc_result> res);
 
+  void setup_sniffer_socket (int portnum);
+
 public:
     list_entry<gtcd> link;
 
diff -Naur src_dot_original/gtcd/gtcd.T src/gtcd/gtcd.T
--- src_dot_original/gtcd/gtcd.T	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/gtcd.T	2008-06-18 20:05:04.000000000 -0400
@@ -12,6 +12,66 @@
 list<gtcd, &gtcd::link> gtclist;
 static struct timeval start, end;
 
+void 
+print_chunk_id (char *sbuf, int len)
+{
+ unsigned char digest[EVP_MAX_MD_SIZE];
+  EVP_MD_CTX desc_hash;
+  unsigned int diglen;
+  
+  EVP_MD_CTX_init(&desc_hash);
+  EVP_DigestInit(&desc_hash, EVP_sha1());
+  EVP_DigestUpdate(&desc_hash, sbuf, len);
+  EVP_DigestFinal(&desc_hash, digest, &diglen);
+  
+  dot_oid chunkname;
+  chunkname.set((char *)digest, diglen);
+  warn << "chunk id = " << chunkname << "\n";	
+}
+
+char * seen_chunks[4] = {0,0,0,0};
+void
+check_chunk_against_prev (char *buf, int len)
+{
+  static int num_seen = 0;
+  int i;
+
+ for (i = 0; i < num_seen; i++) {
+  if (seen_chunks[i]) {
+   if (memcmp (seen_chunks[i], buf, len) == 0) {
+     warn("chunk of len %d matched %d th chunk \n",len,i);
+     warn << "will now print chunk id of prev seen chunk \n";
+     print_chunk_id (seen_chunks[i], len);
+     warn << "will now print chunk id of  new chunk \n";
+     print_chunk_id (buf, len);
+     return;
+   }
+  }
+ }
+ if (num_seen < 4) {
+   seen_chunks[num_seen] = New char[len];		
+   memcpy (seen_chunks[num_seen], buf, len);	
+   warn ("Entering chunk as %d th entry \n",num_seen);
+   num_seen++;
+ }
+}
+
+void
+compute_chunk_id (ref <suio> data, unsigned char *digest, unsigned int *diglen) 
+{
+  //may be potentially computed without copying into char buf
+  EVP_MD_CTX desc_hash;
+  char *sbuf = New char[data->resid()];
+
+  data->copyout(sbuf, data->resid());
+  EVP_MD_CTX_init(&desc_hash);
+  EVP_DigestInit(&desc_hash, EVP_sha1());
+  EVP_DigestUpdate(&desc_hash, sbuf, data->resid());
+  EVP_DigestFinal(&desc_hash, digest, diglen);
+//  check_chunk_against_prev (sbuf, data->resid());
+  delete[] sbuf;
+}
+
 int 
 parse_hint(str hint, str protocol, hint_res *res)
 {
diff -Naur src_dot_original/gtcd/main.cc src/gtcd/main.cc
--- src_dot_original/gtcd/main.cc	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/main.cc	2008-06-18 20:05:04.000000000 -0400
@@ -9,6 +9,7 @@
 #include "xfer/xferPlugin_all.h"
 #include "storage/storagePlugin_all.h"
 #include "configfile.h"
+#include "sniffer/snifferPlugin_tcp.h"
 
 static str gtcd_listen_sock("/tmp/gtcd.sock");
 gtcd_main *m;
@@ -235,6 +236,9 @@
     m->set_xferPlugin(xp);
     
     m->set_chunkerPlugin(New chunkerPlugin_default(m->sp));
+
+    m->set_snifferPlugin(New snifferPlugin_tcp(m, NULL));
+    //m->snp->configure();
 }
 
 int
@@ -246,10 +250,12 @@
     char ch;
     bool daemonize = true;
     str configfile;
+    bool b_no_dot_proxy = false;
+    str first_octet_mask = "2";
 
     setprogname(argv[0]);
 
-    while ((ch = getopt(argc, argv, "dhp:f:")) != -1)
+    while ((ch = getopt(argc, argv, "ndhp:f:m:")) != -1)
         switch(ch) {
 	case 'd':
 	    warn << "Daemonize option not yet implemented\n";
@@ -258,12 +264,18 @@
 	case 'h':
 	    help();
 	    exit(0);
+        case 'n':
+            b_no_dot_proxy = true;
+            break;
         case 'p':
             gtcd_listen_sock = optarg;
             break;
         case 'f':
             configfile = optarg;
             break;
+        case 'm':
+            first_octet_mask = optarg;
+            break;
 	default:
 	    usage();
 	    exit(-1);
@@ -272,7 +284,10 @@
     gtcd_start(gtcd_listen_sock);
 
     /* Configure the graph of plugins */
-    m = New gtcd_main();
+    m = New gtcd_main(configfile);
+    m->no_dot_proxy = b_no_dot_proxy;
+    m->first_octet_mask = first_octet_mask;
+
 
     instantiate_plugins(configfile);
         
diff -Naur src_dot_original/gtcd/Makefile.am src/gtcd/Makefile.am
--- src_dot_original/gtcd/Makefile.am	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -1,19 +1,21 @@
-INCLUDES = -Ixfer -Ichunker -I$(srcdir)/storage -Istorage
-
-SUBDIRS = prot xfer chunker storage
+INCLUDES = -Ixfer -Ichunker -I$(srcdir)/storage -Istorage -Isniffer
 
+SUBDIRS = prot xfer chunker storage sniffer
+AM_LDFLAGS = -all-static
 sbin_PROGRAMS = gtcd
 lib_LTLIBRARIES = libcgtc.la libgtc.la
 
 noinst_HEADERS = gtcd.h gtc.h chunkerPlugin.h xferPlugin.h \
 		 storagePlugin.h configfile.h gtc_prot_strbuf.h \
-		 se_transfer.h
+		 se_transfer.h snifferPlugin.h testbed.h
+
 include_HEADERS = gtc_ext_interface.h
 
 gtcd_SOURCES = gtcd.cc main.cc configfile.cc
 gtcd_LDADD = libcgtc.la $(LIBGTC) \
 	     chunker/libchunk.la xfer/libxferPlugin.la \
-	     storage/libstoragePlugin.la $(LDADD)
+	     storage/libstoragePlugin.la sniffer/libsnifferPlugin.la \
+	     $(LDADD)
 
 libgtc_la_SOURCES = gtc_put.cc gtc_get.cc
 libgtc_la_LIBADD = prot/libgtcprot.la
diff -Naur src_dot_original/gtcd/sniffer/Makefile.am src/gtcd/sniffer/Makefile.am
--- src_dot_original/gtcd/sniffer/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/sniffer/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,35 @@
+lib_LTLIBRARIES = libsnifferPlugin.la
+
+INCLUDES = -I$(srcdir)/../storage
+
+noinst_HEADERS = snifferPlugin_tcp.h
+
+libsnifferPlugin_la_SOURCES = snifferPlugin_tcp.cc snifferPlugin_tcp_prot.C
+
+libsnifferPlugin_la_LIBADD =  ../prot/libgtcprot.la
+
+SUFFIXES = .C .cc .x .h
+
+.x.h:
+	-$(RPCC) -h $< || rm -f $@
+
+.x.C:
+	-$(RPCC) -c $< || rm -f $@
+
+snifferPlugin_tcp_prot.C: $(srcdir)/snifferPlugin_tcp_prot.x
+snifferPlugin_tcp_prot.h: $(srcdir)/snifferPlugin_tcp_prot.x
+snifferPlugin_tcp_prot.o: snifferPlugin_tcp_prot.h
+snifferPlugin_tcp_prot.lo: snifferPlugin_tcp_prot.h
+
+snifferPlugin_tcp.o:  snifferPlugin_tcp_prot.h
+snifferPlugin_tcp.lo:  snifferPlugin_tcp_prot.h
+
+dist-hook:
+	cd $(distdir) && rm -f snifferPlugin_tcp_prot.C snifferPlugin_tcp_prot.h
+
+EXTRA_DIST = snifferPlugin_tcp_prot.x
+
+CLEANFILES = core *.core *~ snifferPlugin_tcp_prot.C snifferPlugin_tcp_prot.h
+
+MAINTAINERCLEANFILES = Makefile.in
+
diff -Naur src_dot_original/gtcd/sniffer/snifferPlugin_tcp.cc src/gtcd/sniffer/snifferPlugin_tcp.cc
--- src_dot_original/gtcd/sniffer/snifferPlugin_tcp.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/sniffer/snifferPlugin_tcp.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,174 @@
+#include "snifferPlugin_tcp.h"
+#include "parseopt.h"
+#include "configfile.h"
+
+snifferPlugin_tcp::snifferPlugin_tcp(gtcd_main *_m, snifferPlugin *next_snp)
+  : m(_m)
+{
+  assert (m);
+  sp = m->sp;
+  setup_sniffer_info();
+}
+
+void
+snifferPlugin_tcp::setup_sniffer_info()
+{
+    vec<str> sniffer_unix_socket_list;
+  
+    if (parse_config_sniffer_info (m->configFile, &sniffer_unix_socket_list))
+        fatal << "Cannot parse sniffer info from config file \n";
+    while (sniffer_unix_socket_list.size ()) {
+        str key = sniffer_unix_socket_list.pop_front ();
+        if (!strcasecmp(key, "tcp")) {
+            // TODO :: does this leak memory?
+            sniffer_listen_sock = sniffer_unix_socket_list.pop_front ();
+            warn << "sniffer_listen_sock = " << sniffer_listen_sock << "\n";
+            snifferd_start();
+        }
+    }
+}
+
+void
+snifferPlugin_tcp::accept_connection(int fd)
+{
+
+    //asrv, aclt crap
+    struct sockaddr_un sun;
+    socklen_t sunlen = sizeof(sun);
+    bzero(&sun, sizeof(sun));
+
+    int cs = accept(fd, (struct sockaddr *) &sun, &sunlen);
+    if (fd < 0) {
+        if (errno != EAGAIN)
+            warn << "accept; errno = " << errno << "\n";
+        return;
+    }
+    conn = New snifferTcpConn(cs, sun, this);
+}
+
+void
+snifferPlugin_tcp::put_chunk (svccb *sbp)
+{
+  sniffer_tcp_put_chunk_arg *arg = sbp->Xtmpl getarg<sniffer_tcp_put_chunk_arg>();
+  sniffer_tcp_put_chunk_res res(false);
+  ref<suio> data = New refcounted<suio>;
+  data->copy(arg->data.base(), arg->data.size());
+  if (arg->end) {
+    unsigned char digest[EVP_MAX_MD_SIZE];
+    unsigned int diglen;
+    ref<dot_descriptor> d = New refcounted<dot_descriptor>;
+
+    compute_chunk_id (data, digest, &diglen);
+    d->length = arg->data.size();
+    d->id.set((char *)digest, diglen);
+    ref<desc_result> dres = New refcounted<desc_result> (d, data, false);
+    warnx << "snifferPlugin_tcp: received chunk " << d->id << " len = " << d->length << "\n";
+    res.set_ok(true);
+    sp->put_ichunk (dres->desc, dres->data, true, wrap(this, &snifferPlugin_tcp::put_sp_ichunk_cb));
+  }
+  else {
+    *res.errmsg = "Can only handle full chunks for now";
+  }
+  sbp->replyref(res);
+}
+
+void
+snifferPlugin_tcp::sp_get_chunk_cb(ref<dot_descriptor> d, str s, ptr<desc_result> dres)
+{
+  if (s) 
+    warnx << "snifferPlugin_tcp: chunk not found in storage " << d->id << "\n";
+  else
+    warnx << "snifferPlugin_tcp: chunk found in storage " << d->id << "\n";
+}
+
+void
+snifferPlugin_tcp::put_sp_ichunk_cb (str s)
+{
+  if (s) 
+    warn << s << "\n";
+}
+
+void
+snifferPlugin_tcp::dispatch(snifferTcpConn *helper, svccb *sbp)
+{
+    if (!sbp) {
+        warnx("snifferPlugin_tcp: dispatch(): client closed connection\n");
+        return;
+    }
+
+    switch(sbp->proc()) {
+    case SNIFFER_TCP_PROC_PUT_CHUNK:
+        put_chunk(sbp);
+        break;
+    default:
+        sbp->reject(PROC_UNAVAIL);
+        break;
+    }
+}
+
+void
+snifferPlugin_tcp::snifferd_start()
+{
+    mode_t m = umask(0);
+
+    int fd = unixsocket(sniffer_listen_sock);
+    if (fd < 0 && errno == EADDRINUSE) {
+        /* XXX - This is a slightly race-prone way of cleaning up after a
+         * server bails without unlinking the socket.  If we can't connect
+         * to the socket, it's dead and should be unlinked and rebound.
+         * Two daemons could do this simultaneously, however. */
+        int xfd = unixsocket_connect(sniffer_listen_sock);
+        if (xfd < 0) {
+            unlink(sniffer_listen_sock);
+            fd = unixsocket(sniffer_listen_sock);
+        }
+        else {
+            warn << "closing the socket \n";
+            close (xfd);
+            errno = EADDRINUSE;
+        }
+    }
+    if (fd < 0)
+        fatal ("%s: %m\n", sniffer_listen_sock.cstr ());
+    
+    close_on_exec(fd);
+    make_async(fd);
+
+    umask(m);
+    listen(fd, 150);
+
+    //    warn("Now listening on fd=%d for socket %s \n",fd, sniffer_listen_sock.cstr());
+    /* XXX: Daemonize */
+    fdcb(fd, selread, wrap(this, &snifferPlugin_tcp::accept_connection, fd));
+}
+
+/*
+bool
+snifferPlugin_tcp::configure (str s)
+{
+  return true;
+}
+*/
+
+snifferPlugin_tcp::~snifferPlugin_tcp ()
+{
+  warn << "snifferPlugin_tcp destructor \n";
+}
+
+snifferTcpConn::snifferTcpConn(int fd, const sockaddr_un &sun, snifferPlugin_tcp *parent)
+    : x(axprt_stream::alloc(fd, MAX_PKTSIZE)),
+      c(asrv::alloc(x, sniffer_tcp_program_1, wrap(parent, &snifferPlugin_tcp::dispatch, this)))
+{
+#ifdef HAVE_GETPEEREID 
+  uid_t uid;
+  gid_t gid;
+  if (getpeereid (fd, &uid, &gid) < 0) {
+    warnx ("snifferTcp: getpeerid for fd = %d failed \n",fd);
+  }
+  else {
+    warnx ("snifferTcp: Accepted connection from uid=%d, gid=%d \n", uid, gid);
+  }
+#else 
+  warnx ("snifferTcp: Accepted connection to fd =%d from %s \n",sun.sun_path);
+#endif 
+}
diff -Naur src_dot_original/gtcd/sniffer/snifferPlugin_tcp.h src/gtcd/sniffer/snifferPlugin_tcp.h
--- src_dot_original/gtcd/sniffer/snifferPlugin_tcp.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/sniffer/snifferPlugin_tcp.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,52 @@
+
+
+#ifndef _SNIFFER_TCP_H_
+#define _SNIFFER_TCP_H_ 
+
+#include "snifferPlugin.h"
+#include "gtcd.h"
+#include "snifferPlugin_tcp_prot.h"
+
+class snifferPlugin_tcp;
+
+class snifferTcpConn {
+private:
+    ref<axprt> x;
+    ref<asrv> c;
+
+public:
+    snifferTcpConn(int fd, const sockaddr_un &sun, snifferPlugin_tcp *parent);
+    
+    ~snifferTcpConn()
+    {
+        // TODO :: who closes the connection ?
+    }
+};
+
+
+class snifferPlugin_tcp : public snifferPlugin {
+  
+  gtcd_main *m;
+  storagePlugin *sp;
+  str sniffer_listen_sock;
+  snifferTcpConn *conn;
+
+ public:
+  //bool configure (str s);
+  snifferPlugin_tcp(gtcd_main *_m, snifferPlugin *next_snp);
+  ~snifferPlugin_tcp();
+  void dispatch(snifferTcpConn *helper, svccb *sbp);
+
+ private:
+  void setup_sniffer_info();
+  void accept_connection(int fd);
+  void snifferd_start();
+  void put_chunk (svccb *sbp);
+  void put_sp_ichunk_cb (str s);
+  void sp_get_chunk_cb(ref<dot_descriptor> d, str s, ptr<desc_result> dres);
+
+};
+
+
+
+#endif /* _SNIFFER_TCP_H_ */
diff -Naur src_dot_original/gtcd/sniffer/snifferPlugin_tcp_prot.x src/gtcd/sniffer/snifferPlugin_tcp_prot.x
--- src_dot_original/gtcd/sniffer/snifferPlugin_tcp_prot.x	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/sniffer/snifferPlugin_tcp_prot.x	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,25 @@
+%#include "gtc_prot.h"
+
+struct sniffer_tcp_put_chunk_arg {
+    dot_data data;
+    bool end;
+    metadata md;
+};
+
+union sniffer_tcp_put_chunk_res switch (bool ok) {
+   case false:
+     dot_errmsg errmsg;	
+   case true:
+     void;	
+};
+
+/* Procedures */
+program SNIFFER_TCP_PROGRAM {
+    version SNIFFER_TCP_VERSION {
+        void
+	SNIFFER_TCP_PROC_NULL(void) = 0;
+
+        sniffer_tcp_put_chunk_res
+        SNIFFER_TCP_PROC_PUT_CHUNK(sniffer_tcp_put_chunk_arg) = 5;
+    } = 1;
+} = 400000;
diff -Naur src_dot_original/gtcd/snifferPlugin.h src/gtcd/snifferPlugin.h
--- src_dot_original/gtcd/snifferPlugin.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/snifferPlugin.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,20 @@
+#ifndef _PLUGIN_SNIFFER_H_
+#define _PLUGIN_SNIFFER_H_
+
+#include "gtc_prot.h"
+#include "amisc.h"
+#include "async.h"
+#include "arpc.h"
+
+class gtcd_main;
+
+class snifferPlugin {
+
+public:
+    //virtual bool configure (str s) = 0;
+    virtual ~snifferPlugin () {}
+  
+};
+
+#endif /* _PLUGIN_SNIFFER_H_ */
+
diff -Naur src_dot_original/gtcd/testbed_emulab.h src/gtcd/testbed_emulab.h
--- src_dot_original/gtcd/testbed_emulab.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/testbed_emulab.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1 @@
+#define EMULAB
diff -Naur src_dot_original/gtcd/testbed.h src/gtcd/testbed.h
--- src_dot_original/gtcd/testbed.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/testbed.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1 @@
+#define EMULAB
diff -Naur src_dot_original/gtcd/testbed_map.h src/gtcd/testbed_map.h
--- src_dot_original/gtcd/testbed_map.h	1969-12-31 19:00:00.000000000 -0500
+++ src/gtcd/testbed_map.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1 @@
+#define MAP1
diff -Naur src_dot_original/gtcd/xfer/xferPlugin_gtc.cc src/gtcd/xfer/xferPlugin_gtc.cc
--- src_dot_original/gtcd/xfer/xferPlugin_gtc.cc	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/xfer/xferPlugin_gtc.cc	2008-06-18 20:05:04.000000000 -0400
@@ -6,6 +6,8 @@
 
 #include "xferPlugin_gtc.h"
 #include "parseopt.h"
+#include "configfile.h"
+#include "testbed.h"
 
 #include <openssl/evp.h> /* Shouldn't need!  Abstract the OID contents */
 
@@ -20,6 +22,10 @@
 #define MAX_RPCS_IN_FLIGHT     50
 
 #define DEFAULT_PORT           12000
+#define DEFAULT_PROXY_PORT    16000
+
+
+static str get_default_hostname (str comp);
 
 static ihash<const dot_desc, stat_entry, &stat_entry::cid, &stat_entry::hlink, dd_hash> statCache;
 
@@ -65,6 +71,112 @@
               << "Make sure that this storage plugin comes last\n";
 
     sp = m->sp;
+    numChunksServed = 0;
+    numBytesOfChunksServed = 0;
+}
+
+void 
+xferPlugin_gtc::configure_routing_info_generator () 
+{
+  char routeFile[64];
+  memset (routeFile, 0, sizeof (routeFile));
+  sprintf(routeFile, "/tmp/_dot_%d_routing_table.txt",xfer_gtc_listen_port);
+  str prog_path = find_program ("olsr_route.sh");
+  if (!prog_path) {
+    fatal << "Could not locate olsr_route.sh script \n";
+  }
+  else {
+    warn << "Path of olsr_route.sh is " << prog_path << "\n";
+  }
+  routing_info_args[0] = strdup(prog_path);
+  routing_info_args[1] = strdup(routeFile);
+}
+
+//#define USE_LOOPBACK_ROUTING
+
+#ifdef USE_LOOPBACK_ROUTING
+static str
+extract_hostname (str end_host, str comp)
+{
+  const char *ddata = end_host.cstr();
+  char *p = strstr (ddata, ":");
+  if (p) {
+    return str (ddata, p - ddata);
+  }
+  else return get_default_hostname (comp);
+}
+
+static int 
+extract_port_num (str end_host)
+{
+  const char *ddata = end_host.cstr();
+  char *ptr = strstr (ddata, ":");
+  str port_str;
+  int port_num;
+
+  if (ptr) {
+    port_str = str (ptr+1);
+  }
+  else {
+    port_str = str (ddata);
+  }
+  if (!convertint (port_str, &port_num))
+    fatal << "Cannot parse port number in entry: " << end_host << "\n";
+
+  return port_num;
+}
+#define NUM_TABLE_COLUMNS 2
+str
+xferPlugin_gtc::get_routing_table () 
+{
+  return m->configFile;
+}
+
+#else 
+
+#define NUM_TABLE_COLUMNS 8
+str
+xferPlugin_gtc::get_routing_table () 
+{
+  char *route_cmd;
+  warn << "Using OLSR ROUTING \n";
+  route_cmd = (char *) malloc (strlen(routing_info_args[0]) + strlen(routing_info_args[1]) + 2);
+  sprintf (route_cmd, "%s %s",routing_info_args[0], routing_info_args[1]);
+  if (system (route_cmd) == -1) {
+    perror (route_cmd);
+    fatal << "Routing table generation failed \n";
+  }
+  free (route_cmd);
+  return str(routing_info_args[1]);
+}
+#endif // USE_LOOPBACK_ROUTING
+
+void
+xferPlugin_gtc::setup_routing_info ()
+{
+  vec<str> route_list;
+  str routeFile = get_routing_table ();
+
+  if (parse_config_routing_info (routeFile, &route_list))
+    fatal << "Cannot parse routing info from config file \n";
+  for (unsigned int i = 0; i < route_list.size (); i += NUM_TABLE_COLUMNS) {
+    str key = route_list[i];
+    str value = route_list[i+1];
+    warn << "routing key = " << key << " routing value = " << value << "\n";
+    if (m->no_dot_proxy == true || value == "*" || value == "0.0.0.0") {
+        if (m->no_dot_proxy == true) {
+            warn << "NO DOT PROXY MODE\n";
+        }
+        warn << "routing key = " << key << " routing value = " << key << "\n";
+        routing_table.insert (key, key);
+    }
+    else {
+        routing_table.insert (key, value);
+    }
+  }
+  while (route_list.size ()) {
+    route_list.pop_front();
+  }
 }
 
 bool
@@ -80,7 +192,8 @@
 
     warn << "xferPlugin_gtc constructor with port == " << port_num << "\n";
     xfer_gtc_listen_port = port_num;
-   
+    configure_routing_info_generator ();
+    setup_routing_info ();
     sock = inetsocket(SOCK_STREAM, xfer_gtc_listen_port);
     if (sock < 0)
         fatal("xfer_gtc inetsocket: %m\n");
@@ -94,8 +207,8 @@
     }
 
     listen(sock, 150);
+    
     fdcb(sock, selread, wrap(this, &xferPlugin_gtc::accept_connection, sock));
-
     //delaycb(5, 0, wrap(this, &xferPlugin_gtc::dump_statcache));
 
     return true;
@@ -124,11 +237,74 @@
                   wrap(this, &xferPlugin_gtc::reap_conn_entries));
 }
 
+#define MULTIPLE_IP 1
+static str 
+get_default_hostname (str comp)
+{
+#ifdef MULTIPLE_IP
+
+    /*
+#ifdef EMULAB
+  str comp = "10"; //used in parsing default_hint in gtc plugin for emulab
+#endif
+
+#ifdef MAP1
+  str comp = "1"; //used in parsing default_hint in gtc plugin for emulab
+#endif
+
+#ifdef MAP2
+  str comp = "2"; //used in parsing default_hint in gtc plugin for emulab
+#endif
+    */
+
+#endif
+
+
+  str hostname;
+  vec<in_addr> av;
+
+  if (myipaddrs (&av)) {
+    for (in_addr *ap = av.base (); ap < av.lim (); ap++) {
+      if (ap->s_addr != htonl (INADDR_LOOPBACK)
+	  && ap->s_addr != htonl (0)) {
+	char s[64];
+	if (inet_ntop(AF_INET, ap, s, sizeof(s))) {
+#ifdef MULTIPLE_IP
+	  warn << "xferPlugin_gtc::get_default_hint:: current is "
+	       << s <<"\n";
+	  char *d, *hn = NULL;
+	  
+	  d = strdup(s); 
+	  assert(d != NULL);
+	  if ((hn = strchr(d, '.'))) {
+	    *hn++ = '\0';
+	    str temp = d;
+	    
+	    warn << "xferPlugin_gtc::get_default_hint:: temp is "
+			     << temp <<"\n";
+	    
+	    if (temp == comp) {
+	      hostname = str(s);
+	      warn << "xferPlugin_gtc::get_default_hint:: hint "
+		   << hostname <<"\n";
+	      break;
+	    }
+	  }
+#else
+	  hostname = str(s);
+	  break;
+#endif
+	}
+      }
+    }
+  }
+  return hostname;
+}
+
 void 
 xferPlugin_gtc::get_default_hint(oid_hint *hint)
 {
     str hostname;
-    str comp = "10"; //used in parsing default_hint in gtc plugin for emulab
     unsigned int port;
     strbuf buf;
     
@@ -137,42 +313,7 @@
 #if 1
     // XXX: Make more robust by fixing addr. selection heuristic
     // or by sending multiple addresses as multiple hints
-    vec<in_addr> av;
-    if (myipaddrs (&av)) {
-        for (in_addr *ap = av.base (); ap < av.lim (); ap++) {
-            if (ap->s_addr != htonl (INADDR_LOOPBACK)
-		&& ap->s_addr != htonl (0)) {
-                char s[64];
-                if (inet_ntop(AF_INET, ap, s, sizeof(s))) {
-#ifdef EMULAB
-		    warn << "xferPlugin_gtc::get_default_hint:: current is "
-			 << s <<"\n";
-		    char *d, *hn = NULL;
-		    
-		    d = strdup(s); 
-		    assert(d != NULL);
-		    if ((hn = strchr(d, '.'))) {
-			*hn++ = '\0';
-			str temp = d;
-			
-			warn << "xferPlugin_gtc::get_default_hint:: temp is "
-			     << temp <<"\n";
-			
-			if (temp == comp) {
-			    hostname = str(s);
-			    warn << "xferPlugin_gtc::get_default_hint:: hint "
-				 << hostname <<"\n";
-			    break;
-			}
-		    }
-#else
-		    hostname = str(s);
-		    break;
-#endif
-                }
-            }
-        }
-    }
+    hostname = get_default_hostname (m->first_octet_mask);
 #else
     if ((hostname = myname())) {
 	if (hostname == "localhost") {
@@ -183,7 +324,9 @@
 	hostname = "";
     }
 #endif
-
+#ifdef USE_LOOPBACK_ROUTING
+    hostname = "127.0.0.1";
+#endif // USE_LOOPBACK_ROUTING
     warn << "Hints: hostname:port is " << hostname << ":"
 	 << port << "\n";
 
@@ -297,11 +440,33 @@
 
     warn << "GET_DESCRIPTORS w/ OID " << oid->id << " offset "
          << offset << "\n";
-    
+
+    hint_res result;
+    if (parse_hint(((arg->hints))[0].name, "gtc", &result) < 0)
+      fatal << "No hints to get descriptors from\n";
+    warn << "Using Hints "<< result.hint.hostname << ":" << result.hint.port << "\n";
+
     sp->get_descriptors(oid, wrap(this, &xferPlugin_gtc::remote_get_descriptors_cb,
                                   sbp, offset));
 }
 
+bool
+xferPlugin_gtc::gtc_in_hint_list ( xfergtc_get_chunk_arg *arg)
+{
+  hint_res res;
+  str hostname = get_default_hostname (m->first_octet_mask);
+
+  for (unsigned int i = 0; i < arg->hints.size() ;i++) {
+    // warn << "gtcd::get_init - Hint at pos " << i << " found\n";
+    if (parse_hint (((arg->hints))[0].name, "gtc", &res) > 0) {
+      if ((hostname == res.hint.hostname) && 
+	  (res.hint.port == (unsigned int) xfer_gtc_listen_port))
+	return true;
+    }
+  }
+  return false;
+}
+
 void
 xferPlugin_gtc::remote_get_chunk(svccb *sbp)
 {
@@ -319,21 +484,75 @@
 	s->count++;
     }
 
-    // warn << "Remote get chunk " << *arg <<"\n";
-    sp->get_chunk(d, wrap(this, &xferPlugin_gtc::remote_get_chunk_cb, sbp));
+    warn << "Remote get chunk " << arg->desc.id <<"\n";
+
+    hint_res result;
+    if (parse_hint(((arg->hints))[0].name, "gtc", &result) < 0)
+      fatal << "No hints to get descriptors from\n";
+    warn << "Using Hints "<< result.hint.hostname << ":" << result.hint.port << "\n";
+    sp->get_chunk(d, wrap(this, &xferPlugin_gtc::remote_get_chunk_cb, sbp, 
+			   gtc_in_hint_list (arg), true));
+}
+
+void 
+xferPlugin_gtc::put_sp_ichunk_cb (str s)
+{
+  if (s) 
+    warn << s << "\n";
+}
+
+// sbp below is the argument of the original rpc request that came to 
+// the proxy.
+void 
+xferPlugin_gtc::proxy_get_chunk_cb (svccb *sbp, str s, ptr<desc_result> res)
+{
+  xfergtc_get_chunk_arg *arg = sbp->Xtmpl getarg<xfergtc_get_chunk_arg>();
+  ref<dot_descriptor> d = New refcounted<dot_descriptor> (arg->desc);
+
+  if (s) {
+    xfergtc_get_chunk_res res(false);
+    warn << "Proxy get chunk failed " << s << "\n";
+    *res.errmsg = s;
+    sbp->replyref(res);
+    return;
+  }
+
+  remote_get_chunk_cb (sbp, true, false, NULL, res);
+#ifndef NO_ONPATH_CACHE
+  sp->put_ichunk (res->desc, res->data, true,
+		  wrap (this, &xferPlugin_gtc::put_sp_ichunk_cb));
+  //sp->get_chunk(d, wrap(this, &xferPlugin_gtc::remote_get_chunk_cb, sbp, true, false));
+#endif 
 }
 
+
+int num_send_back = 0;
 void
-xferPlugin_gtc::remote_get_chunk_cb(svccb *sbp, str errmsg, ptr<desc_result> dres)
+xferPlugin_gtc::remote_get_chunk_cb(svccb *sbp, bool last_try, bool servedChunk,
+				    str errmsg, ptr<desc_result> dres)
 {
     xfergtc_get_chunk_arg *arg = sbp->Xtmpl getarg<xfergtc_get_chunk_arg>();
     xfergtc_get_chunk_res res(false);
     
     if (errmsg) {
+      if (last_try) {
 	warn << "get_chunk from sp failed " << errmsg << "\n";
 	*res.errmsg = errmsg;
 	sbp->replyref(res);
-	return;
+      }
+      else {
+	warn << "get_chunk from sp failed in gtc proxy: " << errmsg << "\n";
+	 ref<dot_descriptor> d = New refcounted<dot_descriptor> (arg->desc);
+	 ref<vec<oid_hint> > hints = New refcounted<vec<oid_hint> >;
+	 hints->setsize(arg->hints.size());
+	 
+	 for (unsigned int i = 0; i < arg->hints.size() ;i++) {
+	   // warn << "gtcd::get_init - Hint at pos " << i << " found\n";
+	   (*hints)[i] = (arg->hints[i]);
+	 }
+	 get_chunk(d, hints, wrap (this, &xferPlugin_gtc::proxy_get_chunk_cb, sbp));
+      }
+      return;
     }
     ptr<suio> data = dres->data;
 
@@ -354,19 +573,53 @@
     else {
         res.resok->end = true;
     }
-
+    
+    if (servedChunk) {
+      numChunksServed++;
+      numBytesOfChunksServed += num_bytes;
+    }
+    
     if (arg->offset > 0) {
         data->rembytes(arg->offset);
     }
     res.resok->offset = arg->offset;
     res.resok->data.setsize(num_bytes);
-    // warn << "Sending back " << dres->data->resid() << " bytes\n";
+    res.resok->chunk_id = dres->desc->id;
+    num_send_back++;
+    warn << num_send_back << ": Sending back " << dres->data->resid() << " bytes\n";
+    warn << "numChunksServed = " << numChunksServed <<  "\n";
+    warn << "numBytesOfChunksServed = " << numBytesOfChunksServed <<  "\n";
     data->copyout(res.resok->data.base(), num_bytes);
     sbp->replyref(res);
 }
 
 /* Internal stuff */
 
+int 
+xferPlugin_gtc::get_next_hop (str hint, hint_res *res)
+{
+  int status = parse_hint (hint, "gtc", res);
+  if (status > 0) {
+#ifdef USE_LOOPBACK_ROUTING
+    char route_key[64];
+    memset (route_key, 0, sizeof (route_key));
+    sprintf (route_key, "%s:%d",res->hint.hostname.cstr(),res->hint.port);
+    str *next_hop = routing_table[str(route_key)];
+    if (next_hop == NULL) 
+      fatal << "No routing entry for " << res->hint.hostname << ":" << res->hint.port << "\n";
+    res->hint.hostname = extract_hostname (*next_hop, m->first_octet_mask);
+    res->hint.port = extract_port_num (*next_hop);
+#else
+    setup_routing_info ();
+    str *next_hop = routing_table[res->hint.hostname.cstr()];
+    if (next_hop == NULL) 
+      fatal << "No routing entry for " << res->hint.hostname << ":" << res->hint.port << "\n";
+    res->hint.hostname = *next_hop;
+#endif // USE_LOOPBACK_ROUTING
+  }
+  return status;
+}
+
 void
 xferPlugin_gtc::get_descriptors(ref<dot_oid_md> oid, ref<vec<oid_hint> > hints,
 			        descriptors_cb cb, ptr<closure_t>)
@@ -375,25 +628,24 @@
     hint_res result;
     
     if (parse_hint((*hints)[0].name, "gtc", &result) < 0)
-	fatal << "No hints to get descriptors from\n";
-    
+	fatal << "No hints to get chunk from\n";
     key << result.hint.hostname << ":" << result.hint.port;
-
+    warn << "Getting descriptors from " << key << "\n";
     conn_entry *conn = connCache[key];
     if (!connCache[key]) {
 	tcpconnect(result.hint.hostname, result.hint.port, 
-		   wrap(this, &xferPlugin_gtc::get_descriptors_clnt, oid, cb, key));
+		   wrap(this, &xferPlugin_gtc::get_descriptors_clnt, oid, cb, key, hints));
     }
     else {
         conn->refcount++;
         gettimeofday(&conn->tv, NULL);
-	get_descriptors_int(oid, 0, cb, conn);
+	get_descriptors_int(oid, 0, cb, hints, conn);
     }
 }
 
 void
 xferPlugin_gtc::get_descriptors_clnt(ref<dot_oid_md> oid, descriptors_cb cb, str key,
-			             int fd)
+				     ref<vec<oid_hint> > hints,	int fd)
 {
     if (fd == -1) {
 	(*cb)("could not connect to remote host", NULL, true);
@@ -405,26 +657,28 @@
     conn_entry *conn = New conn_entry(key, c);
     connCache.insert(conn);
     gettimeofday(&conn->tv, NULL);
-    get_descriptors_int(oid, 0, cb, conn);
+    get_descriptors_int(oid, 0, cb, hints, conn);
 }
 
 void xferPlugin_gtc::get_descriptors_int(ref<dot_oid_md> oid, int offset, 
-                                         descriptors_cb cb, conn_entry *conn)
+                                         descriptors_cb cb, ref<vec<oid_hint> > hints,
+					 conn_entry *conn)
 {
     xfergtc_get_descriptors_arg darg;
     ref<xfergtc_get_descriptors_res> dres = 
         New refcounted<xfergtc_get_descriptors_res>;
     darg.oid = *oid;
     darg.offset = offset;
+    darg.hints.set(hints->base(), hints->size());
     conn->c->call(XFERGTC_PROC_GET_DESCRIPTORS, &darg, dres, 
-                  wrap(this, &xferPlugin_gtc::get_desc_internal_cb, cb, oid, conn, 
+                  wrap(this, &xferPlugin_gtc::get_desc_internal_cb, cb, oid, hints, conn, 
                        dres));
     
 }
 
 void
 xferPlugin_gtc::get_desc_internal_cb(descriptors_cb cb, ref<dot_oid_md> oid,
-                                     conn_entry *conn,
+                                      ref<vec<oid_hint> > hints, conn_entry *conn,
                                      ref<xfergtc_get_descriptors_res> res, 
                                      clnt_stat err)
 {
@@ -456,7 +710,7 @@
 
     if (!res->resok->end) {
 	get_descriptors_int(oid, res->resok->count + res->resok->offset, cb,
-                            conn);
+                            hints, conn);
     }
     else {
 	struct timeval tv;
@@ -469,8 +723,9 @@
 }
 
 void
-xferPlugin_gtc::get_chunk_int(ref<dot_descriptor> d, chunk_cb cb, size_t offset,
-                       ref<suio> data, str s, conn_entry *conn)
+xferPlugin_gtc::get_chunk_int(ref<dot_descriptor> d,  ref<vec<oid_hint> > hints,
+			      chunk_cb cb, size_t offset, ref<suio> data, str s, 
+			      conn_entry *conn)
 {
     if (s) {
 	(*cb) (s, NULL);
@@ -480,9 +735,10 @@
     ref<xfergtc_get_chunk_res> res = New refcounted<xfergtc_get_chunk_res>;
     arg.desc = *d;
     arg.offset = offset;
-    //    warn << "calling transfer for " << d->desc << "\n";
+    arg.hints.set (hints->base(), hints->size());
+    warn << "calling transfer for " << d->id << "\n";
     conn->c->call(XFERGTC_PROC_GET_CHUNK, &arg, res, 
-                  wrap(this, &xferPlugin_gtc::get_chunk_internal_cb, cb, d, data, res,
+                  wrap(this, &xferPlugin_gtc::get_chunk_internal_cb, cb, d, hints, data, res,
                        conn));
 }
 
@@ -546,17 +802,18 @@
     strbuf key;
     hint_res result;
     
-    if (parse_hint((*hints)[0].name, "gtc", &result) < 0)
-	fatal << "No hints to get chunk from\n";
+    if (get_next_hop ((*hints)[0].name, &result) < 0)
+         fatal << "No hints to get chunk from\n";
     
     key << result.hint.hostname << ":" << result.hint.port;
-    
-    // warn << "xferPlugin_gtc::get_chunk for " << d->desc << "\n" ;
+
+    warn << "xferPlugin_gtc::get_chunk for " << d->id << " from " << key << "\n" ;
     conn_entry *conn = connCache[key];
     if (!conn) {
 	ref<suio> data = New refcounted<suio>;
-	get_connection(result.hint.hostname, result.hint.port, wrap(this, &xferPlugin_gtc::get_chunk_int, d, cb,
-					0, data));
+	get_connection(result.hint.hostname, result.hint.port, 
+		       wrap(this, &xferPlugin_gtc::get_chunk_int, d, hints,
+			    cb, 0, data));
     }
     else {
         if (conn->refcount >= MAX_RPCS_IN_FLIGHT) {
@@ -567,7 +824,7 @@
             conn->refcount++;
             gettimeofday(&conn->tv, NULL);
             ref<suio> data = New refcounted<suio>;
-            get_chunk_int(d, cb, 0, data, NULL, conn);
+            get_chunk_int(d, hints, cb, 0, data, NULL, conn);
         }
     }
 }
@@ -578,7 +835,7 @@
 			   chunk_cb cb, ptr<closure_t>)
 {
   
-  //warn << "get_chunks received\n";
+    warn << "get_chunks received\n";
 
     // When we want to send chunks in the reverse order from the
     // request, we actually need 'int i' and NOT 'unsigned int i'
@@ -592,8 +849,8 @@
 }
 
 void
-xferPlugin_gtc::get_chunk_clnt(ref<dot_descriptor> d, chunk_cb cb, str key, 
-			int fd)
+xferPlugin_gtc::get_chunk_clnt(ref<dot_descriptor> d,  ref<vec<oid_hint> > hints,
+			       chunk_cb cb, str key, int fd)
 {
     if (fd == -1) {
 	(*cb)("could not connect to remote host", NULL);
@@ -607,7 +864,7 @@
     gettimeofday(&conn->tv, NULL);
 
     ref<suio> data = New refcounted<suio>;
-    get_chunk_int(d, cb, 0, data, NULL, conn);
+    get_chunk_int(d, hints, cb, 0, data, NULL, conn);
 }
 
 void
@@ -623,10 +880,12 @@
     }
 }
 
+int got_reply = 0;
 void
 xferPlugin_gtc::get_chunk_internal_cb(chunk_cb cb, ref<dot_descriptor> d, 
-                               ref<suio> data, ref<xfergtc_get_chunk_res> res,
-			       conn_entry *conn, clnt_stat err)
+				      ref<vec<oid_hint> > hints,
+				      ref<suio> data, ref<xfergtc_get_chunk_res> res,
+				      conn_entry *conn, clnt_stat err)
 {
     if (err) {
         strbuf sb;
@@ -644,44 +903,30 @@
         (*cb)(sb, NULL);
         return;
     }
-    // warn << "Got reply for " << d->id << "\n";
+    got_reply++;
+    warn << got_reply << ": Got reply for " << d->id << "\n";
 
     data->copy(res->resok->data.base(), res->resok->data.size());
     if (res->resok->end) {
-
-	//may be potentially computed without copying into char buf
-	unsigned char digest[EVP_MAX_MD_SIZE];
-	EVP_MD_CTX desc_hash;
-	unsigned int diglen;
-
-	EVP_MD_CTX_init(&desc_hash);
-	EVP_DigestInit(&desc_hash, EVP_sha1());
-
-	char *sbuf = New char[data->resid()];
-	data->copyout(sbuf, data->resid());
-
-	EVP_DigestUpdate(&desc_hash, sbuf, data->resid());
-	EVP_DigestFinal(&desc_hash, digest, &diglen);
-
-	dot_oid chunkname;
-	chunkname.set((char *)digest, diglen);
-	
-	delete[] sbuf;
-
-	if (d->id != chunkname) {
-	    strbuf sb;
-	    sb << __PRETTY_FUNCTION__ << " XFERGTC_PROC_GET_CHUNK returned invalid data\n";
-	    (*cb)(sb, NULL);
-	    return;
-	}
-		
-        ref<desc_result> dres = New refcounted<desc_result> (d, data, false);
-        conn->refcount--;
-        (*cb)(NULL, dres);
-        check_outstanding(conn);
+      dot_desc chunkname;
+      unsigned char digest[EVP_MAX_MD_SIZE];
+      unsigned int diglen;
+
+      compute_chunk_id (data, digest, &diglen);
+      chunkname.set((char *)digest, diglen);
+      if (d->id != chunkname) {
+	strbuf sb;
+	sb << __PRETTY_FUNCTION__ << " XFERGTC_PROC_GET_CHUNK returned invalid data\n";
+	(*cb)(sb, NULL);
+	return;
+      }
+      ref<desc_result> dres = New refcounted<desc_result> (d, data, false);
+      conn->refcount--;
+      (*cb)(NULL, dres);
+      check_outstanding(conn);
     }
     else {
-        get_chunk_int(d, cb, data->resid(), data, NULL, conn);
+      get_chunk_int(d, hints, cb, data->resid(), data, NULL, conn);
     }
 }
 
diff -Naur src_dot_original/gtcd/xfer/xferPlugin_gtc.h src/gtcd/xfer/xferPlugin_gtc.h
--- src_dot_original/gtcd/xfer/xferPlugin_gtc.h	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/xfer/xferPlugin_gtc.h	2008-06-18 20:05:04.000000000 -0400
@@ -82,6 +82,10 @@
     ihash<const str, pending_conn_entry, &pending_conn_entry::key, 
 	&pending_conn_entry::hlink> pendingConnCache;
     timecb_t *tcb;
+  qhash<str, str> routing_table;
+  int numChunksServed;
+  unsigned long numBytesOfChunksServed;
+  char *routing_info_args[2];
 
 public:
     bool configure(str s);
@@ -108,30 +112,31 @@
     void remote_get_bitmap(svccb *sbp);
     
     void update_hints(ref< vec<dot_descriptor> > dv, ref<hv_vec > hints);
-
+  
     xferPlugin_gtc(gtcd_main *_m, xferPlugin *next_xp);
     ~xferPlugin_gtc();
 
 private:
     void remote_get_descriptors_cb(svccb *sbp, unsigned int offset, str s, 
 				   ptr< vec<dot_descriptor> > descs, bool end);
-    void remote_get_chunk_cb(svccb *sbp, str errmsg, ptr<desc_result> dres);
+    void remote_get_chunk_cb(svccb *sbp, bool last_try, bool servedChunk, str errmsg, ptr<desc_result> dres);
 
     void accept_connection(int s);
     void get_descriptors_clnt(ref<dot_oid_md> oid, descriptors_cb cb, str key,
-			      int fd);
+			     ref<vec<oid_hint> > hints,  int fd);
     void get_descriptors_int(ref<dot_oid_md> oid, int offset, descriptors_cb cb,
-			     conn_entry *conn);
+			      ref<vec<oid_hint> > hints, conn_entry *conn);
     void get_desc_internal_cb(descriptors_cb cb, ref<dot_oid_md> oid,
-                              conn_entry *conn,
+                               ref<vec<oid_hint> > hints, conn_entry *conn,
 			      ref<xfergtc_get_descriptors_res> res, 
                               clnt_stat err);
-    void get_chunk_int(ref<dot_descriptor> d, chunk_cb cb, size_t offset,
-                       ref<suio> data, str s, conn_entry *conn);
-    void get_chunk_clnt(ref<dot_descriptor> d, chunk_cb cb, str key, int fd);
-    void get_chunk_internal_cb(chunk_cb cb, ref<dot_descriptor> d,
-                               ref<suio> data, ref<xfergtc_get_chunk_res> res,
-                               conn_entry *conn, clnt_stat err);
+  void get_chunk_int(ref<dot_descriptor> d,  ref<vec<oid_hint> > hints, chunk_cb cb, 
+		     size_t offset, ref<suio> data, str s, conn_entry *conn);
+  void get_chunk_clnt(ref<dot_descriptor> d, ref<vec<oid_hint> > hints, chunk_cb cb, 
+			str key, int fd);
+  void get_chunk_internal_cb(chunk_cb cb, ref<dot_descriptor> d, ref<vec<oid_hint> > hints,
+			     ref<suio> data, ref<xfergtc_get_chunk_res> res,
+			     conn_entry *conn, clnt_stat err);
 
     void establish_connection(str key, int fd);
     void get_connection(str host, int port, conn_cb cb);
@@ -153,7 +158,14 @@
 			      ptr<bitvec> bmp);
     
     void dump_statcache();
-    
+
+  int get_next_hop (str hint, hint_res *res);
+  void proxy_get_chunk_cb (svccb *sbp, str s, ptr<desc_result> res);
+  void put_sp_ichunk_cb (str s);
+  void setup_routing_info ();
+  bool gtc_in_hint_list ( xfergtc_get_chunk_arg *arg);
+  void configure_routing_info_generator ();
+  str get_routing_table ();
 protected:
     void dispatch(xferGtcConn *helper, svccb *sbp);
 };
diff -Naur src_dot_original/gtcd/xfer/xferPlugin_gtc_prot.x src/gtcd/xfer/xferPlugin_gtc_prot.x
--- src_dot_original/gtcd/xfer/xferPlugin_gtc_prot.x	2007-02-06 17:36:55.000000000 -0500
+++ src/gtcd/xfer/xferPlugin_gtc_prot.x	2008-06-18 20:05:04.000000000 -0400
@@ -13,6 +13,7 @@
 struct xfergtc_get_descriptors_arg {
     dot_oid_md oid;
     dot_offset offset;
+    oid_hint hints<>;
 };
 
 struct xfergtc_get_descriptors_res_ok {
@@ -32,10 +33,12 @@
 struct xfergtc_get_chunk_arg {
     dot_descriptor desc;
     dot_offset offset;
+    oid_hint hints<>;	
 };
 
 struct xfergtc_get_chunk_res_ok {
     dot_offset offset;
+    dot_desc chunk_id;	
     dot_data data;
     bool end;
     metadata md;
diff -Naur src_dot_original/ideal-sniffer/contiguous_block.cc src/ideal-sniffer/contiguous_block.cc
--- src_dot_original/ideal-sniffer/contiguous_block.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/contiguous_block.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,151 @@
+#include "contiguous_block.h"
+
+ContiguousBlock::ContiguousBlock()   // Constructor
+{
+    bInit = true;
+    bModified = true;
+    starting_seq_number = 0;
+    next_expected_seq_number = 0;
+    p_s_contiguous_block = new string("");
+}
+
+ContiguousBlock::ContiguousBlock(const ContiguousBlock &copyin)   // Copy constructor to handle pass by value.
+{
+    starting_seq_number = copyin.starting_seq_number;
+    next_expected_seq_number = copyin.next_expected_seq_number;
+    p_s_contiguous_block = new string(*(copyin.p_s_contiguous_block));
+    bInit = copyin.bInit;
+    bModified = copyin.bModified;
+}
+
+ostream &operator<<(ostream &output, const ContiguousBlock &cb)
+{
+    output << cb.starting_seq_number << " " << cb.next_expected_seq_number << " yay" << endl;
+    return output;
+}
+
+ContiguousBlock& ContiguousBlock::operator=(const ContiguousBlock &rhs)
+{
+    this->starting_seq_number = rhs.starting_seq_number;
+    this->next_expected_seq_number = rhs.next_expected_seq_number;
+    return *this;
+}
+
+int ContiguousBlock::operator==(const ContiguousBlock &rhs) const
+{
+    if ( (this->starting_seq_number == rhs.starting_seq_number) && (this->next_expected_seq_number == rhs.next_expected_seq_number) ) return 1;
+    return 0;
+}
+
+// This function is required for built-in STL list functions like sort
+int ContiguousBlock::operator<(const ContiguousBlock &rhs) const
+{
+   if( this->next_expected_seq_number < rhs.starting_seq_number ) return 1;
+   return 0;
+}
+
+void ContiguousBlock::append(const char* str, const int size_payload, const tcp_seq start_seq_number)
+{
+    if (bInit) {
+        starting_seq_number = next_expected_seq_number = start_seq_number;
+        bInit = false;
+    }
+
+    // giving the size_payload param here makes sure that we append \0s too from the char*
+    p_s_contiguous_block->append(str, size_payload);
+    next_expected_seq_number  += size_payload;
+    //cout << "next_expected_seq_number : " << next_expected_seq_number << endl;
+    bModified = true;
+}
+
+// used while merging the next ContiguousBlock with the current one in the list
+void ContiguousBlock::append(const string* str, const tcp_seq end_seq_number)
+{
+    // we don't need the size_payload param as we are using a string and not a char*,
+    // hence the \0s will be copied
+    p_s_contiguous_block->append(*str);
+    next_expected_seq_number = end_seq_number;
+    bModified = true;
+}
+
+// used while merging the next ContiguousBlock with the current one in the list
+void ContiguousBlock::overlapping_append(const string* str, const unsigned int offset, const tcp_seq end_seq_number)
+{
+    // we don't need the size_payload param as we are using a string and not a char*,
+    // hence the \0s will be copied
+    p_s_contiguous_block->append(*str, offset, str->size() - offset);
+    next_expected_seq_number = end_seq_number;
+    bModified = true;
+}
+
+
+void ContiguousBlock::prepend(const char* str, const int size_payload, const tcp_seq start_seq_number)
+{
+    starting_seq_number = start_seq_number;
+
+    //string* new_str = new string(str);
+
+    // giving the size_payload param here makes sure that we append \0s too from the char*
+    string* new_str = new string();
+    new_str->append(str, size_payload);
+
+    new_str->append(*p_s_contiguous_block);
+    delete p_s_contiguous_block;
+    p_s_contiguous_block = new_str;
+    bModified = true;
+}
+
+/*
+int main()
+{
+   list<ContiguousBlock> L;
+   ContiguousBlock cb;
+
+   cb.last_seq_number = 10;
+   L.push_back(cb);  // Insert a new element at the end
+
+   cb.last_seq_number = 3;
+   L.push_back(cb);  // Object passed by value. Uses default member-wise copy constructor
+
+   cb.last_seq_number = 5;
+   L.push_back(cb);
+
+   list<ContiguousBlock>::iterator i;
+
+   for(i=L.begin(); i != L.end(); ++i) cout << (*i).last_seq_number << " "; // print member
+   cout << endl;
+   for(i=L.begin(); i != L.end(); ++i) cout << *i << " "; // print all
+   cout << endl;
+
+   cout << "Sorted: " << endl;
+   L.sort();
+   for(i=L.begin(); i != L.end(); ++i) cout << *i << " "; // print all
+   cout << endl;
+
+   return 0;
+    list<int> l;
+    l.push_back(1);
+    l.push_back(2);
+    l.push_back(3);
+    l.push_back(4);
+
+
+    list<int>::iterator i;
+    for (i = l.begin(); i != l.end(); ++i) {
+        if (*i == 3) {
+            l.insert(i, 5);
+        }
+    }
+
+    for(i=l.begin(); i != l.end(); ++i) {
+
+        if (*i == 5) {
+            list<int>::iterator i2(i);
+            i2++;
+            l.erase(i2);
+        }
+        cout << *i << " "; // print all
+    }
+    cout << endl;
+}
+*/
diff -Naur src_dot_original/ideal-sniffer/contiguous_block.h src/ideal-sniffer/contiguous_block.h
--- src_dot_original/ideal-sniffer/contiguous_block.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/contiguous_block.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,39 @@
+#ifndef _CONTIGUOUS_BLOCKS
+#define _CONTIGUOUS_BLOCKS 1
+
+#include <iostream>
+#include <list>
+#include <netinet/tcp.h>
+
+using namespace std;
+
+typedef u_int tcp_seq;
+
+// The List STL template requires overloading operators =, == and <.
+class ContiguousBlock
+{
+   friend ostream &operator<<(ostream &, const ContiguousBlock &);
+
+ public:
+   tcp_seq starting_seq_number;
+   tcp_seq next_expected_seq_number;
+   string* p_s_contiguous_block;
+   bool bInit;
+   bool bModified;
+
+   ContiguousBlock();
+   ContiguousBlock(const ContiguousBlock &);
+   ~ContiguousBlock()
+       {
+           if(p_s_contiguous_block) delete p_s_contiguous_block;
+       };
+   ContiguousBlock &operator=(const ContiguousBlock &rhs);
+   int operator==(const ContiguousBlock &rhs) const;
+   int operator<(const ContiguousBlock &rhs) const;
+   void append(const char* str, const int size_payload, const tcp_seq start_seq_number);
+   void append(const string* str, const tcp_seq end_seq_number);
+   void overlapping_append(const string* str, const unsigned int offset, const tcp_seq end_seq_number);
+   void prepend(const char* str, const int size_payload, const tcp_seq start_seq_number);
+};
+
+#endif // _CONTIGUOUS_BLOCKS
diff -Naur src_dot_original/ideal-sniffer/crc32.cc src/ideal-sniffer/crc32.cc
--- src_dot_original/ideal-sniffer/crc32.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/crc32.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,143 @@
+/* crc32.c
+ * CRC-32 routine
+ *
+ * $Id: crc32.cpp,v 1.1 2007/02/14 00:05:50 jpang Exp $
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * Copied from README.developer
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Credits:
+ *
+ * Table from Solomon Peachy
+ * Routine from Chris Waters
+ */
+
+#include "types.h"
+
+/*
+ * Table for the AUTODIN/HDLC/802.x CRC.
+ *
+ * Polynomial is
+ *
+ *  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^8 + x^7 +
+ *      x^5 + x^4 + x^2 + x + 1
+ */
+const guint32 crc32_ccitt_table[256] = {
+        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
+        0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
+        0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
+        0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
+        0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
+        0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
+        0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+        0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
+        0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
+        0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
+        0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
+        0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
+        0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
+        0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+        0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
+        0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
+        0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
+        0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
+        0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
+        0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
+        0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
+        0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
+        0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
+        0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
+        0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
+        0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
+        0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
+        0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
+        0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
+        0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
+        0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
+        0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
+        0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
+        0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
+        0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
+        0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
+        0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
+        0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
+        0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
+        0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
+        0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
+        0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
+        0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
+        0x2d02ef8d
+};
+
+#define CRC32_CCITT_SEED    0xFFFFFFFF
+
+guint32
+crc32_ccitt_seed(const guint8 *buf, guint len, guint32 seed);
+
+guint32
+crc32_ccitt(const guint8 *buf, guint len)
+{
+  return ( crc32_ccitt_seed(buf, len, CRC32_CCITT_SEED) );
+}
+
+guint32
+crc32_ccitt_seed(const guint8 *buf, guint len, guint32 seed)
+{
+  guint i;
+  guint32 crc32 = seed;
+
+  for (i = 0; i < len; i++)
+    crc32 = crc32_ccitt_table[(crc32 ^ buf[i]) & 0xff] ^ (crc32 >> 8);
+
+  return ( ~crc32 );
+}
+
+/*
+ * IEEE 802.x version (Ethernet and 802.11, at least) - byte-swap
+ * the result of "crc32()".
+ *
+ * XXX - does this mean we should fetch the Ethernet and 802.11
+ * FCS with "tvb_get_letohl()" rather than "tvb_get_ntohl()",
+ * or is fetching it big-endian and byte-swapping the CRC done
+ * to cope with 802.x sending stuff out in reverse bit order?
+ */
+guint32
+crc32_802(const guint8 *buf, guint len)
+{
+  guint32 c_crc;
+
+  c_crc = crc32_ccitt(buf, len);
+
+  /* Byte reverse. */
+  c_crc = ((unsigned char)(c_crc>>0)<<24) |
+    ((unsigned char)(c_crc>>8)<<16) |
+    ((unsigned char)(c_crc>>16)<<8) |
+    ((unsigned char)(c_crc>>24)<<0);
+
+  return ( c_crc );
+}
diff -Naur src_dot_original/ideal-sniffer/ethertype.h src/ideal-sniffer/ethertype.h
--- src_dot_original/ideal-sniffer/ethertype.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/ethertype.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 1993, 1994, 1996
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/ethertype.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Ethernet types.
+ *
+ * We wrap the declarations with #ifdef, so that if a file includes
+ * <netinet/if_ether.h>, which may declare some of these, we don't
+ * get a bunch of complaints from the C compiler about redefinitions
+ * of these values.
+ *
+ * We declare all of them here so that no file has to include
+ * <netinet/if_ether.h> if all it needs are ETHERTYPE_ values.
+ */
+
+#ifndef ETHERTYPE_LEN
+#define ETHERTYPE_LEN           2
+#endif
+
+#ifndef ETHERTYPE_GRE_ISO
+#define ETHERTYPE_GRE_ISO       0x00FE  /* not really an ethertype only used in GRE */
+#endif
+#ifndef ETHERTYPE_PUP
+#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
+#endif
+#ifndef ETHERTYPE_IP
+#define	ETHERTYPE_IP		0x0800	/* IP protocol */
+#endif
+#ifndef ETHERTYPE_ARP
+#define ETHERTYPE_ARP		0x0806	/* Addr. resolution protocol */
+#endif
+#ifndef ETHERTYPE_REVARP
+#define ETHERTYPE_REVARP	0x8035	/* reverse Addr. resolution protocol */
+#endif
+#ifndef ETHERTYPE_NS
+#define ETHERTYPE_NS		0x0600
+#endif
+#ifndef	ETHERTYPE_SPRITE
+#define	ETHERTYPE_SPRITE	0x0500
+#endif
+#ifndef ETHERTYPE_TRAIL
+#define ETHERTYPE_TRAIL		0x1000
+#endif
+#ifndef	ETHERTYPE_MOPDL
+#define	ETHERTYPE_MOPDL		0x6001
+#endif
+#ifndef	ETHERTYPE_MOPRC
+#define	ETHERTYPE_MOPRC		0x6002
+#endif
+#ifndef	ETHERTYPE_DN
+#define	ETHERTYPE_DN		0x6003
+#endif
+#ifndef	ETHERTYPE_LAT
+#define	ETHERTYPE_LAT		0x6004
+#endif
+#ifndef ETHERTYPE_SCA
+#define ETHERTYPE_SCA		0x6007
+#endif
+#ifndef	ETHERTYPE_LANBRIDGE
+#define	ETHERTYPE_LANBRIDGE	0x8038
+#endif
+#ifndef	ETHERTYPE_DECDNS
+#define	ETHERTYPE_DECDNS	0x803c
+#endif
+#ifndef	ETHERTYPE_DECDTS
+#define	ETHERTYPE_DECDTS	0x803e
+#endif
+#ifndef	ETHERTYPE_VEXP
+#define	ETHERTYPE_VEXP		0x805b
+#endif
+#ifndef	ETHERTYPE_VPROD
+#define	ETHERTYPE_VPROD		0x805c
+#endif
+#ifndef ETHERTYPE_ATALK
+#define ETHERTYPE_ATALK		0x809b
+#endif
+#ifndef ETHERTYPE_AARP
+#define ETHERTYPE_AARP		0x80f3
+#endif
+#ifndef	ETHERTYPE_8021Q
+#define	ETHERTYPE_8021Q		0x8100
+#endif
+#ifndef ETHERTYPE_IPX
+#define ETHERTYPE_IPX		0x8137
+#endif
+#ifndef ETHERTYPE_IPV6
+#define ETHERTYPE_IPV6		0x86dd
+#endif
+#ifndef ETHERTYPE_PPP
+#define	ETHERTYPE_PPP		0x880b
+#endif
+#ifndef ETHERTYPE_SLOW
+#define	ETHERTYPE_SLOW		0x8809
+#endif
+#ifndef	ETHERTYPE_MPLS
+#define	ETHERTYPE_MPLS		0x8847
+#endif
+#ifndef	ETHERTYPE_MPLS_MULTI
+#define	ETHERTYPE_MPLS_MULTI	0x8848
+#endif
+#ifndef ETHERTYPE_PPPOED
+#define ETHERTYPE_PPPOED	0x8863
+#endif
+#ifndef ETHERTYPE_PPPOES
+#define ETHERTYPE_PPPOES	0x8864
+#endif
+#ifndef ETHERTYPE_JUMBO
+#define ETHERTYPE_JUMBO         0x8870
+#endif
+#ifndef ETHERTYPE_EAPOL
+#define ETHERTYPE_EAPOL  	0x888e
+#endif
+#ifndef	ETHERTYPE_LOOPBACK
+#define	ETHERTYPE_LOOPBACK	0x9000
+#endif
+#ifndef	ETHERTYPE_VMAN
+#define	ETHERTYPE_VMAN	        0x9100 /* Extreme VMAN Protocol */ 
+#endif
+#ifndef	ETHERTYPE_ISO
+#define	ETHERTYPE_ISO           0xfefe  /* nonstandard - used in Cisco HDLC encapsulation */
+#endif
+
+extern const struct tok ethertype_values[];
diff -Naur src_dot_original/ideal-sniffer/extract.h src/ideal-sniffer/extract.h
--- src_dot_original/ideal-sniffer/extract.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/extract.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 1992, 1993, 1994, 1995, 1996
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/extract.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Macros to extract possibly-unaligned big-endian integral values.
+ */
+#ifdef LBL_ALIGN
+/*
+ * The processor doesn't natively handle unaligned loads.
+ */
+#ifdef HAVE___ATTRIBUTE__
+/*
+ * We have __attribute__; we assume that means we have __attribute__((packed)).
+ * Declare packed structures containing a u_int16_t and a u_int32_t,
+ * cast the pointer to point to one of those, and fetch through it;
+ * the GCC manual doesn't appear to explicitly say that
+ * __attribute__((packed)) causes the compiler to generate unaligned-safe
+ * code, but it apppears to do so.
+ *
+ * We do this in case the compiler can generate, for this instruction set,
+ * better code to do an unaligned load and pass stuff to "ntohs()" or
+ * "ntohl()" than the code to fetch the bytes one at a time and
+ * assemble them.  (That might not be the case on a little-endian platform,
+ * where "ntohs()" and "ntohl()" might not be done inline.)
+ */
+typedef struct {
+	u_int16_t	val;
+} __attribute__((packed)) unaligned_u_int16_t;
+
+typedef struct {
+	u_int32_t	val;
+} __attribute__((packed)) unaligned_u_int32_t;
+
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)ntohs(((const unaligned_u_int16_t *)(p))->val))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)ntohl(((const unaligned_u_int32_t *)(p))->val))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)(((u_int64_t)ntohl(((const unaligned_u_int32_t *)(p) + 0)->val)) << 32 | \
+		     ((u_int64_t)ntohl(((const unaligned_u_int32_t *)(p) + 1)->val)) << 0))
+
+#else /* HAVE___ATTRIBUTE__ */
+/*
+ * We don't have __attribute__, so do unaligned loads of big-endian
+ * quantities the hard way - fetch the bytes one at a time and
+ * assemble them.
+ */
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)((u_int16_t)*((const u_int8_t *)(p) + 0) << 8 | \
+		     (u_int16_t)*((const u_int8_t *)(p) + 1)))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 0) << 24 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 3)))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)((u_int64_t)*((const u_int8_t *)(p) + 0) << 56 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 1) << 48 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 2) << 40 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 3) << 32 | \
+	             (u_int64_t)*((const u_int8_t *)(p) + 4) << 24 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 5) << 16 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 6) << 8 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 7)))
+#endif /* HAVE___ATTRIBUTE__ */
+#else /* LBL_ALIGN */
+/*
+ * The processor natively handles unaligned loads, so we can just
+ * cast the pointer and fetch through it.
+ */
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)ntohs(*(const u_int16_t *)(p)))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)ntohl(*(const u_int32_t *)(p)))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)(((u_int64_t)ntohl(*((const u_int32_t *)(p) + 0))) << 32 | \
+		     ((u_int64_t)ntohl(*((const u_int32_t *)(p) + 1))) << 0))
+#endif /* LBL_ALIGN */
+
+#define EXTRACT_24BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 0) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2)))
+
+/*
+ * Macros to extract possibly-unaligned little-endian integral values.
+ * XXX - do loads on little-endian machines that support unaligned loads?
+ */
+#define EXTRACT_LE_8BITS(p) (*(p))
+#define EXTRACT_LE_16BITS(p) \
+	((u_int16_t)((u_int16_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int16_t)*((const u_int8_t *)(p) + 0)))
+#define EXTRACT_LE_32BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 3) << 24 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 0)))
+#define EXTRACT_LE_64BITS(p) \
+	((u_int64_t)((u_int64_t)*((const u_int8_t *)(p) + 7) << 56 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 6) << 48 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 5) << 40 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 4) << 32 | \
+	             (u_int64_t)*((const u_int8_t *)(p) + 3) << 24 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 2) << 16 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 0)))
diff -Naur src_dot_original/ideal-sniffer/flow_id.cc src/ideal-sniffer/flow_id.cc
--- src_dot_original/ideal-sniffer/flow_id.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/flow_id.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,138 @@
+#include <map>
+#include <vector>
+#include "flow_id.h"
+
+// Call using FlowId fid = new FlowId(inet_ntoa(ip->ip_src), inet_ntoa(ip->ip_dst), inet_ntoa(ip->ip_src), inet_ntoa(ip->ip_dst));
+
+FlowId::FlowId(const char *sip, const char *dip, unsigned int sp, unsigned int dp) { 
+    srcIp = (char *)malloc(sizeof(char) * (strlen(sip) + 1));
+    dstIp = (char *)malloc(sizeof(char) * (strlen(dip) + 1));
+
+    strcpy(srcIp, sip);
+    strcpy(dstIp, dip);
+
+    srcPort = sp;
+    dstPort = dp;
+}
+
+FlowId::FlowId(const FlowId& fid) { 
+
+    srcIp = (char *)malloc(sizeof(char) * (strlen(fid.srcIp) + 1));
+    dstIp = (char *)malloc(sizeof(char) * (strlen(fid.dstIp) + 1));
+
+    strcpy(srcIp, fid.srcIp);
+    strcpy(dstIp, fid.dstIp);
+
+    srcPort = fid.srcPort;
+    dstPort = fid.dstPort;
+}
+
+FlowId::~FlowId() { 
+    //cout << "d'tor called" << endl;
+    if (srcIp != NULL) {
+        delete srcIp; 
+    }
+    if (dstIp != NULL) {
+        delete dstIp; 
+    }
+}
+
+bool FlowId::operator==(FlowId fid2) {
+    bool retVal = false;
+    if ( (strcmp(this->srcIp, fid2.srcIp) == 0) && (strcmp(this->dstIp, fid2.dstIp) == 0)
+         && (this->srcPort == fid2.srcPort) && (this->dstPort == fid2.dstPort) ) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+bool FlowId::operator<(const FlowId& fid2) {
+    bool retVal = false;
+    if ( (this->srcPort + this->dstPort) < (fid2.srcPort + fid2.dstPort) ) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+void FlowId::print() {
+    cout << this->srcIp << ":" << this->srcPort << " => " << this->dstIp << ":" << this->dstPort << endl;
+}
+
+string* FlowId::toString() {
+    string* ps = new string();
+
+    char buffer[32];
+
+    ps->append(this->srcIp);
+    ps->append(":");
+    sprintf(buffer, "%d", this->srcPort);
+    ps->append(buffer);
+    ps->append(" => ");
+    ps->append(this->dstIp);
+    ps->append(":");
+    sprintf(buffer, "%d", this->dstPort);
+    ps->append(buffer);
+
+    return ps;
+}
+
+
+/*
+struct FlowIdCmp {
+    bool operator()(FlowId* f1, FlowId* f2) const {
+        if (*f1 < *f2) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+};
+
+int main(void) {
+
+    string s1 = "1.1.1.1";
+    string s2 = "2.2.2.2";
+
+    FlowId *fid1 = new FlowId(s1.c_str(), s2.c_str(), 11, 22);
+    FlowId *fid2 = new FlowId(s1.c_str(), s2.c_str(), 11, 23);
+
+    if (*fid1==*fid2) {
+        cout << "yoohoo" << endl;
+    } else {
+        cout << "nada" << endl;
+    }
+
+    vector< pair< FlowId*, vector<string*> > > flow_list;
+
+    vector<string*> v;
+    string* s = new string("a");
+    v.push_back(s);
+    pair< FlowId*, vector<string*> >* p = new pair< FlowId*, vector<string*> >(fid1, v);
+    flow_list.push_back(*p);
+
+    for( unsigned int i = 0; i < flow_list.size(); i++ ) {
+        if ( *(flow_list[i].first) ==  *fid1 ) {
+            cout << "yay!" << endl;
+        }
+        else {
+            cout << "boo!" << endl;
+        }
+    }
+
+    map<FlowId*, string*, FlowIdCmp> flow_map;
+    flow_map[fid1] = new string("hola!");
+    if (NULL == flow_map[fid2]) {
+        flow_map[fid2] = new string("hola again!");
+    }
+
+    map<FlowId*, string*>::iterator mi;
+    
+    cout << "fid1 => " << *(flow_map[fid1]) << endl;
+    cout << "fid2 => " << *(flow_map[fid2]) << endl;
+
+    delete fid1;
+    delete fid2;
+
+    return 0;
+}
+*/
diff -Naur src_dot_original/ideal-sniffer/flow_id.h src/ideal-sniffer/flow_id.h
--- src_dot_original/ideal-sniffer/flow_id.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/flow_id.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,26 @@
+#ifndef _FLOW_ID
+#define _FLOW_ID 1
+
+#include <iostream>
+#include <stdio.h>
+#include <sstream>
+#include <string>
+
+using namespace std;
+
+class FlowId {
+protected:
+    char *srcIp, *dstIp;
+    unsigned int srcPort, dstPort;
+
+public:
+    FlowId(const char *sip, const char *dip, unsigned int sp, unsigned int dp);
+    FlowId(const FlowId& fid);
+    virtual ~FlowId();
+    virtual bool operator==(FlowId);
+    virtual bool operator<(const FlowId&);
+    virtual void print();
+    virtual string* toString();
+};
+
+#endif //_FLOW_ID
diff -Naur src_dot_original/ideal-sniffer/ieee802_11.h src/ideal-sniffer/ieee802_11.h
--- src_dot_original/ideal-sniffer/ieee802_11.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/ieee802_11.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,357 @@
+/* $Id: ieee802_11.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ */
+/* @(#) $Header: /home/cvs/wifitools/wifipcap/ieee802_11.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL) */
+/*
+ * Copyright (c) 2001
+ *	Fortress Technologies
+ *      Charlie Lenahan ( clenahan@fortresstech.com )
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _WLANSEC_IEEE802_11_H
+#define _WLANSEC_IEEE802_11_H 1
+
+/* Lengths of 802.11 header components. */
+#define	IEEE802_11_FC_LEN		2
+#define	IEEE802_11_DUR_LEN		2
+#define	IEEE802_11_DA_LEN		6
+#define	IEEE802_11_SA_LEN		6
+#define	IEEE802_11_BSSID_LEN		6
+#define	IEEE802_11_RA_LEN		6
+#define	IEEE802_11_TA_LEN		6
+#define	IEEE802_11_SEQ_LEN		2
+#define	IEEE802_11_IV_LEN		3
+#define	IEEE802_11_KID_LEN		1
+
+/* Frame check sequence length. */
+#define	IEEE802_11_FCS_LEN		4
+
+/* Lengths of beacon components. */
+#define	IEEE802_11_TSTAMP_LEN		8
+#define	IEEE802_11_BCNINT_LEN		2
+#define	IEEE802_11_CAPINFO_LEN		2
+#define	IEEE802_11_LISTENINT_LEN	2
+
+#define	IEEE802_11_AID_LEN		2
+#define	IEEE802_11_STATUS_LEN		2
+#define	IEEE802_11_REASON_LEN		2
+
+/* Length of previous AP in reassocation frame */
+#define	IEEE802_11_AP_LEN		6
+
+#define	T_MGMT 0x0		/* management */
+#define	T_CTRL 0x1		/* control */
+#define	T_DATA 0x2		/* data */
+#define	T_RESV 0x3		/* reserved */
+
+#define	ST_ASSOC_REQUEST   	0x0
+#define	ST_ASSOC_RESPONSE 	0x1
+#define	ST_REASSOC_REQUEST   	0x2
+#define	ST_REASSOC_RESPONSE  	0x3
+#define	ST_PROBE_REQUEST   	0x4
+#define	ST_PROBE_RESPONSE   	0x5
+/* RESERVED 			0x6  */
+/* RESERVED 			0x7  */
+#define	ST_BEACON   		0x8
+#define	ST_ATIM			0x9
+#define	ST_DISASSOC		0xA
+#define	ST_AUTH			0xB
+#define	ST_DEAUTH		0xC
+/* RESERVED 			0xD  */
+/* RESERVED 			0xE  */
+/* RESERVED 			0xF  */
+
+
+#define	CTRL_PS_POLL	0xA
+#define	CTRL_RTS	0xB
+#define	CTRL_CTS	0xC
+#define	CTRL_ACK	0xD
+#define	CTRL_CF_END	0xE
+#define	CTRL_END_ACK	0xF
+
+#define	DATA_DATA		0x0
+#define	DATA_DATA_CF_ACK	0x1
+#define	DATA_DATA_CF_POLL	0x2
+#define	DATA_DATA_CF_ACK_POLL	0x3
+#define	DATA_NODATA		0x4
+#define	DATA_NODATA_CF_ACK	0x5
+#define	DATA_NODATA_CF_POLL	0x6
+#define	DATA_NODATA_CF_ACK_POLL	0x7
+
+/*
+ * Bits in the frame control field.
+ */
+#define	FC_VERSION(fc)		((fc) & 0x3)
+#define	FC_TYPE(fc)		(((fc) >> 2) & 0x3)
+#define	FC_SUBTYPE(fc)		(((fc) >> 4) & 0xF)
+#define	FC_TO_DS(fc)		((fc) & 0x0100)
+#define	FC_FROM_DS(fc)		((fc) & 0x0200)
+#define	FC_MORE_FLAG(fc)	((fc) & 0x0400)
+#define	FC_RETRY(fc)		((fc) & 0x0800)
+#define	FC_POWER_MGMT(fc)	((fc) & 0x1000)
+#define	FC_MORE_DATA(fc)	((fc) & 0x2000)
+#define	FC_WEP(fc)		((fc) & 0x4000)
+#define	FC_ORDER(fc)		((fc) & 0x8000)
+
+struct mgmt_header_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC da;
+    MAC sa;
+    MAC bssid;
+    
+    u_int16_t seq;
+    u_int8_t  frag;
+};
+
+#define	MGMT_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_DA_LEN+IEEE802_11_SA_LEN+\
+			 IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)
+
+#define	CAPABILITY_ESS(cap)	((cap) & 0x0001)
+#define	CAPABILITY_IBSS(cap)	((cap) & 0x0002)
+#define	CAPABILITY_CFP(cap)	((cap) & 0x0004)
+#define	CAPABILITY_CFP_REQ(cap)	((cap) & 0x0008)
+#define	CAPABILITY_PRIVACY(cap)	((cap) & 0x0010)
+
+typedef enum {
+	NOT_PRESENT,
+	PRESENT,
+	TRUNCATED
+} elem_status_t;
+
+
+struct ssid_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_char		ssid[33];  /* 32 + 1 for null */
+};
+
+struct rates_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	rate[16];
+};
+
+struct challenge_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	text[254]; /* 1-253 + 1 for null */
+};
+
+struct fh_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int16_t	dwell_time;
+	u_int8_t	hop_set;
+	u_int8_t 	hop_pattern;
+	u_int8_t	hop_index;
+};
+
+struct ds_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	channel;
+};
+
+struct cf_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	count;
+	u_int8_t	period;
+	u_int16_t	max_duration;
+	u_int16_t	dur_remaing;
+};
+
+struct tim_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	count;
+	u_int8_t	period;
+	u_int8_t	bitmap_control;
+	u_int8_t	bitmap[251];
+};
+
+#define	E_SSID 		0
+#define	E_RATES 	1
+#define	E_FH	 	2
+#define	E_DS 		3
+#define	E_CF	 	4
+#define	E_TIM	 	5
+#define	E_IBSS 		6
+/* reserved 		7 */
+/* reserved 		8 */
+/* reserved 		9 */
+/* reserved 		10 */
+/* reserved 		11 */
+/* reserved 		12 */
+/* reserved 		13 */
+/* reserved 		14 */
+/* reserved 		15 */
+/* reserved 		16 */
+
+#define	E_CHALLENGE 	16
+/* reserved 		17 */
+/* reserved 		18 */
+/* reserved 		19 */
+/* reserved 		16 */
+/* reserved 		16 */
+
+struct mgmt_body_t {
+	u_int8_t   	timestamp[IEEE802_11_TSTAMP_LEN];
+	u_int16_t  	beacon_interval;
+	u_int16_t 	listen_interval;
+	u_int16_t 	status_code;
+	u_int16_t 	aid;
+	u_char		ap[IEEE802_11_AP_LEN];
+	u_int16_t	reason_code;
+	u_int16_t	auth_alg;
+	u_int16_t	auth_trans_seq_num;
+	elem_status_t	challenge_status;
+	struct challenge_t  challenge;
+	u_int16_t	capability_info;
+	elem_status_t	ssid_status;
+	struct ssid_t	ssid;
+	elem_status_t	rates_status;
+	struct rates_t 	rates;
+	elem_status_t	ds_status;
+	struct ds_t	ds;
+	elem_status_t	cf_status;
+	struct cf_t	cf;
+	elem_status_t	fh_status;
+	struct fh_t	fh;
+	elem_status_t	tim_status;
+	struct tim_t	tim;
+};
+
+// XXX Jeff: no FCS fields are filled in right now
+
+struct ctrl_rts_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC ta;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_RTS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_RA_LEN+IEEE802_11_TA_LEN)
+
+struct ctrl_cts_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_CTS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)
+
+struct ctrl_ack_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_ACK_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)
+
+struct ctrl_ps_poll_t {
+    u_int16_t fc;
+    u_int16_t aid;
+    MAC bssid;
+    MAC ta;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_PS_POLL_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_AID_LEN+\
+				 IEEE802_11_BSSID_LEN+IEEE802_11_TA_LEN)
+
+struct ctrl_end_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_END_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)
+
+struct ctrl_end_ack_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_END_ACK_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+				 IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)
+
+#define	IV_IV(iv)	((iv) & 0xFFFFFF)
+#define	IV_PAD(iv)	(((iv) >> 24) & 0x3F)
+#define	IV_KEYID(iv)	(((iv) >> 30) & 0x03)
+
+struct data_hdr_ibss_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    u_int8_t fcs[4];
+};
+
+struct data_hdr_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    MAC sa;
+    MAC da;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+struct data_hdr_wds_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    MAC ra;
+    MAC ta;
+    MAC sa;
+    MAC da;
+    u_int8_t fcs[4];
+};
+
+#define	DATA_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_SA_LEN+IEEE802_11_DA_LEN+\
+			 IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)
+
+#define	DATA_WDS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+	\
+			 IEEE802_11_RA_LEN+IEEE802_11_TA_LEN+\
+			 IEEE802_11_SA_LEN+IEEE802_11_DA_LEN+IEEE802_11_SEQ_LEN)
+
+/* Jeff: added for fully-decoded wep info */
+struct wep_hdr_t {
+    u_int32_t iv;
+    u_int32_t pad;
+    u_int32_t keyid;
+};
+
+// XXX TKIP/CCMP ?
+
+#endif /* _WLANSEC_IEEE802_11_H */
diff -Naur src_dot_original/ideal-sniffer/llc.h src/ideal-sniffer/llc.h
--- src_dot_original/ideal-sniffer/llc.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/llc.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 1993, 1994, 1997
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/llc.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Definitions for information in the LLC header.
+ */
+
+#define	LLC_U_FMT	3
+#define	LLC_GSAP	1
+#define	LLC_IG	        1 /* Individual / Group */
+#define LLC_S_FMT	1
+
+#define	LLC_U_POLL	0x10
+#define	LLC_IS_POLL	0x0100
+#define	LLC_XID_FI	0x81
+
+#define	LLC_U_CMD(u)	((u) & 0xef)
+#define	LLC_UI		0x03
+#define	LLC_UA		0x63
+#define	LLC_DISC	0x43
+#define	LLC_DM		0x0f
+#define	LLC_SABME	0x6f
+#define	LLC_TEST	0xe3
+#define	LLC_XID		0xaf
+#define	LLC_FRMR	0x87
+
+#define	LLC_S_CMD(is)	(((is) >> 2) & 0x03)
+#define	LLC_RR		0x0001
+#define	LLC_RNR		0x0005
+#define	LLC_REJ		0x0009
+
+#define LLC_IS_NR(is)	(((is) >> 9) & 0x7f)
+#define LLC_I_NS(is)	(((is) >> 1) & 0x7f)
+
+#ifndef LLCSAP_NULL
+#define	LLCSAP_NULL		0x00
+#endif
+#ifndef LLCSAP_GLOBAL
+#define	LLCSAP_GLOBAL		0xff
+#endif
+#ifndef LLCSAP_8021B_I
+#define	LLCSAP_8021B_I		0x02
+#endif
+#ifndef LLCSAP_8021B_G
+#define	LLCSAP_8021B_G		0x03
+#endif
+#ifndef LLCSAP_SNA
+#define	LLCSAP_SNA		0x04
+#endif
+#ifndef LLCSAP_IP
+#define	LLCSAP_IP		0x06
+#endif
+#ifndef LLCSAP_PROWAYNM
+#define	LLCSAP_PROWAYNM		0x0e
+#endif
+#ifndef LLCSAP_8021D
+#define	LLCSAP_8021D		0x42
+#endif
+#ifndef LLCSAP_RS511
+#define	LLCSAP_RS511		0x4e
+#endif
+#ifndef LLCSAP_ISO8208
+#define	LLCSAP_ISO8208		0x7e
+#endif
+#ifndef LLCSAP_PROWAY
+#define	LLCSAP_PROWAY		0x8e
+#endif
+#ifndef LLCSAP_SNAP
+#define	LLCSAP_SNAP		0xaa
+#endif
+#ifndef LLCSAP_IPX
+#define LLCSAP_IPX		0xe0
+#endif
+#ifndef LLCSAP_NETBEUI
+#define LLCSAP_NETBEUI		0xf0
+#endif
+#ifndef LLCSAP_ISONS
+#define	LLCSAP_ISONS		0xfe
+#endif
+
+/*
+ * PIDs for use with OUI_CISCO.
+ */
+#define	PID_CISCO_CDP		0x2000	/* Cisco Discovery Protocol */
+
+/*
+ * PIDs for use with OUI_RFC2684.
+ */
+#define PID_RFC2684_ETH_FCS	0x0001	/* Ethernet, with FCS */
+#define PID_RFC2684_ETH_NOFCS	0x0007	/* Ethernet, without FCS */
+#define PID_RFC2684_802_4_FCS	0x0002	/* 802.4, with FCS */
+#define PID_RFC2684_802_4_NOFCS	0x0008	/* 802.4, without FCS */
+#define PID_RFC2684_802_5_FCS	0x0003	/* 802.5, with FCS */
+#define PID_RFC2684_802_5_NOFCS	0x0009	/* 802.5, without FCS */
+#define PID_RFC2684_FDDI_FCS	0x0004	/* FDDI, with FCS */
+#define PID_RFC2684_FDDI_NOFCS	0x000a	/* FDDI, without FCS */
+#define PID_RFC2684_802_6_FCS	0x0005	/* 802.6, with FCS */
+#define PID_RFC2684_802_6_NOFCS	0x000b	/* 802.6, without FCS */
+#define PID_RFC2684_BPDU	0x000e	/* BPDUs */
+
+/* Jeff: endian-fixed llc/snap header + ethernet type */
+struct llc_hdr_t {
+    uint8_t dsap;
+    uint8_t ssap;
+    uint8_t control;
+    uint16_t oui;
+    uint16_t type;
+};
diff -Naur src_dot_original/ideal-sniffer/Makefile.am src/ideal-sniffer/Makefile.am
--- src_dot_original/ideal-sniffer/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,18 @@
+INCLUDES = -I$(top_srcdir)/gtcd/sniffer -I$(top_srcdir)/gtcd/xfer -I../gtcd/sniffer/ -I../gtcd/xfer/
+
+$(PROGRAMS): $(LDEPS) $(LIBGTC)
+AM_LDFLAGS = -all-static
+bin_PROGRAMS = sniffTcp
+noinst_HEADERS = contiguous_block.h  flow_id.h  reconstructed_chunk.h  types.h  ethertype.h  util.h  extract.h  ieee802_11.h  llc.h  oui.h  SniffTcp.h
+
+sniffTcp_SOURCES = contiguous_block.cc  flow_id.cc  reconstructed_chunk.cc  util.cc  crc32.cc  SniffTcp.cc
+sniffTcp_LDADD =  -lpcap  ../gtcd/sniffer/libsnifferPlugin.la $(LIBGTC) $(LDADD)
+
+SUFFIXES = .cc .h
+
+SniffTcp.o:  ../gtcd/xfer/xferPlugin_gtc_prot.h ../gtcd/sniffer/snifferPlugin_tcp_prot.h ../gtcd/prot/gtc_prot.h
+
+dist-hook:
+
+CLEANFILES = core *.core *~ 
+MAINTAINERCLEANFILES = Makefile.in
diff -Naur src_dot_original/ideal-sniffer/oui.h src/ideal-sniffer/oui.h
--- src_dot_original/ideal-sniffer/oui.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/oui.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,78 @@
+/* @(#) $Header: /home/cvs/wifitools/wifipcap/oui.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL) */
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code
+ * distributions retain the above copyright notice and this paragraph
+ * in its entirety, and (2) distributions including binary code include
+ * the above copyright notice and this paragraph in its entirety in
+ * the documentation or other materials provided with the distribution.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
+ * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
+ * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE.
+ *
+ * Original code by Hannes Gredler (hannes@juniper.net)
+ */
+
+extern struct tok oui_values[];
+extern struct tok smi_values[];
+
+#define OUI_ENCAP_ETHER 0x000000        /* encapsulated Ethernet */
+#define OUI_CISCO       0x00000c        /* Cisco protocols */
+#define OUI_NORTEL      0x000081        /* Nortel SONMP */
+#define OUI_CISCO_90    0x0000f8        /* Cisco bridging */
+#define OUI_RFC2684     0x0080c2        /* RFC 2427/2684 bridged Ethernet */
+#define OUI_ATM_FORUM   0x00A03E        /* ATM Forum */
+#define OUI_CABLE_BPDU  0x00E02F        /* DOCSIS spanning tree BPDU */
+#define OUI_APPLETALK   0x080007        /* Appletalk */
+#define OUI_JUNIPER     0x009069        /* Juniper */
+#define OUI_HP          0x080009        /* Hewlett-Packard */
+
+/*
+ * These are SMI Network Management Private Enterprise Codes for
+ * organizations; see
+ *
+ *	http://www.iana.org/assignments/enterprise-numbers
+ *
+ * for a list.
+ *
+ * List taken from Ethereal's epan/sminmpec.h.
+ */
+#define SMI_IETF                     0 /* reserved - used by the IETF in L2TP? */
+#define SMI_ACC                      5
+#define SMI_CISCO                    9
+#define SMI_HEWLETT_PACKARD          11
+#define SMI_SUN_MICROSYSTEMS         42
+#define SMI_MERIT                    61
+#define SMI_SHIVA                    166
+#define SMI_ERICSSON                 193
+#define SMI_CISCO_VPN5000            255
+#define SMI_LIVINGSTON               307
+#define SMI_MICROSOFT                311
+#define SMI_3COM                     429
+#define SMI_ASCEND                   529
+#define SMI_BAY                      1584
+#define SMI_FOUNDRY                  1991
+#define SMI_VERSANET                 2180
+#define SMI_REDBACK                  2352
+#define SMI_JUNIPER                  2636
+#define SMI_APTIS                    2637
+#define SMI_CISCO_VPN3000            3076
+#define SMI_COSINE                   3085
+#define SMI_SHASTA                   3199
+#define SMI_NETSCREEN                3224
+#define SMI_NOMADIX                  3309
+#define SMI_SIEMENS                  4329
+#define SMI_CABLELABS                4491
+#define SMI_UNISPHERE                4874
+#define SMI_CISCO_BBSM               5263
+#define SMI_THE3GPP2                 5535
+#define SMI_IP_UNPLUGGED             5925
+#define SMI_ISSANNI                  5948
+#define SMI_QUINTUM                  6618
+#define SMI_INTERLINK                6728
+#define SMI_COLUBRIS                 8744
+#define SMI_COLUMBIA_UNIVERSITY      11862
+#define SMI_THE3GPP                  10415
+#define SMI_GEMTEK_SYSTEMS           10529
+#define SMI_WIFI_ALLIANCE            14122
diff -Naur src_dot_original/ideal-sniffer/reconstructed_chunk.cc src/ideal-sniffer/reconstructed_chunk.cc
--- src_dot_original/ideal-sniffer/reconstructed_chunk.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/reconstructed_chunk.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,227 @@
+#include "reconstructed_chunk.h"
+
+ReconstructedChunk::ReconstructedChunk(string *p_cid, int len)
+{
+    p_chunk_id = new string(*p_cid);
+    length = len;
+    chunk_done = false;
+    //p_chunk = (char*) malloc(sizeof(char) * len);
+}
+
+ReconstructedChunk::ReconstructedChunk(const ReconstructedChunk &copyin)
+{
+    p_chunk_id = new string(*(copyin.p_chunk_id));
+    length = copyin.length;
+    flow_seq_map = copyin.flow_seq_map;
+    uniquely_contributing_flows = copyin.uniquely_contributing_flows;
+
+    //p_chunk = (char*) malloc(sizeof(char) * length);
+    //memcpy(p_chunk, copyin.p_chunk, length);
+
+    // XXX : dangerous - not doing deep copy 
+    // - but ok for time being as this presumably is called only when we first insert it into the map in SniffTcp.cc
+    lcb = copyin.lcb;
+    chunk_done = false;
+}
+
+/*
+ostream &operator<<(ostream &output, const ReconstructedChunk &rc)
+{
+    output << *(rc.p_chunk_id) << " : " << rc.length << " : " << *(rc.p_chunk) << endl;
+    return output;
+}
+*/
+
+
+/* this function should be called only after an entry for the tcp flow 
+   is inserted into the flow_seq_map.
+*/
+bool ReconstructedChunk::fill_gaps_in_chunk(FlowId *pFid, string* pFidStr, 
+                                const u_char *payload, int size_payload, 
+                                tcp_seq seq_num, unsigned long *p_numDuplicateBytes) 
+{
+
+    map<string, tcp_seq>::iterator fsi = flow_seq_map.find(*pFidStr);
+    if (fsi != flow_seq_map.end()) {
+
+        bool b_duplicate = false;
+
+        // If it does, check if the current packet is a dup and if so discard.
+        // Else, check if contiguous
+        //    if so fuse
+        //    else append.
+
+
+        tcp_seq starting_seq_number = fsi->second;
+        tcp_seq normalized_seq_num = seq_num - starting_seq_number;
+
+#ifdef AMAR_DEBUG_1
+        cout << "ReconstructedChunk:: " << "Existing flow! For incoming packet => seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)
+             << ". normalized seq # = " << normalized_seq_num << ". Normalized next expected seq # = " << (normalized_seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG_1
+        std::list<ContiguousBlock*>::iterator li;
+        bool bDone = false;
+
+        // TODO :: maybe better to start from the end of the list and move back
+        for (li = lcb.begin(); li != lcb.end(); ++li) {
+            if ( *li !=  0 ) {
+
+                /*
+                  if ( ((seq_num + size_payload) == (*li)->next_expected_seq_number) && (seq_num == (*li)->starting_seq_number) ) {
+                  // duplicate - hence ignore
+                  bDone = true;
+                  break;
+                  }
+
+                  // TODO ::
+                  // there are also cases where
+                  // a) start boundary is the same and the end boundary is different
+                  // b) end bondary is the same and the start boundary is different
+                  // ignoring these cases for the time being
+                  */
+
+#ifdef AMAR_DEBUG_1
+                cout << "ReconstructedChunk:: " << "cb.starting_seq_number = " << (*li)->starting_seq_number 
+                     << "; cb.next_expected_seq_number = " << (*li)->next_expected_seq_number 
+                     << endl;
+#endif //AMAR_DEBUG_1
+
+
+                if ( normalized_seq_num < (*li)->starting_seq_number ) {
+                    if ( (normalized_seq_num + size_payload) == (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "pre-contiguous! prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        (*li)->prepend((const char*)payload, size_payload, normalized_seq_num);
+                    }
+                    else if ( (normalized_seq_num + size_payload) < (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "not pre-contiguous. inserting new cb ..." << endl;
+#endif //AMAR_DEBUG_1
+                        ContiguousBlock* p_cb = new ContiguousBlock();
+                        p_cb->append((const char*)payload, size_payload, normalized_seq_num);
+                        lcb.insert(li, p_cb);
+                    }
+                    else if ( (normalized_seq_num + size_payload) <= (*li)->next_expected_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "pre-contiguous-overlapping! pruning and prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload - ((*li)->starting_seq_number - normalized_seq_num);
+                        (*li)->prepend((const char*)payload, (*li)->starting_seq_number - normalized_seq_num, normalized_seq_num);
+                    }
+                    else {
+                        // ( (normalized_seq_num + size_payload) > (*li)->next_expected_seq_number )
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "overlapping packet! pruning and prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload - ((*li)->starting_seq_number - normalized_seq_num);
+                        (*li)->prepend((const char*)payload, (*li)->starting_seq_number - normalized_seq_num, normalized_seq_num);
+
+                        // TODO :: there is stuff still remaining at the end of the packet.
+                    }
+
+                    bDone = true;
+                    break;
+                }
+                else if ( (normalized_seq_num >= (*li)->starting_seq_number) && 
+                          (normalized_seq_num <= (*li)->next_expected_seq_number) ) {
+                    // new contiguous packet
+#ifdef AMAR_DEBUG_1
+                    cout << "ReconstructedChunk:: " << "contiguous appending ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                    // do something, only if there is extra information
+                    if ( (normalized_seq_num  + size_payload) > (*li)->next_expected_seq_number) {
+
+                        // ignore the overlapping part and just append the extra stuff
+                        string *p_s = new string();
+                        p_s->append((const char*)payload, size_payload);
+
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "old value of numDuplicateBytes = " << *p_numDuplicateBytes << endl;
+                        cout << "ReconstructedChunk:: " << "adding " << ((*li)->next_expected_seq_number - normalized_seq_num) << " to numDuplicateBytes." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + (*li)->next_expected_seq_number - normalized_seq_num;
+                        (*li)->overlapping_append(p_s, (*li)->next_expected_seq_number - normalized_seq_num, normalized_seq_num + size_payload);
+                        delete p_s;
+
+                        std::list<ContiguousBlock*>::iterator li2(li);
+                        li2++;
+                        while (li2 != lcb.end()) {
+                            if ( (*li2)->starting_seq_number <= (*li)->next_expected_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                                cout << "ReconstructedChunk:: " << "merging ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                                if ( (*li2)->next_expected_seq_number > (*li)->next_expected_seq_number ) {
+                                    // time to merge the two
+                                    *p_numDuplicateBytes = *p_numDuplicateBytes + (*li)->next_expected_seq_number - (*li2)->starting_seq_number;
+                                    (*li)->overlapping_append( ((*li2)->p_s_contiguous_block), (*li)->next_expected_seq_number - (*li2)->starting_seq_number, (*li2)->next_expected_seq_number );
+                                    lcb.erase(li2);
+                                    break;
+                                }
+                                else {
+                                    // (*li2)->next_expected_seq_number <= (*li)->next_expected_seq_number
+                                    // the overlap goes beyond the next packet(indicated by li2)
+                                    *p_numDuplicateBytes = *p_numDuplicateBytes + (*li2)->next_expected_seq_number - (*li2)->starting_seq_number;
+				    std::list<ContiguousBlock*>::iterator li3(li2);
+                                    li2++;
+                                    lcb.erase(li3);
+                                }
+                            }
+                            else {
+                                break;
+                            }
+                        }
+                    }
+                    else {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "we already have this information (from some other flow) ignoring ..." << endl;
+#endif //AMAR_DEBUG_1
+                        b_duplicate = true;
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload;
+                    }
+
+                    bDone = true;
+                    break;
+                }
+            }
+        }
+
+        if (!bDone) {
+#ifdef AMAR_DEBUG_1
+            cout << "ReconstructedChunk:: " << "packet from the future, inserting at the end of the list." << endl;
+#endif //AMAR_DEBUG_1
+            ContiguousBlock* p_cb = new ContiguousBlock();
+            p_cb->append((const char*)payload, size_payload, normalized_seq_num);
+            lcb.push_back(p_cb);
+        }
+
+#ifdef AMAR_DEBUG_1
+        cout << "ReconstructedChunk:: " << "# of cbs = " << lcb.size() << endl;
+#endif //AMAR_DEBUG_1
+
+
+        if (false == b_duplicate) {
+            // we inserted something new !
+
+            uniquely_contributing_flows.insert(make_pair(*pFidStr, 0));
+            std::list<ContiguousBlock*>::iterator i = lcb.begin();
+            if (*i != NULL) {
+                if ( (*i)->p_s_contiguous_block->size() >= (unsigned int) length ) return true;
+            }
+        }
+        return false;
+    }
+    return false;
+}
+
+
+const char* ReconstructedChunk::get_data() {
+    const char* p_ret_data = NULL;
+    std::list<ContiguousBlock*>::iterator i = lcb.begin();
+    if (*i != NULL) {
+        p_ret_data = (*i)->p_s_contiguous_block->data();
+    }
+    return p_ret_data;
+}
diff -Naur src_dot_original/ideal-sniffer/reconstructed_chunk.h src/ideal-sniffer/reconstructed_chunk.h
--- src_dot_original/ideal-sniffer/reconstructed_chunk.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/reconstructed_chunk.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,68 @@
+#ifndef _RECONSTRUCTED_CHUNK
+#define _RECONSTRUCTED_CHUNK 1
+
+#include <map>
+#include <iostream>
+#include <netinet/tcp.h>
+
+#include "flow_id.h"
+#include "contiguous_block.h"
+
+using namespace std;
+
+//#define AMAR_DEBUG_1 1
+
+class ReconstructedChunk
+{
+    //friend ostream &operator<<(ostream &, const ReconstructedChunk &);
+
+ public:
+   string* p_chunk_id;
+
+   //char* p_chunk;
+   std::list<ContiguousBlock*> lcb;
+
+   //this is the actual data we transferred for this chunk
+   ContiguousBlock *oracle_data;
+
+   int length;
+   map<string, tcp_seq> flow_seq_map;
+   map<string, int> uniquely_contributing_flows;
+   bool chunk_done;
+
+   ReconstructedChunk(string*, int);
+   ReconstructedChunk(const ReconstructedChunk &);
+   ~ReconstructedChunk() 
+   {
+       if (p_chunk_id)
+           delete p_chunk_id;
+
+       /*
+       if (p_chunk)
+           free(p_chunk);
+       */
+
+       std::list<ContiguousBlock*>::iterator i;
+       for (i = lcb.begin(); i != lcb.end(); ++i) {
+           //print_payload((const u_char*) (*i)->p_s_contiguous_block->c_str(), (*i)->p_s_contiguous_block->size());
+           delete *i;
+       }
+
+       flow_seq_map.clear();
+       uniquely_contributing_flows.clear();
+   };
+   ReconstructedChunk &operator=(const ReconstructedChunk &rhs);
+   int get_flow_offset(FlowId* pFid);
+
+   bool fill_gaps_in_chunk(FlowId *pFid, string* pFidStr, 
+                           const u_char *payload, int size_payload, 
+                           tcp_seq seq_num, unsigned long *p_numDuplicateBytes);
+
+   const char* get_data();
+
+   void fill_oracle_data(ContiguousBlock *in) {
+     oracle_data = in;
+   }
+};
+
+#endif // _RECONSTRUCTED_CHUNK
diff -Naur src_dot_original/ideal-sniffer/SniffTcp.cc src/ideal-sniffer/SniffTcp.cc
--- src_dot_original/ideal-sniffer/SniffTcp.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/SniffTcp.cc	2008-08-11 12:59:55.000000000 -0400
@@ -0,0 +1,2138 @@
+#define DOT_OFFSET_FIELD_FROM_RPC_HEADER 32
+#define DOT_OFFSET_FIELD_LEN 8
+#define RPC_HEADER 0x80
+#define CHUNK_ID_LEN_FIELD 4
+#define LEN_OF_CHUNK_ID 20
+#define CHUNK_LEN_FIELD 4
+
+#include "SniffTcp.h"
+#include <string.h>
+
+#include <netinet/in.h>
+
+#define IDEAL_DEBUG
+#define AMAR_DEBUG
+
+enum run_mode_t {
+  OFFLINE = 0,
+  ONLINE = 1,
+  OFFLINE_ONLINE = 2,
+  ONLINE_WIFI = 3,
+  OFFLINE_ONLINE_WIFI = 4
+};
+
+struct run_params_t {
+  int num_pkts;
+  char *interface;
+  char *socket;
+  run_mode_t mode;
+  char *ip_to_ignore;
+  int multi_chance;
+  char *dump_file_name;
+  char *input_file;
+};
+
+run_params_t g_run_options;
+bool g_multi_chances = true;
+
+// XXX :: TESTING - BEGIN
+FlowId *g_pFid = NULL;
+string *g_pFidStr = NULL;
+// XXX :: TESTING - END
+
+dot_desc string_to_dot_desc (string s);
+
+
+SniffTcp::SniffTcp(const char* s)
+{
+    p_flow_list = new std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >();
+
+    mask_size_in_bytes = 24;
+    memset(mask, 0, mask_size_in_bytes);
+    mask[3] = 1;
+    mask[23] = 1;
+    //print_payload((const u_char*)mask, mask_size_in_bytes);
+
+    numChunksSniffed = 0;
+    numPacketsCaptured = 0;
+    numBytesOfTcpPacketsCaptured = 0;
+    numBytesOfChunksSniffed = 0;
+    numTcpPacketsCaptured = 0;
+    numDuplicateBytes = 0;
+
+    int fd = unixsocket_connect(s);
+    if (fd < 0)
+        fatal("%s: %m\n", s);
+
+    // warn("Connected via FD: %d\n", fd);
+
+    /* Setup GTC connection */
+    warn << "Connected to sniffer pluging listening at " << s << "\n";
+    ptr<axprt_unix> sniffer_x(axprt_unix::alloc(fd, MAX_PKTSIZE));
+    sniffer_c = aclnt::alloc(sniffer_x, sniffer_tcp_program_1);
+}
+
+SniffTcp::SniffTcp(SniffTcp& sniffer)
+{
+    // TODO
+}
+
+SniffTcp::~SniffTcp()
+{
+    //cout << "#####" << endl;
+    while(!p_flow_list->empty()) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = p_flow_list->back();
+        FlowId* pFid = p->first;
+	//pFid->print();
+        delete pFid;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+	//cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ++i) {
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            //print_payload((const u_char*) (*i)->p_s_contiguous_block->c_str(), (*i)->p_s_contiguous_block->size());
+            delete *i;
+        }
+        delete stream_blocks;
+        delete p;
+
+        p_flow_list->pop_back();
+	//cout << "*****" << endl;
+    }
+    delete p_flow_list;
+
+
+    flow_chunk_map.clear();
+    chunkId_reconstructedChunk_map.clear();
+
+    cout << "#####" << endl;
+}
+
+
+/*
+ * print data in rows of 16 bytes: offset   hex   ascii
+ *
+ * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+ */
+void SniffTcp::print_hex_ascii_line(const u_char *payload,
+                                    int len,
+                                    int offset)
+{
+    int i;
+    int gap;
+    const u_char *ch;
+
+    /* offset */
+    printf("%05d   ", offset);
+
+    /* hex */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        printf("%02x ", *ch);
+        ch++;
+        /* print extra space after 8th byte for visual aid */
+        if (i == 7)
+            printf(" ");
+    }
+    /* print space to handle line less than 8 bytes */
+    if (len < 8)
+        printf(" ");
+
+    /* fill hex gap with spaces if not full line */
+    if (len < 16) {
+        gap = 16 - len;
+        for (i = 0; i < gap; i++) {
+            printf("   ");
+        }
+    }
+    printf("   ");
+
+    /* ascii (if printable) */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        if (isprint(*ch))
+            printf("%c", *ch);
+        else
+            printf(".");
+        ch++;
+    }
+
+    printf("\n");
+
+    return;
+}
+
+/*
+ * print packet payload data (avoid printing binary data)
+ */
+void SniffTcp::print_payload(const u_char *payload,
+                             int len)
+{
+    int len_rem = len;
+    int line_width = 16;			/* number of bytes per line */
+    int line_len;
+    int offset = 0;					/* zero-based offset counter */
+    const u_char *ch = payload;
+
+    if (len <= 0)
+        return;
+
+    /* data fits on one line */
+    if (len <= line_width) {
+        print_hex_ascii_line(ch, len, offset);
+        return;
+    }
+
+    /* data spans multiple lines */
+    for ( ;; ) {
+        /* compute current line length */
+        line_len = line_width % len_rem;
+        /* print line */
+        print_hex_ascii_line(ch, line_len, offset);
+        /* compute total remaining */
+        len_rem = len_rem - line_len;
+        /* shift pointer to remaining bytes to print */
+        ch = ch + line_len;
+        /* add offset */
+        offset = offset + line_width;
+        /* check if we have line width chars or less */
+        if (len_rem <= line_width) {
+            /* print last line and get out */
+            print_hex_ascii_line(ch, len_rem, offset);
+            break;
+        }
+    }
+
+    return;
+}
+
+/* handle ethernet packets, much of this code gleaned from
+ * print-ether.c from tcpdump source
+ */
+u_int16_t SniffTcp::handle_ethernet(const struct pcap_pkthdr* pkthdr,
+                                    const u_char* packet)
+{
+    u_int caplen = pkthdr->caplen;
+#ifdef AMAR_DEBUG
+    u_int length = pkthdr->len;
+#endif //AMAR_DEBUG
+    struct ether_header *eptr;  /* net/ethernet.h */
+    u_short ether_type;
+
+    if (caplen < ETHER_HDRLEN) {
+        cout << "Packet length less than ethernet header length." << endl;
+        return ~0;
+    }
+
+    /* lets start with the ether header... */
+    eptr = (struct ether_header *) packet;
+    ether_type = ntohs(eptr->ether_type);
+
+#ifdef AMAR_DEBUG
+    /* print SOURCE DEST TYPE LENGTH */
+    fprintf(stdout,"ETH: ");
+    fprintf(stdout,"[%s => ", ether_ntoa((struct ether_addr*)eptr->ether_shost));
+    fprintf(stdout,"%s] ", ether_ntoa((struct ether_addr*)eptr->ether_dhost));
+
+    /* check to see if we have an ip packet */
+    if (ether_type == ETHERTYPE_IP) {
+        cout << "(IP)";
+    }
+    else  if (ether_type == ETHERTYPE_ARP) {
+        cout << "(ARP)";
+    }
+    else  if (eptr->ether_type == ETHERTYPE_REVARP) {
+        cout << "(RARP)";
+    }
+    else {
+        cout << "(?)";
+    }
+    cout << length << endl;
+#endif //AMAR_DEBUG
+
+    return ether_type;
+}
+
+
+void SniffTcp::handle_ip(u_int length,
+                         const u_char* ip_packet)
+{
+    const struct sniff_ip* ip;
+    u_int ip_hlen, off, version;
+    u_int len;
+    u_int size_tcp_header;
+    const struct sniff_tcp *tcp;
+    const u_char *payload; /* Packet payload */
+    int size_payload;
+
+    /* jump past the ethernet header */
+    ip = (struct sniff_ip*)(ip_packet);
+
+    /* check to see we have a packet of valid length */
+    if (length < sizeof(struct sniff_ip))
+        {
+            printf("Truncated ip packet (length = %d).\n", length);
+            return;
+        }
+
+    // length of the ip packet along with the ip header
+    len     = ntohs(ip->ip_len);
+    ip_hlen = IP_HL(ip)*4; /* header length */
+    version = IP_V(ip);  /* ip version */
+
+    /* check version */
+    if (version != 4) {
+        fprintf(stdout,"Unknown IP version %d\n", version);
+        return;
+    }
+
+    /* check header length */
+    if (ip_hlen < 20) {
+        fprintf(stdout,"Bad-ip-hlen %d \n", ip_hlen);
+        return;
+    }
+
+    /* see if we have as much packet as we should */
+    if(length < len) {
+        printf("Truncated IP - %d bytes missing\n", len - length);
+        return;
+    }
+
+    /* Check to see if we have the first fragment */
+    off = ntohs(ip->ip_off);
+    if ((off & IP_OFFMASK) == 0 ) /* aka no 1's in first 13 bits */
+        {
+#ifdef AMAR_DEBUG
+            /* print SOURCE DESTINATION hlen version len frag_offset */
+            cout << "\tIP: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+#endif //AMAR_DEBUG
+        } else {
+        //#ifdef AMAR_DEBUG
+            cout << "\tIP fragment has arrived: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+        //#endif //AMAR_DEBUG
+    }
+
+    // XXX
+    // IMPORTANT ASSUMPTION :: ignore ip reassembly for the time being !!!
+
+    /* determine protocol */
+    switch(ip->ip_p) {
+        case IPPROTO_TCP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: TCP" << endl;
+#endif //AMAR_DEBUG
+            break;
+
+        case IPPROTO_UDP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: UDP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_ICMP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: ICMP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_IP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: IP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        default:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: unknown" << endl;
+#endif //AMAR_DEBUG
+            return;
+    }
+
+
+    // handle_tcp
+    tcp = (struct sniff_tcp*)(ip_packet + ip_hlen);
+    size_tcp_header = TH_OFF(tcp)*4;
+    if (size_tcp_header < 20) {
+        fprintf(stdout, "\t*! Invalid TCP header length: %u bytes\n", size_tcp_header);
+    }
+    else {
+        payload = (u_char *)(ip_packet + ip_hlen + size_tcp_header);
+
+        /* compute tcp payload (segment) size */
+        size_payload = ntohs(ip->ip_len) - (ip_hlen + size_tcp_header);
+
+        /*
+         * Print payload data; it might be binary, so don't just
+         * treat it as a string.
+         */
+        if (size_payload > 0) {
+            numTcpPacketsCaptured++;
+            numBytesOfTcpPacketsCaptured += size_payload;
+
+            char *src_ip = strdup(inet_ntoa(ip->ip_src));
+            char *dst_ip = strdup(inet_ntoa(ip->ip_dst));
+
+#ifdef AMAR_DEBUG
+            cout << "----------" << endl;
+            cout << "\tTCP Src " << src_ip << ":" << ntohs(tcp->th_sport)
+                 << "; TCP Dst " << dst_ip << ":" << ntohs(tcp->th_dport);
+	    cout << "\tPayload (" << size_payload << " bytes):" << endl;
+            //print_payload(payload, size_payload);
+#endif
+            tcp_seq seq_num = ntohl(tcp->th_seq);
+
+
+            /*
+            // XXX :: TESTING - BEGIN
+            //tcp_seq temp_seq0 = 3659991430;
+            tcp_seq temp_seq0 = 3659989982; // first flow
+            
+            if (seq_num == temp_seq0) {
+                cout << "dropping packet" << endl;
+
+                g_pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+                g_pFidStr = g_pFid->toString();
+
+                return;
+            }
+            // XXX :: TESTING - END
+            */
+
+            FlowId *pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+            string* pFidStr = pFid->toString();
+
+
+            free (src_ip);
+            free (dst_ip);
+
+
+            if (g_multi_chances == false) {
+	        // insert payload into flow_list
+	        insert(pFid, pFidStr, payload, size_payload, seq_num);
+            }
+            else {
+                // NEW - START
+#ifdef AMAR_DEBUG_1
+                cout << "@@@@@ ";
+                pFid->print();
+#endif //AMAR_DEBUG_1
+
+
+                map< string, std::list<string> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+                if (fc_map_i == flow_chunk_map.end()) {
+                    // never seen this flow before (at least never seen a chunk of this flow)
+#ifdef AMAR_DEBUG_1
+                    cout << "never seen this flow before (at least never seen a chunk of this flow)" << endl;
+#endif //AMAR_DEBUG_1
+                
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    // TODO :: for testing only - remove later and replace with line above
+                    p_cid_offset_pair = NULL;
+                    cout << "yo = " << seq_num << endl;
+
+                    tcp_seq temp_seq1 = 3659989982; // first flow
+                    tcp_seq temp_seq2 = 3667694287; // second flow
+
+#if 0
+                    if ( (seq_num == temp_seq1) || (seq_num == temp_seq2)) {
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+#endif //0
+                    if (seq_num == temp_seq2) {
+                        cout << "playing around with seq_num = " << seq_num << endl;
+                        seq_num = temp_seq1;
+                        
+                        // ignore delete for testing purposes
+                        pFid = g_pFid;
+                        pFidStr = g_pFidStr;
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+
+                    // XXX :: TESTING - END
+                    */
+
+
+                    // the packet has a chunk id - either at the starting or somewhere in the middle
+                    if (p_cid_offset_pair != NULL) {
+
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // insert payload into flow_list, size = offset
+                            insert(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        // yes! as this was a new flow, we have to add this flow to the flow_chunk_map
+                        std::list<string> cids;
+                        cids.push_back(*p_chunk_id);
+                
+                        flow_chunk_map[*pFidStr] = cids;
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+				    p_rc->chunk_done = true;
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+				    mapi->second->chunk_done = true;
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+                    } else {
+                        // this packet does not have a chunk id and we have never seen a chunk on this flow,
+                        // go ahead and store it in the flow as a contiguous block
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. inserting into flow_list" << endl;
+#endif //AMAR_DEBUG_1
+                        insert(pFid, pFidStr, payload, size_payload, seq_num);
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                }
+                else {
+
+                    // ah! we have seen a chunk on this flow before
+#ifdef AMAR_DEBUG_1
+                    cout << "we have seen some chunk on this flow before." << endl;
+#endif //AMAR_DEBUG_1
+
+                    // so is the packet that just came in a part of a chunk that we have seen or is it a new one?
+                    // if it is a new one - 
+                    //    it either has the chunk id (if it is the first packet), 
+                    //    or it is an intermediate packet of a new chunk that we have not yet seen
+
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    tcp_seq temp_seq3 = 3659997222;
+                    if ( seq_num == temp_seq3 ) {
+                    cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                    p_cid_offset_pair = new pair<string*, int>(new string("aloha!"), 1004);
+                    }
+                    // XXX :: TESTING - END
+                    */
+
+
+                    if (p_cid_offset_pair != NULL) {
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " 
+			     << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // deal with the first part of the packet wich has no chunk id
+                            deal_with_pkt_without_chunkid(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        std::list<string>::iterator ci; 
+                        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+                            if (*ci == *p_chunk_id) break;
+                        }
+                        if (ci == fc_map_i->second.end()) {
+                            fc_map_i->second.push_back(*p_chunk_id);
+                        }
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+				    p_rc->chunk_done = true;
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+				    mapi->second->chunk_done = true;
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+                    } else {
+                        // this packet does not have a chunk id 
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. deal_with_pkt_without_chunkid()" << endl;
+#endif //AMAR_DEBUG_1
+                        deal_with_pkt_without_chunkid(pFid, pFidStr, payload, size_payload, seq_num);
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                    /*
+                      std::list<string>::iterator si;
+                      for (si = chunkIds.begin(); si != chunkIds.end(); ++si) {
+                      cout << "##### ";
+                      pFid->print();
+                      cout << "==> " << *si << endl;
+                      }
+                    */
+                }
+                // NEW - END
+            }
+
+            delete pFidStr;
+        }
+    }
+
+    //cout << "-------------------------" << endl;
+    return;
+}
+
+void SniffTcp::deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                             const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+    map< string, std::list<string> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+    if (fc_map_i != flow_chunk_map.end()) {
+        std::list<string>::iterator ci; 
+        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+            map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*ci);
+
+            if (mapi != chunkId_reconstructedChunk_map.end()) {
+                tcp_seq starting_seq_number = mapi->second->flow_seq_map[(*pFidStr)];
+                int len = mapi->second->length;
+
+#ifdef AMAR_DEBUG_1
+                warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "checking " << string_to_dot_desc (*ci) 
+                     << "; starting_seq_number = " << starting_seq_number << "; len = " << len 
+                     << "; seq_num of incoming packet = " << seq_num << "\n";
+#endif // AMAR_DEBUG_1
+                // do something only if the packet lies within the chunk
+                if ( (seq_num > starting_seq_number) && (seq_num < (starting_seq_number + len) ) ) {
+#ifdef AMAR_DEBUG_1
+                    warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet fits/overlaps in the chunk " 
+			 << string_to_dot_desc (*ci) << "\n";
+#endif // AMAR_DEBUG_1
+                    bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                    if (b_chunk_done) {
+                        const char* p_data = mapi->second->get_data();
+                        if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                            cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                            cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                            warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+			    mapi->second->chunk_done = true;
+                            send_chunk_to_sniffer_plugin (p_data);
+                        }
+                    }
+                    return;
+                } else {
+#ifdef AMAR_DEBUG_1
+                    warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet does not fit/overlap the chunk "
+			 << string_to_dot_desc (*ci) << "\n";
+#endif // AMAR_DEBUG_1
+                }
+            }
+            
+        }
+
+        // if this packet did not fit into any of the exisiting chunks
+#ifdef AMAR_DEBUG_1
+        cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet did not fit/overlap any chunk. " 
+             << "Inserting into the global tcp flow state (flow_list)" << endl;
+#endif //AMAR_DEBUG_1
+        insert(pFid, pFidStr, payload, size_payload, seq_num);
+    }
+}
+
+void SniffTcp::deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                             FlowId *pFid, string* pFidStr) 
+{
+
+#ifdef AMAR_DEBUG_1
+    cout << "In SniffTcp::deal_with_candidates_for_chunk" << endl;
+#endif //AMAR_DEBUG_1
+    tcp_seq starting_seq_number = p_rc->flow_seq_map[(*pFidStr)];
+    int len = p_rc->length;
+
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0)
+        {
+            std::list<ContiguousBlock*>::iterator li;
+            for (li = p_lcb->begin(); li != p_lcb->end(); ) 
+            {
+                if ( ( *li !=  0 )  &&
+                     ( ((*li)->starting_seq_number > starting_seq_number) && 
+                       ((*li)->starting_seq_number < (starting_seq_number + len) ) )
+                     )
+                    {
+                        /* there is no chance of overlapping - because if it does 
+                           overlap then there would have been a chunk boundary
+                           and we would have already dealt with that case
+                        */
+                        bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, 
+                                                 (const u_char*) (*li)->p_s_contiguous_block->c_str(), 
+                                                 (*li)->p_s_contiguous_block->size(), 
+                                                 (*li)->starting_seq_number);
+
+                        if (b_chunk_done) {
+                            const char* p_data = p_rc->get_data();
+                            if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                cout << "SniffTcp::deal_with_candidates_for_chunk => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+				warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+				p_rc->chunk_done = true;
+                                send_chunk_to_sniffer_plugin (p_data);
+                            }
+                        }
+
+                        // remove *li
+                        p_lcb->erase(li++);
+                }
+                else {
+                    ++li;
+                }
+            }
+        }
+    }    
+}
+
+bool SniffTcp::fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num)
+{
+
+    bool b_chunk_done = false;
+
+    map<string, tcp_seq>::iterator fsi = p_rc->flow_seq_map.find(*pFidStr);
+    if (fsi != p_rc->flow_seq_map.end()) {
+        tcp_seq starting_seq_num = fsi->second;
+        int chunk_len = p_rc->length;
+
+        int diff = ( (seq_num + size_payload) - (starting_seq_num + chunk_len) );
+
+        if (diff < 0) {
+            diff = 0;
+        }
+
+        if (diff  > 0 ) {
+            insert(pFid, pFidStr, payload + size_payload - diff, diff, seq_num + size_payload - diff);
+        }
+        
+        b_chunk_done = p_rc->fill_gaps_in_chunk(pFid, pFidStr, payload, size_payload - diff, seq_num, &numDuplicateBytes);
+    }
+
+    return b_chunk_done;
+}
+
+void SniffTcp::insert(FlowId *pFid, string* pFidStr, 
+                      const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+
+    // check if the fracking flow exists
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        // If it does, check if the current packet is a dup and if so discard.
+        // Else, check if contiguous
+        //    if so fuse
+        //    else append.
+#ifdef AMAR_DEBUG
+        cout << "Existing flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0) {
+            std::list<ContiguousBlock*>::iterator li;
+            bool bDone = false;
+
+            // TODO :: maybe better to start from the end of the list and move back
+            for (li = p_lcb->begin(); li != p_lcb->end(); ++li) {
+                if ( *li !=  0 ) {
+
+                    /*
+                      if ( ((seq_num + size_payload) == (*li)->next_expected_seq_number) && (seq_num == (*li)->starting_seq_number) ) {
+                      // duplicate - hence ignore
+                      bDone = true;
+                      break;
+                      }
+
+                      // TODO ::
+                      // there are also cases where
+                      // a) start boundary is the same and the end boundary is different
+                      // b) end bondary is the same and the start boundary is different
+                      // ignoring these cases for the time being
+                      */
+
+                    if ( seq_num < (*li)->next_expected_seq_number ) {
+                        if ( (seq_num + size_payload) == (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "pre-contiguous! prepending ..." << endl;
+#endif //AMAR_DEBUG
+                            (*li)->prepend((const char*)payload, size_payload, seq_num);
+                        }
+                        else if ( (seq_num + size_payload) < (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "not pre-contiguous. inserting new cb ..." << endl;
+#endif //AMAR_DEBUG
+                            ContiguousBlock* p_cb = new ContiguousBlock();
+                            p_cb->append((const char*)payload, size_payload, seq_num);
+                            p_lcb->insert(li, p_cb);
+                        }
+                        bDone = true;
+                        break;
+                    }
+                    else if (seq_num == (*li)->next_expected_seq_number) {
+                        // new contiguous packet
+#ifdef AMAR_DEBUG
+                        cout << "contiguous. appending ..." << endl;
+#endif //AMAR_DEBUG
+                        (*li)->append((const char*)payload, size_payload, seq_num + size_payload);
+
+                        std::list<ContiguousBlock*>::iterator li2(li);
+                        li2++;
+                        if (li2 != p_lcb->end()) {
+                            if ( (*li)->next_expected_seq_number == (*li2)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                                cout << "merging ..." << endl;
+#endif //AMAR_DEBUG
+                                // time to merge the two
+                                (*li)->append( ((*li2)->p_s_contiguous_block), (*li2)->next_expected_seq_number );
+                                p_lcb->erase(li2);
+                            }
+                        }
+                        bDone = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!bDone) {
+#ifdef AMAR_DEBUG
+                cout << "packet from the future, inserting at the end of the list." << endl;
+#endif //AMAR_DEBUG
+                ContiguousBlock* p_cb = new ContiguousBlock();
+                p_cb->append((const char*)payload, size_payload, seq_num);
+                p_lcb->push_back(p_cb);
+            }
+        }
+#ifdef AMAR_DEBUG
+        cout << "# of cbs = " << p_lcb->size() << endl;
+#endif //AMAR_DEBUG
+
+        //delete pFid;
+    }
+    else {
+#ifdef AMAR_DEBUG
+        cout << "New flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+
+        ContiguousBlock* p_cb = new ContiguousBlock();
+        p_cb->append((const char*)payload, size_payload, seq_num);
+
+        std::list<ContiguousBlock*>* p_lcb = new std::list<ContiguousBlock*>();
+        p_lcb->push_back(p_cb);
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p_pair = new pair< FlowId*, std::list<ContiguousBlock*>* >(pFid, p_lcb);
+        p_flow_list->push_back(p_pair);
+    }
+}
+
+int SniffTcp::get_flow_offset(FlowId* pFid)
+{
+    int offset = -1;
+    if (pFid != 0) {
+        for( unsigned int i = 0; i < (*p_flow_list).size(); i++ ) {
+            if ( *((*p_flow_list)[i]->first) ==  *pFid ) {
+                offset = i;
+                break;
+            }
+        }
+    }
+    return offset;
+}
+
+void SniffTcp::grep_flows_for_chunks()
+{
+    //cout << "In grep_flows_for_chunks" << endl;
+    //cout << "#####" << endl;
+    //cout << "#of flows = " << p_flow_list->size() << endl;
+    for (unsigned int numFlows = 0; numFlows < p_flow_list->size(); numFlows++) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = (*p_flow_list)[numFlows];
+        FlowId* pFid = p->first;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+        //cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ) { // remember to increment i inside!
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            
+            while((*i)->bModified && ((*i)->starting_seq_number < (*i)->next_expected_seq_number) ) {
+                cout << "grepping flow => ";
+                pFid->print();
+                grep_contiguous_block_for_chunks(*i,i,stream_blocks); //enchance this call by passing list and iterator
+            }
+              
+            if ((*i)->starting_seq_number == (*i)->next_expected_seq_number) {
+                // we are done with this block!
+                stream_blocks->erase(i++);
+            }
+            else {
+                ++i;
+            }
+        }
+        //cout << "*****" << endl;
+    }
+    //cout << "#####" << endl;
+}
+
+int SniffTcp::get_length_from_byte_stream(const char *b)
+{
+    int i = 0;
+    //printf("converter# = %d, %x, %x %x %x\n", i, b[0], b[1],b[2],b[3]);
+    i |= b[0] & 0x7F;
+    //printf("# = %d \n", i);
+    i = (i << 8);
+    //printf("# = %d \n", i);
+    i |= b[1] & 0xFF;
+    i = (i << 8);
+    i |= b[2] & 0xFF;
+    i = (i << 8);
+    i |= b[3] & 0xFF;
+
+    //cout<<"return val of converter is"<<i<<endl;
+    return i;
+}
+
+char *seen_chunks[4] = {0, 0, 0, 0};
+
+void
+check_chunk_against_prev (char *buf, int len)
+{
+    static int num_seen = 0;
+    int i;
+
+    for (i = 0; i < num_seen; i++) {
+        if (seen_chunks[i]) {
+            if (memcmp (seen_chunks[i], buf, len) == 0) {
+                warn("chunk of len %d matched %d th chunk \n",len,i);
+                // warn << "will now print chunk id of prev seen chunk \n";
+                //     print_chunk_id (seen_chunks[i], len);
+                // warn << "will now print chunk id of  new chunk \n";
+                // print_chunk_id (buf, len);
+                return;
+            }
+        }
+    }
+    if (num_seen < 4) {
+        seen_chunks[num_seen] = New char[len];		
+        memcpy (seen_chunks[num_seen], buf, len);	
+        warn ("Entering chunk as %d th entry \n",num_seen);
+        num_seen++;
+    }
+}
+
+// Given a pointer to an rpc header in a byte stream, if the byte stream
+// is a DOT chunk response return true and populate (passed by ref) arg chunk_res.
+// If it is not a a chunk response return false.
+// A Dot chunk response is currently expected to have the following features
+// 1. RPC payload >= MIN_PAYLOAD_LENGTH
+// 2. Successful bytes2xdr() on dot chunk response portion of byte stream
+// 3. Chunk size >= MIN_CHUNK_SIZE
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res)
+{
+#define RPC_HEADER_LEN 28
+  assert (chunk_res != NULL);
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+    return false;
+  }
+
+  const u_char *tmp = rpc_header + RPC_HEADER_LEN;
+  rpc_bytes <> value;
+  value.set((char *)tmp, payload_length - RPC_HEADER_LEN);
+#ifdef AMAR_DEBUG_PAYLOAD
+  print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+  if (!bytes2xdr(*chunk_res, value)) {
+      warn << "problem in bytes2xdr\n";
+    return false;
+  }
+  if (chunk_res->resok->data.size () < MIN_CHUNK_SIZE) {
+    return false;
+  }
+
+  return true;
+}
+
+
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res) 
+{
+    assert (chunk_res != NULL);
+
+    int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+    if (payload_length < MIN_PAYLOAD_LENGTH) {
+        return false;
+    }
+    const u_char *tmp = rpc_header + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+    chunk_res->chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+    if (chunk_res->chunk_id_len != LEN_OF_CHUNK_ID) {
+        return false;
+    }
+
+    chunk_res->chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+    chunk_res->chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+    if (chunk_res->chunk_data_len < MIN_CHUNK_SIZE) {
+        return false;
+    }
+    chunk_res->chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+#ifdef AMAR_DEBUG_PAYLOAD
+    print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+
+    return true;
+}
+
+void SniffTcp::send_chunk_to_sniffer_plugin (const char *rpc_buffer)
+{
+//#ifdef AMAR_DEBUG_1
+    cout << "SniffTcp::send_chunk_to_sniffer_plugin => " << "sending to sniffer plugin ..." << endl;
+//#endif //AMAR_DEBUG_1
+#if 1
+    dot_chunk_res_t chunk_res;
+    if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+      cout << "Extracting chunk response failed\n";
+      return;
+    }
+    sniffer_tcp_put_chunk_arg arg;
+    ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+    arg.end = true;
+    arg.data.set ((char *)chunk_res.chunk_data_base, chunk_res.chunk_data_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+    return;
+  }
+  sniffer_tcp_put_chunk_arg arg;
+  ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+  arg.end = true;
+  arg.data.set ((char *)chunk_res.resok->data.base(), chunk_res.resok->data.size());
+#endif 
+  numChunksSniffed++;
+  numBytesOfChunksSniffed += (arg.data.size());
+  sniffer_c->call (SNIFFER_TCP_PROC_PUT_CHUNK, &arg, res,
+		   wrap (this, &SniffTcp::put_chunk_cb, res));
+  if (g_run_options.mode == OFFLINE || g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    usleep (1000);
+  }
+}
+
+void SniffTcp::put_chunk_cb (ref<sniffer_tcp_put_chunk_res> res, clnt_stat err) 
+{
+    if (err) {
+        warn << "Could not send chunk to sniffer plugin \n";
+    }
+    if (!res->ok) {
+        warn << " put chunk to sniffer plugin returned " << *res->errmsg << "\n";
+    }
+    warn << "put chunk to sniffer plugin successful \n" ;
+}
+
+void SniffTcp::grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator it, std::list<ContiguousBlock*>* stream_block)
+{
+    char rpc_header = 0x80;
+    //unsigned int data_size; 
+    string chunk;
+    string tempString;
+
+    //cout << "in grep function to check block starting with seq no = "<< pcb->starting_seq_number << " and size= " << pcb->p_s_contiguous_block->size() << endl;
+    const char *cb_data = pcb->p_s_contiguous_block->c_str();
+    for (unsigned int i = 0; i < pcb->p_s_contiguous_block->size(); i++) {
+        if ( *(cb_data + i) == rpc_header) {
+            //cout << "!!! Found something that looks like the RPC HEADER at " << i << endl;
+	  
+	  pair<string*, int>* p_cid_offset_pair = getChunkId((const u_char*)(cb_data+i), (pcb->p_s_contiguous_block->size()-i));
+	  if ( (i + 3) < pcb->p_s_contiguous_block->size()) {
+                int payload_length = get_length_from_byte_stream((cb_data + i));
+                
+                //unsigned int payload_length1=*(cb_data+i);
+		
+                unsigned int j = i + 8;
+                if ( (j + mask_size_in_bytes) < pcb->p_s_contiguous_block->size() ) {
+
+                    int cmp_result = memcmp((cb_data + j), mask, mask_size_in_bytes);
+                    if (cmp_result == 0) {
+                        //cout << "!!! Found something that looks like a DOT RESPONSE at " << i << endl;
+
+                        unsigned int start = i;
+                        i += (payload_length + 4);
+
+                        //cout << "payload length of RPC =" << payload_length << endl;
+                        if(i <= pcb->p_s_contiguous_block->size()) {  //enough data in the block
+            		
+                            if (start == 0) {
+                                // chunk at the begining of the cb
+
+                                // Amar :: debug start
+                                //cout << "chunk at the start" << endl;
+                                //cout << "size of contiguous block before trimming = " << pcb->p_s_contiguous_block->size() << endl;
+                                // print_payload((const u_char*) (cb_data + start), i);
+                                // Amar :: debug end
+  			        if (p_cid_offset_pair && p_cid_offset_pair->first) {
+				  warn << "Grep id " << string_to_dot_desc(*(p_cid_offset_pair->first)) << "\n";
+				  
+				  //throw it into the chunker map too
+				  map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*(p_cid_offset_pair->first));
+				  ReconstructedChunk *p_rc;
+				  if (mapi == chunkId_reconstructedChunk_map.end()) {
+				    //key not found
+#ifdef IDEAL_DEBUG
+				    warn << "Creating a new key in grep_flows of length " << payload_length << "\n";
+#endif
+				    p_rc = new ReconstructedChunk(p_cid_offset_pair->first, payload_length);
+				    chunkId_reconstructedChunk_map[*p_cid_offset_pair->first] = p_rc;
+				  }
+				  else {
+#ifdef IDEAL_DEBUG
+				    warn << "Key already there in grep_flows\n";
+#endif
+				    p_rc = mapi->second;
+				  }
+				  
+				  p_rc->chunk_done = true;
+				}
+				else {
+				  warn << "Grep noid\n";
+				}
+				
+				send_chunk_to_sniffer_plugin (cb_data + start);
+				pcb->starting_seq_number += i;
+				pcb->p_s_contiguous_block->erase(start, i); // FOR TESTING :: use i-1 for middle chunk test
+				
+                                // Amar :: debug start
+                                //cout << "size of contiguous block after trimming = "<< pcb->p_s_contiguous_block->size() << endl;
+                                // Amar :: debug start
+                                //it--;
+
+                                return;
+                            }
+                            else if ( i == (pcb->p_s_contiguous_block->size()+1) ) //when chunk starts from the middle and goes till the end
+			      {
+				    if (p_cid_offset_pair && p_cid_offset_pair->first)  {
+				      warn << "Grep id " << string_to_dot_desc(*(p_cid_offset_pair->first)) << "\n";
+				      //throw it into the chunker map too
+				      map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*(p_cid_offset_pair->first));
+				      ReconstructedChunk *p_rc;
+				      if (mapi == chunkId_reconstructedChunk_map.end()) {
+					//key not found
+#ifdef IDEAL_DEBUG
+					warn << "Creating a new key in grep_flows of length " << payload_length << "\n";
+#endif
+					p_rc = new ReconstructedChunk(p_cid_offset_pair->first, payload_length);
+					chunkId_reconstructedChunk_map[*p_cid_offset_pair->first] = p_rc;
+				      }
+				      else {
+#ifdef IDEAL_DEBUG
+					warn << "Key already there in grep_flows\n";
+#endif
+					p_rc = mapi->second;
+				      }
+				      
+				      p_rc->chunk_done = true;
+				    }
+				    else {
+				      warn << "Grep noid\n";
+				    }
+				    
+                                    send_chunk_to_sniffer_plugin (cb_data + start);
+                                    //cout << "chunk is at the end. resizing contiguous block." << endl;
+                                    pcb->next_expected_seq_number = start;    
+                                    //cout << "old size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->p_s_contiguous_block->resize(pcb->p_s_contiguous_block->size() - payload_length - 4);
+                                    //cout << "new size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->bModified = false;
+                                    return;
+                                }
+                            else {  //chunk is in the middle of the block like A-chunk-B
+			        
+  			        if (p_cid_offset_pair && p_cid_offset_pair->first)  {
+				  warn << "Grep id " << string_to_dot_desc(*(p_cid_offset_pair->first)) << "\n";
+				  //throw it into the chunker map too
+				  map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*(p_cid_offset_pair->first));
+				  ReconstructedChunk *p_rc;
+				  if (mapi == chunkId_reconstructedChunk_map.end()) {
+				    //key not found
+#ifdef IDEAL_DEBUG
+				    warn << "Creating a new key in grep_flows of length " << payload_length << "\n";
+#endif
+				    p_rc = new ReconstructedChunk(p_cid_offset_pair->first, payload_length);
+				    chunkId_reconstructedChunk_map[*p_cid_offset_pair->first] = p_rc;
+				  }
+				  else {
+#ifdef IDEAL_DEBUG
+				    warn << "Key already there in grep_flows\n";
+#endif
+				    p_rc = mapi->second;
+				  }
+				  
+				  p_rc->chunk_done = true;
+				}
+				else {
+				  warn << "Grep noid\n";
+				} 
+
+                                send_chunk_to_sniffer_plugin (cb_data + start);
+                                //cout << "chunk in the middle" << endl;
+                                ContiguousBlock* p_cb = new ContiguousBlock(); //creating new block to store A
+                                char * tempPointer = (char *)pcb->p_s_contiguous_block;
+                                p_cb->append(tempPointer, start, pcb->starting_seq_number); //filling the new block with A
+                                p_cb->bModified=false;                                    //marking that it has been checked
+                                stream_block->insert(it, p_cb);  //inserting the new block in the new list
+
+                                pcb->starting_seq_number += i;         //changing the initial sequence of the original block
+                                pcb->p_s_contiguous_block->erase(0, i); //erasing the part upto the start of B
+            			       
+                                it--;
+                                return;
+                            }
+                        }
+                        else {
+                            //cout << "waiting for more data to come!" << endl;
+                            pcb->bModified = false;
+                        }
+                      
+                        i--; // i will be incremented in the loop, hence compensating
+                    }
+                }
+            }
+	}
+    }
+    
+    pcb->bModified = false; //indicating that this round has been checked
+}
+
+void 
+run_pcap_live ()
+{
+    //char *dev = "lo";
+  char *dev = g_run_options.interface;
+    char *net = g_run_options.ip_to_ignore; /* dot notation of the network address */
+    char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+    pcap_t* h_pcap;
+    struct bpf_program fp;      /* hold compiled program     */
+    bpf_u_int32 maskp;          /* subnet mask               */
+    bpf_u_int32 netp;           /* ip                        */
+    struct in_addr tmp_addr;
+
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    int ret = pcap_lookupnet(dev, &netp, &maskp, errbuf);
+    if(ret == -1)
+    {
+        printf("%s\n",errbuf);
+        exit(1);
+    }
+
+    /* get the network address in a human readable form */
+    tmp_addr.s_addr = netp;
+    //net = strdup(inet_ntoa(tmp_addr));
+
+    //if(net == NULL)
+    //{
+    //    perror("inet_ntoa");
+    //    exit(1);
+    //}
+    //printf("NET: %s\n", net);
+
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    char *default_filter = "tcp and not port 22 and not port 6010"; 
+    char *host_filter = " and not host "; 
+    int filter_len = strlen(default_filter) + strlen(host_filter) + strlen(net) + 1;
+    char* final_filter = (char *)malloc(sizeof(char *) * filter_len);
+    memset(final_filter, 0, filter_len);
+    sprintf(final_filter, "%s%s%s", default_filter, host_filter, net);
+    cout << "Final Filter: " << final_filter << endl;
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, final_filter, 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+        //pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_ethernet, (u_char *)pSt);
+        pSt->numPacketsCaptured += pcap_dispatch(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    
+        //time_t start1, end1;
+        //time (&start1);
+      
+        pSt->grep_flows_for_chunks();
+
+        cout << "-----" << endl;
+        cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+        cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+        cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+        cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+	cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+        cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+        cout << "~~~~~" << endl;
+        //time (&end1);
+        //double dif1 = difftime (end1, start1);
+        //cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+    free(net);
+}
+
+void 
+run_pcap_live_wifi ()
+{
+  //char *dev = "lo";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+  
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+      pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_wifi, (u_char *)pSt);
+      
+      time_t start1, end1;
+      time (&start1);
+      
+      pSt->grep_flows_for_chunks();
+      
+      time (&end1);
+      double dif1 = difftime (end1, start1);
+      cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+}
+
+void
+run_pcap_offline ()
+{
+    //char *dev = "eth0";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;  
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    //h_pcap = pcap_open_offline("./dot_test_2.dump", errbuf);
+    //h_pcap = pcap_open_offline("./dotdump", errbuf);
+    //h_pcap = pcap_open_offline("./wifidump", errbuf);
+    //h_pcap = pcap_open_offline("./dump2", errbuf);
+    h_pcap = pcap_open_offline(g_run_options.dump_file_name, errbuf);
+
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    /*
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+    */
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp and not port 22 and not port 6010", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+  
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+  
+    pcap_loop(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    //pcap_loop(h_pcap, -1, my_callback_wifi, (u_char *)pSt);
+
+    time_t start1, end1;
+    time (&start1);
+
+    cout << "!!!!! Done with pcap_loop - in grep_flows_for_chunks !!!!!" << endl;
+
+    pSt->grep_flows_for_chunks();
+      
+    time (&end1);
+    double dif1 = difftime (end1, start1);
+    cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    cout << "Offline -----" << endl;
+    cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+    cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+    cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+    cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+    cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+    cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+    cout << "~~~~~" << endl;
+
+    cout << "------------------------------------------------------" << endl;
+    cout << "------------------------------------------------------" << endl;
+    cout << "Starting Ideal analysis" << endl;
+
+    pSt->run_ideal_analysis();
+    cout << "Done analyzing " << endl;
+    delete pSt;
+}
+
+void SniffTcp::run_ideal_analysis()
+{
+  //read a file
+  struct {
+    char id[20];
+    unsigned int length;
+  } chunk_info;
+  
+  char chunk_data[CHUNK_SIZE];
+  
+  FILE *fp;
+  fp = fopen(g_run_options.input_file, "r");
+  if (!fp) 
+    fatal << "Could not open file\n";
+  
+  int count = 0;
+  int total = 0;
+
+  while (!feof(fp)) {
+    
+    //reading the chunk info
+    unsigned int c = fread(&chunk_info, sizeof(char), 24, fp);
+    if (c != 24) 
+      break;
+
+    total++;
+
+    string *key = new string();
+    key->append ((char *)chunk_info.id, 20);
+
+#ifdef IDEAL_DEBUG
+    warn << "Id is " << string_to_dot_desc(*key) << " and length " << chunk_info.length << "\n";
+#endif
+    
+    //reading the data
+    c = fread(chunk_data, sizeof(char), chunk_info.length, fp);
+    if (c != chunk_info.length) 
+      fatal << "Problem in read\n";
+
+    ContiguousBlock *block = new ContiguousBlock();
+    block->append(chunk_data, chunk_info.length, 0);
+    
+    // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+    map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*key);
+    ReconstructedChunk *p_rc;
+    
+    if (mapi == chunkId_reconstructedChunk_map.end()) {
+      //key not found
+#ifdef IDEAL_DEBUG
+      warn << "Creating a new key\n";
+#endif
+      count++;
+      p_rc = new ReconstructedChunk(key, chunk_info.length);
+      chunkId_reconstructedChunk_map[*key] = p_rc;
+    }
+    else {
+#ifdef IDEAL_DEBUG
+      warn << "Found a match\n";
+#endif
+      p_rc = mapi->second;
+    }
+    
+    p_rc->fill_oracle_data(block);
+  }
+ 
+#ifdef IDEAL_DEBUG 
+  warn << "Created " << count << " new chunks and total " 
+       << total << " in the map\n";
+#endif
+  fclose(fp);
+
+  
+  
+}
+
+void SniffTcp::dump_flow_chunk_map()
+{
+  map<string, ReconstructedChunk*>::iterator mapi;
+  unsigned int size = chunkId_reconstructedChunk_map.size();
+  warn << "Size is " << size << "\n";
+  
+  for (mapi = chunkId_reconstructedChunk_map.begin(); 
+       mapi != chunkId_reconstructedChunk_map.end(); mapi++) {
+    ReconstructedChunk *p_rc = mapi->second;
+#ifdef IDEAL_DEBUG
+    warn << "Visiting key " << string_to_dot_desc(*(p_rc->p_chunk_id)) << "\n";
+    if (!p_rc->chunk_done) 
+      warn << "Not completed\n";
+#endif
+  }
+  
+}
+
+void print_usage () 
+{
+  cout << "Usage: sudo ./binary_name" << endl
+       << "              numpackets"  << endl
+       << "              interface"   << endl
+       << "              unix_socket_fqn" << endl 
+       << "              mode" << endl
+       << "              self_interface_ip_to_ignore" << endl
+       << "              multi_chances [0 | 1    default = 1]" << endl
+       << "              dump file name" << endl
+       << "              input file name " << endl;
+  //cout << "mode => 0 = offline | 1 = online | 2 = offline+online | 3 = online_wifi | 4 = offline+online_wifi" << endl;
+  cout << "mode => 0 = offline | 1 = online | 2 = offline+online" << endl;
+  cout << "e.g.: sudo ./sniffTcp 1000 lo /tmp/gtcd_sniff.sock 1 128.2.223.103 1 tcpdump.dmp file1.chunks" << endl;
+}
+
+bool parse_command_line_args (int argc, char **argv)
+{
+  if (argc < 6) {
+    return false;
+  }
+  g_run_options.num_pkts = atoi(argv[1]);
+  g_run_options.interface = argv[2];
+  g_run_options.socket = argv[3];
+  switch (atoi(argv[4])) {
+  case 0:
+    g_run_options.mode = OFFLINE;
+    break;
+  case 1:
+    g_run_options.mode = ONLINE;
+    break;
+  case 2:
+    g_run_options.mode = OFFLINE_ONLINE;
+    break;
+  case 3:
+    g_run_options.mode = ONLINE_WIFI;
+    break;
+  case 4:
+    g_run_options.mode = OFFLINE_ONLINE_WIFI;
+    break;
+  default:
+    return false;
+  }
+  g_run_options.ip_to_ignore = argv[5];
+  if (argc > 6) {
+    g_run_options.multi_chance = atoi (argv[6]);
+  }
+  if (g_run_options.mode == OFFLINE) {
+    g_run_options.dump_file_name = argv[7];
+    g_run_options.input_file = argv[8];
+  }
+
+  return true;
+}
+
+int main(int argc, char **argv)
+{
+    //printf("Sizeof unsinged int = %d\n", sizeof(u_int));
+  
+    /* grab a device to peek into ... */
+    /*
+      dev = pcap_lookupdev(errbuf);
+      if(dev == NULL)
+      {
+      printf("%s\n", errbuf);
+      exit(1);
+      }
+    */
+  if (!parse_command_line_args (argc, argv)) {
+    print_usage ();
+    return 0;
+  }
+  if (g_run_options.multi_chance == 0) {
+    cout << "Running NOT MHEAR\n";
+    g_multi_chances = false;
+  }
+  if (g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    // run_pcap_offline();
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == ONLINE_WIFI) {
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == OFFLINE_ONLINE) {
+    run_pcap_offline ();
+    run_pcap_live (); 
+  }
+  else if (g_run_options.mode == ONLINE) {
+    run_pcap_live (); 
+  }
+  else {
+    run_pcap_offline ();
+  }
+  
+  cout << endl << "Finished" << endl;
+  return 0;
+}
+
+
+extern guint32 crc32_802(const guint8 *buf, guint len);
+
+/* Translate Ethernet address, as seen in struct ether_header, to type MAC. */
+static inline MAC ether2MAC(const uint8_t * ether)
+{
+    return MAC(ether);
+}
+
+/* Extract header length. */
+u_int8_t SniffTcp::extract_header_length(u_int16_t fc)
+{
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            return MGMT_HDRLEN;
+        case T_CTRL:
+            switch (FC_SUBTYPE(fc)) {
+                case CTRL_PS_POLL:
+                    return CTRL_PS_POLL_HDRLEN;
+                case CTRL_RTS:
+                    return CTRL_RTS_HDRLEN;
+                case CTRL_CTS:
+                    return CTRL_CTS_HDRLEN;
+                case CTRL_ACK:
+                    return CTRL_ACK_HDRLEN;
+                case CTRL_CF_END:
+                    return CTRL_END_HDRLEN;
+                case CTRL_END_ACK:
+                    return CTRL_END_ACK_HDRLEN;
+                default:
+                    return 0;
+            }
+        case T_DATA:
+            return (FC_TO_DS(fc) && FC_FROM_DS(fc)) ? 30 : 24;
+        default:
+            return 0;
+    }
+}
+
+void SniffTcp::handle_80211(const u_char* packet, u_int len) 
+{
+    if (len < 2) {
+        return;
+    }
+
+    u_int16_t fc = EXTRACT_LE_16BITS(packet);       //frame control
+    u_int hdrlen = extract_header_length(fc);
+
+    if (len < IEEE802_11_FC_LEN || len < hdrlen) {
+	//cbs->Handle80211Unknown(t, fc, packet, len);
+        //cout << "boo" << endl;
+        return;
+    }
+
+    bool fcs_ok = false;
+    if (Check80211FCS()) {
+	if (len < hdrlen + 4) {
+	    //cerr << "too short to have fcs!" << endl;
+	} else {
+	    // assume fcs is last 4 bytes (?)
+	    u_int32_t fcs_sent = EXTRACT_32BITS(packet+len-4);
+	    u_int32_t fcs = crc32_802(packet, len-4);
+
+	    /*
+	    if (fcs != fcs_sent) {
+		cerr << "bad fcs: ";
+		fprintf (stderr, "%08x != %08x\n", fcs_sent, fcs); 
+	    }
+	    */
+	    
+	    fcs_ok = (fcs == fcs_sent);
+	}
+    }
+
+    // fill in current_frame: type, sn
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            //cout << "mgmt frame" << endl;
+            break;
+        case T_DATA:
+            // TODO :: do the magic!
+            cout << "data frame" << endl;
+            handle_data_frame(packet, len, fc);
+            break;
+        case T_CTRL:
+            //cout << "ctrl frame" << endl;
+            break;
+        default:
+            break;
+    }
+}
+
+void SniffTcp::handle_data_frame(const u_char *ptr, int len, u_int16_t fc)
+{
+    u_int16_t seq_ctl;
+    u_int16_t seq;
+    u_int8_t  frag;
+
+    u_int16_t du = EXTRACT_LE_16BITS(ptr+2);        //duration
+
+    seq_ctl = pletohs(ptr + 22);
+    seq = COOK_SEQUENCE_NUMBER(seq_ctl);
+    frag = COOK_FRAGMENT_NUMBER(seq_ctl);
+
+    bool body = true;
+    int hdrlen = 0;
+
+    if (!FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* ad hoc IBSS */
+        cout << "ad hoc IBSS" << endl;
+	data_hdr_ibss_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	// AMAR:: cbs->Handle80211(t, fc, MAC::null, MAC::null, MAC::null, MAC::null, fcs_ok);
+	// XXX fcs
+	// AMAR:: cbs->Handle80211DataIBSS(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+	body = false;
+    } else if (!FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* frame from AP to STA */
+        cout << "frame from AP to STA" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 16);
+	hdr.da = ether2MAC(ptr + 4);
+	hdr.bssid = ether2MAC(ptr + 10);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataFromAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* frame from STA to AP */
+        cout << "frame from STA to AP" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 10);
+	hdr.da = ether2MAC(ptr + 16);
+	hdr.bssid = ether2MAC(ptr + 4);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataToAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* WDS */
+        cout << "WDS" << endl;
+	data_hdr_wds_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.ra = ether2MAC(ptr+4);
+	hdr.ta = ether2MAC(ptr+10);
+	hdr.da = ether2MAC(ptr+16);
+	hdr.da = ether2MAC(ptr+24);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, fcs_ok);
+	// AMAR:: cbs->Handle80211DataWDS(t, &hdr, ptr+DATA_WDS_HDRLEN, len-DATA_WDS_HDRLEN);
+	hdrlen = DATA_WDS_HDRLEN;
+    }
+
+    if (body) {
+	if (FC_WEP(fc)) {
+	    //handle_wep(t, cbs, ptr+hdrlen, len-hdrlen-4 /* FCS */);
+            cout << "who need wep?" << endl;
+	} else {
+            cout << "lls finally!" << endl;
+	    handle_llc(ptr+hdrlen, len-hdrlen-4 /* FCS */);
+	}
+    }
+}
+
+void SniffTcp::handle_llc(const u_char *ptr, int len)
+{
+    if (len < 7) {
+	// truncated header!
+        return;
+    }
+
+    // Jeff: XXX This assumes ethernet->80211 llc encapsulation and is
+    // NOT correct for all forms of LLC encapsulation. See print-llc.c
+    // in tcpdump for a more complete parsing of this header.
+
+    llc_hdr_t hdr;
+    hdr.dsap = EXTRACT_LE_8BITS(ptr);
+    hdr.ssap = EXTRACT_LE_8BITS(ptr + 1);
+    hdr.control = EXTRACT_LE_8BITS(ptr + 2);
+    hdr.oui = EXTRACT_24BITS(ptr + 3);
+    hdr.type = EXTRACT_16BITS(ptr + 6);
+
+    if (hdr.oui != OUI_ENCAP_ETHER && hdr.oui != OUI_CISCO_90) {
+        cout << "Not encapsulated Ethernet and not Cisco protocols." << endl;
+        return;
+    }
+
+    ptr += 8;
+    len -= 8;
+
+    //cbs->HandleLLC(t, &hdr, ptr, len);
+
+    switch (hdr.type) {
+        case ETHERTYPE_IP:
+            // TODO :: call something similar to
+            cout << "DATA!" << endl;
+            //handle_ip(len, ptr);
+            break;
+        default:
+            break;
+    }
+}
+
+const u_char *
+SniffTcp::rpc_header_in_stream (const u_char *payload, int len) 
+{
+  for (int i = 0; i < len; i++) {
+    if (payload[i] == RPC_HEADER) {
+      if (memcmp((payload + i + 8), mask, mask_size_in_bytes) == 0)
+	return (payload + i);
+    }
+  }
+  return NULL;
+}
+
+ void print_chunk_id (string *s) 
+{
+  dot_desc id;
+  id.set((char *) s->data(), s->length());
+  warn << "Chunk id = " << id << " \n";
+}
+
+dot_desc string_to_dot_desc (string s)
+{
+  dot_desc id;
+  id.set((char *) s.data(), s.length());
+  return id;
+}
+
+pair<string*, int>* SniffTcp::getChunkId(const u_char *payload, int len)
+{
+  // should return NULL if chunkId not found in the payload
+  
+  //return new pair<string*, int>(new string("hola!"), 0);
+  const u_char *rpc_buffer = rpc_header_in_stream (payload, len);
+  if (rpc_buffer == NULL) {
+    return NULL;
+  }
+  string *s = new string();
+  int rpc_offset = rpc_buffer - payload;
+  pair<string *, int> *p;
+
+  /*
+#if 1
+  dot_chunk_res_t chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return false;
+  }
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return NULL;
+  }
+  warn << "getChunkId () " << chunk_res.resok->chunk_id << " in stream \n";
+  s->append (chunk_res.resok->chunk_id.base(), chunk_res.resok->chunk_id.size());
+#endif 
+  */
+
+
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_buffer);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+      return false;
+  }
+  const u_char *tmp = rpc_buffer + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+
+  dot_chunk_res_t chunk_res;
+  chunk_res.chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+  if (chunk_res.chunk_id_len != LEN_OF_CHUNK_ID) {
+      return NULL;
+  }
+
+  chunk_res.chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+  chunk_res.chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+  if (chunk_res.chunk_data_len < MIN_CHUNK_SIZE) {
+      return NULL;
+  }
+  chunk_res.chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+  p = new pair<string *, int>(s, rpc_offset);  
+#ifdef AMAR_DEBUG_1
+  warn << "getChunkId:" <<  "will return pair (" << string_to_dot_desc (*(p->first)) << "," << p->second << ")\n";  
+#endif // AMAR_DEBUG_1
+  return p;
+}
+
+/*
+int SniffTcp::getChunkLength(const u_char *payload, int len) {
+    return get_length_from_byte_stream(payload);
+    //return 16384; // 16K
+}
+*/
diff -Naur src_dot_original/ideal-sniffer/SniffTcp.h src/ideal-sniffer/SniffTcp.h
--- src_dot_original/ideal-sniffer/SniffTcp.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/SniffTcp.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,292 @@
+#ifndef _SNIFF_TCP
+#define _SNIFF_TCP 1
+
+
+#include "async.h"
+#include "amisc.h"
+#include "arpc.h"
+#include "xdrmisc.h"
+
+#include "gtc.h"
+#include "snifferPlugin_tcp_prot.h"
+#include "xferPlugin_gtc_prot.h"
+
+#include "gtc_prot.h"
+#include "chunkerPlugin.h"
+
+#include "flow_id.h"
+#include "contiguous_block.h"
+#include "reconstructed_chunk.h"
+
+#include "extract.h"
+#include "types.h"
+#include "util.h"
+#include "ieee802_11.h"
+#include "llc.h"
+#include "oui.h"
+
+#include <map>
+#include <vector>
+#include <list>
+#include <string>
+#include <pcap.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <net/ethernet.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h> 
+#include <netinet/ether.h> 
+#include <netinet/tcp.h> 
+
+//using namespace std;
+
+/* tcpdump header (ether.h) defines ETHER_HDRLEN) */
+#ifndef ETHER_HDRLEN
+#define ETHER_HDRLEN 14
+#endif
+
+#ifndef CAPTURE_BUF_SIZE
+#define CAPTURE_BUF_SIZE 32768
+#endif
+
+//#define MIN_CHUNK_SIZE 0x1000 // 4 KB
+#define MIN_CHUNK_SIZE 0x400 // 1 KB
+#define MIN_PAYLOAD_LENGTH (MIN_CHUNK_SIZE + RPC_HEADER_LEN - 4)
+
+//#define AMAR_DEBUG 1
+//#define AMAR_DEBUG_PAYLOAD 1
+
+/*
+          IP HEADER
+
+           0                   1                   2                   3   
+           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |Version|  IHL  |Type of Service|          Total Length         |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |         Identification        |Flags|      Fragment Offset    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |  Time to Live |    Protocol   |         Header Checksum       |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                       Source Address                          |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Destination Address                        |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Options                    |    Padding    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        
+ * Structure of an ip header, devoid of options.
+ * Stolen from tcpdump source
+ */
+struct sniff_ip {
+	u_int8_t	ip_vhl;		/* header length, version */
+#define IP_V(ip)	(((ip)->ip_vhl & 0xf0) >> 4)
+#define IP_HL(ip)	((ip)->ip_vhl & 0x0f)
+	u_int8_t	ip_tos;		/* type of service */
+	u_int16_t	ip_len;		/* total length */
+	u_int16_t	ip_id;		/* identification */
+	u_int16_t	ip_off;		/* fragment offset field */
+#define	IP_DF 0x4000			/* dont fragment flag */
+#define	IP_MF 0x2000			/* more fragments flag */
+#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
+	u_int8_t	ip_ttl;		/* time to live */
+	u_int8_t	ip_p;		/* protocol */
+	u_int16_t	ip_sum;		/* checksum */
+	struct	in_addr ip_src,ip_dst;	/* source and dest address */
+};
+
+
+
+/* 
+                            TCP Header Format
+
+    0                   1                   2                   3   
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |          Source Port          |       Destination Port        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                        Sequence Number                        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Acknowledgment Number                      |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |  Data |           |U|A|P|R|S|F|                               |
+   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
+   |       |           |G|K|H|T|N|N|                               |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |           Checksum            |         Urgent Pointer        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Options                    |    Padding    |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                             data                              |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+*/
+
+//typedef u_int tcp_seq;
+
+struct sniff_tcp {
+    u_short th_sport;	/* source port */
+    u_short th_dport;	/* destination port */
+    tcp_seq th_seq;	/* sequence number */
+    tcp_seq th_ack;	/* acknowledgement number */
+    u_char th_offx2;	/* data offset, rsvd */
+#define TH_OFF(th)	(((th)->th_offx2 & 0xf0) >> 4)
+    u_char th_flags;
+#define TH_FIN 0x01
+#define TH_SYN 0x02
+#define TH_RST 0x04
+#define TH_PUSH 0x08
+#define TH_ACK 0x10
+#define TH_URG 0x20
+#define TH_ECE 0x40
+#define TH_CWR 0x80
+#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
+    u_short th_win;	/* window */
+    u_short th_sum;	/* checksum */
+    u_short th_urp;	/* urgent pointer */
+};
+
+/* from ethereal packet-prism.c */
+#define pletohs(p)  ((u_int16_t)					\
+		     ((u_int16_t)*((const u_int8_t *)(p)+1)<<8|		\
+		      (u_int16_t)*((const u_int8_t *)(p)+0)<<0))
+#define pntohl(p)   ((u_int32_t)*((const u_int8_t *)(p)+0)<<24|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+1)<<16|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+2)<<8|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+3)<<0)
+#define COOK_FRAGMENT_NUMBER(x) ((x) & 0x000F)
+#define COOK_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)
+/* end ethereal code */
+
+struct dot_chunk_res_t {
+  const u_char *chunk_id_base;
+  unsigned int chunk_id_len;
+  const u_char *chunk_data_base;
+  unsigned int chunk_data_len;
+};
+
+class SniffTcp {
+ protected:
+    std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >* p_flow_list;
+    char mask[24];
+    unsigned int mask_size_in_bytes;
+    ptr <aclnt> sniffer_c;
+
+    // NEW - START
+    map< string, std::list<string> > flow_chunk_map;
+    map< string, ReconstructedChunk* > chunkId_reconstructedChunk_map;
+    // NEW - END
+
+ public:
+  
+    SniffTcp(const char* s);
+    SniffTcp(SniffTcp& sniffer);
+    virtual ~SniffTcp();
+  
+    int numChunksSniffed;
+    int numPacketsCaptured;
+    int numTcpPacketsCaptured;
+    unsigned long numBytesOfTcpPacketsCaptured;
+    unsigned long numBytesOfChunksSniffed;
+    unsigned long numDuplicateBytes;
+  
+    int get_flow_offset(FlowId* pFid);
+
+    /*
+     * print data in rows of 16 bytes: offset   hex   ascii
+     *
+     * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+     */
+    void print_hex_ascii_line(const u_char *payload, int len, int offset);
+
+    void print_payload(const u_char *payload, int len);
+
+    u_int16_t handle_ethernet(const struct pcap_pkthdr* pkthdr, const u_char* packet);
+
+    void handle_ip(u_int length, const u_char* ip_packet);
+
+    //void grep_contiguous_block_for_chunks(ContiguousBlock *pcb);
+    void grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator i, std::list<ContiguousBlock*>* stream_block);
+    void grep_flows_for_chunks();
+
+    int get_length_from_byte_stream(const char *b);
+    void send_chunk_to_sniffer_plugin (const char *rpc_buffer);
+    void put_chunk_cb (ref <sniffer_tcp_put_chunk_res>, clnt_stat);
+
+    // Stolen and modified from Jeff's code
+    bool Check80211FCS() { return true; }
+    u_int8_t extract_header_length(u_int16_t fc);
+    void handle_80211(const u_char* packet, u_int len);
+    void handle_data_frame(const u_char *ptr, int len, u_int16_t fc);
+    void handle_llc(const u_char *ptr, int len);
+
+
+    void deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                       const u_char *payload, int size_payload, 
+                                       tcp_seq seq_num);
+
+    void deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                       FlowId *pFid, string* pFidStr);
+
+    bool fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    void insert(FlowId *pFid, string* pFidStr, 
+                const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    pair<string*, int>* getChunkId(const u_char *payload, int len);
+    const u_char * rpc_header_in_stream (const u_char *payload, int len);
+    bool extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res);
+    bool extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res);
+    //int getChunkLength(const u_char *payload, int len);
+
+    void run_ideal_analysis();
+    void dump_flow_chunk_map();
+};
+
+/*
+ * workhorse function
+ */ 
+static void my_callback_wifi(u_char* arg, 
+                             const struct pcap_pkthdr* pkthdr, 
+                             const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int frameOffset = 0;
+        u_int frameLen = pkthdr->caplen;
+	pSt->handle_80211(packet + frameOffset, frameLen);
+    }
+}
+
+static void my_callback_ethernet(u_char* arg, 
+                                 const struct pcap_pkthdr* pkthdr, 
+                                 const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int16_t type = pSt->handle_ethernet(pkthdr, packet);
+
+        if(type == ETHERTYPE_IP) {
+            /* handle IP packet */
+ 	    // cout << "this is an IP packet" << endl;
+
+            pSt->handle_ip(pkthdr->caplen - ETHER_HDRLEN, (const u_char *)packet + ETHER_HDRLEN);
+        }
+        else if(type == ETHERTYPE_ARP) {
+            // handle arp packet
+        }
+        else if(type == ETHERTYPE_REVARP) {
+            // handle reverse arp packet
+        }
+    }
+}
+
+#endif //_SNIFF_TCP
diff -Naur src_dot_original/ideal-sniffer/types.h src/ideal-sniffer/types.h
--- src_dot_original/ideal-sniffer/types.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/types.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,65 @@
+////////////////////////////////////////////////////////////////////////////////
+// Mercury and Colyseus Software Distribution 
+// 
+// Copyright (C) 2004-2005 Ashwin Bharambe (ashu@cs.cmu.edu)
+//               2004-2005 Jeffrey Pang    (jeffpang@cs.cmu.edu)
+//                    2004 Mukesh Agrawal  (mukesh@cs.cmu.edu)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License as
+// published by the Free Software Foundation; either version 2, or (at
+// your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful, but
+// WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA
+////////////////////////////////////////////////////////////////////////////////
+#ifndef __TYPES__H
+#define __TYPES__H
+
+// basic types and utility macros
+
+typedef unsigned char      byte;
+typedef unsigned char      ubyte;
+typedef unsigned char      uint8;
+typedef unsigned short     uint16; 
+typedef unsigned int       uint32;
+typedef unsigned long long uint64;
+
+typedef          char      sbyte;
+typedef          char      sint8;
+typedef          short     sint16; 
+typedef          int       sint32;
+typedef          long long sint64;
+
+typedef float              real;
+typedef float              real32;
+typedef double             real64;
+//typedef long double        real64;
+
+typedef unsigned int guint;
+typedef uint32 guint32;
+typedef uint16 guint16;
+typedef uint8  guint8;
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y)?(x):(y))
+#endif
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+#endif
+// vim: set sw=4 sts=4 ts=8 noet: 
+// Local Variables:
+// Mode: c++
+// c-basic-offset: 4
+// tab-width: 8
+// indent-tabs-mode: t
+// End:
diff -Naur src_dot_original/ideal-sniffer/util.cc src/ideal-sniffer/util.cc
--- src_dot_original/ideal-sniffer/util.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/util.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,136 @@
+
+#include <stdarg.h>
+#include <cstdlib>
+#include <cstdio>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "util.h"
+#include "ethertype.h"
+
+MAC::MAC(const u_char *ether) {
+    val = ((((((((((((uint64_t) (ether[0]))
+		    << 8) | ether[1])
+		  << 8) | ether[2])
+		<< 8) | ether[3])
+	      << 8) | ether[4])
+	    << 8) | ether[5]);
+}
+MAC::MAC(uint64_t val) : val(val) {
+}
+MAC::MAC(const MAC& o) : val(o.val) {
+}
+
+MAC MAC::broadcast = MAC(0xffffffffffffULL);
+MAC MAC::null = MAC((uint64_t)0);
+
+std::ostream& operator<<(std::ostream& out, const MAC& mac) {
+    char buf[24];
+    sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", 
+	    (int)((mac.val>>40)&0xff),
+	    (int)((mac.val>>32)&0xff),
+	    (int)((mac.val>>24)&0xff),
+	    (int)((mac.val>>16)&0xff),
+	    (int)((mac.val>>8)&0xff),
+	    (int)((mac.val)&0xff)
+	    );
+    out << buf;
+    return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const struct in_addr& ip) {
+    out << inet_ntoa(ip);
+    return out;
+}
+
+char *va(char *format, ...)
+{
+    va_list		argptr;
+    static int index = 0;
+    static char	buf[8][512];
+    
+    char *b = *(buf + index);
+
+    va_start (argptr, format);
+    vsprintf (b, format,argptr);
+    va_end (argptr);
+
+    index = (index + 1) % 8;
+
+    return b;	
+}
+
+const struct tok ethertype_values[] = { 
+    { ETHERTYPE_IP,		"IPv4" },
+    { ETHERTYPE_MPLS,		"MPLS unicast" },
+    { ETHERTYPE_MPLS_MULTI,	"MPLS multicast" },
+    { ETHERTYPE_IPV6,		"IPv6" },
+    { ETHERTYPE_8021Q,		"802.1Q" },
+    { ETHERTYPE_VMAN,		"VMAN" },
+    { ETHERTYPE_PUP,            "PUP" },
+    { ETHERTYPE_ARP,            "ARP"},
+    { ETHERTYPE_REVARP,         "Reverse ARP"},
+    { ETHERTYPE_NS,             "NS" },
+    { ETHERTYPE_SPRITE,         "Sprite" },
+    { ETHERTYPE_TRAIL,          "Trail" },
+    { ETHERTYPE_MOPDL,          "MOP DL" },
+    { ETHERTYPE_MOPRC,          "MOP RC" },
+    { ETHERTYPE_DN,             "DN" },
+    { ETHERTYPE_LAT,            "LAT" },
+    { ETHERTYPE_SCA,            "SCA" },
+    { ETHERTYPE_LANBRIDGE,      "Lanbridge" },
+    { ETHERTYPE_DECDNS,         "DEC DNS" },
+    { ETHERTYPE_DECDTS,         "DEC DTS" },
+    { ETHERTYPE_VEXP,           "VEXP" },
+    { ETHERTYPE_VPROD,          "VPROD" },
+    { ETHERTYPE_ATALK,          "Appletalk" },
+    { ETHERTYPE_AARP,           "Appletalk ARP" },
+    { ETHERTYPE_IPX,            "IPX" },
+    { ETHERTYPE_PPP,            "PPP" },
+    { ETHERTYPE_SLOW,           "Slow Protocols" },
+    { ETHERTYPE_PPPOED,         "PPPoE D" },
+    { ETHERTYPE_PPPOES,         "PPPoE S" },
+    { ETHERTYPE_EAPOL,          "EAPOL" },
+    { ETHERTYPE_JUMBO,          "Jumbo" },
+    { ETHERTYPE_LOOPBACK,       "Loopback" },
+    { ETHERTYPE_ISO,            "OSI" },
+    { ETHERTYPE_GRE_ISO,        "GRE-OSI" },
+    { 0, NULL}
+};
+
+/*
+ * Convert a token value to a string; use "fmt" if not found.
+ */
+const char *
+tok2strbuf(register const struct tok *lp, register const char *fmt,
+	   register int v, char *buf, size_t bufsize)
+{
+	if (lp != NULL) {
+		while (lp->s != NULL) {
+			if (lp->v == v)
+				return (lp->s);
+			++lp;
+		}
+	}
+	if (fmt == NULL)
+		fmt = "#%d";
+
+	(void)snprintf(buf, bufsize, fmt, v);
+	return (const char *)buf;
+}
+
+/*
+ * Convert a token value to a string; use "fmt" if not found.
+ */
+const char *
+tok2str(register const struct tok *lp, register const char *fmt,
+	register int v)
+{
+	static char buf[4][128];
+	static int idx = 0;
+	char *ret;
+
+	ret = buf[idx];
+	idx = (idx+1) & 3;
+	return tok2strbuf(lp, fmt, v, ret, sizeof(buf[0]));
+}
diff -Naur src_dot_original/ideal-sniffer/util.h src/ideal-sniffer/util.h
--- src_dot_original/ideal-sniffer/util.h	1969-12-31 19:00:00.000000000 -0500
+++ src/ideal-sniffer/util.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,41 @@
+
+#include <ostream>
+
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+//typedef unsigned long long uint64_t;
+
+struct MAC {
+    uint64_t val;
+    MAC() {}
+    MAC(const uint8_t *stream);
+    MAC(uint64_t val);
+    MAC(const MAC& o);
+
+    bool operator==(const MAC& o) const {
+	return val == o.val;
+    }
+    bool operator!=(const MAC& o) const {
+	return val != o.val;
+    }
+    bool operator<(const MAC& o) const {
+	return val < o.val;
+    }
+
+    static MAC broadcast;
+    static MAC null;
+};
+
+std::ostream& operator<<(std::ostream& out, const MAC& mac);
+std::ostream& operator<<(std::ostream& out, const struct in_addr& ip);
+
+char *va(char *format, ...);
+
+struct tok {
+	int v;			/* value */
+	const char *s;		/* string */
+};
+
+extern const char *
+tok2str(register const struct tok *lp, register const char *fmt,
+	register int v);
diff -Naur src_dot_original/Makefile.am src/Makefile.am
--- src_dot_original/Makefile.am	2007-02-06 17:37:00.000000000 -0500
+++ src/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -6,7 +6,7 @@
 FILTER =
 endif
 
-DIST_SUBDIRS = util gtcd gcp cdht
+DIST_SUBDIRS = util gtcd gcp sniffer ideal-sniffer
 SUBDIRS = $(DIST_SUBDIRS) $(FILTER)
 
 CLEANFILES = core *.core *~
diff -Naur src_dot_original/olsr_route.sh src/olsr_route.sh
--- src_dot_original/olsr_route.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/olsr_route.sh	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,8 @@
+#!/bin/bash
+TMP_FILE=/tmp/_olsr_tmp.txt
+
+out_file=$1
+rm -f $out_file
+/sbin/route -n > $out_file 
+
+
diff -Naur src_dot_original/push.sh src/push.sh
--- src_dot_original/push.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/push.sh	2008-08-11 12:56:09.000000000 -0400
@@ -0,0 +1,84 @@
+#!/bin/bash -x
+
+BASE_DIR=/home/aphanish/life/research/dist/ditto
+SRC_DIR=${BASE_DIR}/dot_snap_20070206
+
+INSTALL_BASE_DIR=${BASE_DIR}/emulab_map
+
+#INSTALL_DIR=${BASE_DIR}/install
+
+SCRIPTS_DIR=${BASE_DIR}/scripts
+BASE_TAR_DIR=${BASE_DIR}/tar
+PERL_SCRIPTS_DIR=${BASE_DIR}/scripts
+
+EMULAB_USER_NAME=amar
+#EMULAB_USER_NAME=fdogar
+
+EMULAB_EXPT_NAME=nodew1.ditto.netarch.emulab.net
+#EMULAB_EXPT_NAME=nodew1.ditto.cmu849.emulab.net
+
+#DST_DIR=~/project/mobisys/
+DST_DIR=project/ditto/
+
+
+for testbed in "emulab" "map"
+do
+
+    TAR_DIR=${BASE_TAR_DIR}/$testbed
+    rm -rf ${TAR_DIR}/*
+    mkdir -p ${TAR_DIR}/dot/build/gtcd
+    mkdir -p ${TAR_DIR}/dot/build/gcp
+    mkdir -p ${TAR_DIR}/dot/conf
+    
+#     if [ $testbed = "emulab" ]
+#     then
+#         echo "emulab!";
+#         ### SCP Scripts to Emulab
+#         scp ${PERL_SCRIPTS_DIR}/* ${EMULAB_USER_NAME}@${EMULAB_EXPT_NAME}:~/${DST_DIR}
+#         scp -r ${PERL_SCRIPTS_DIR}/setup ${EMULAB_USER_NAME}@${EMULAB_EXPT_NAME}:~/${DST_DIR}
+#         scp -r ${PERL_SCRIPTS_DIR}/emulab_olsr_setup ${EMULAB_USER_NAME}@${EMULAB_EXPT_NAME}:~/${DST_DIR}
+#     fi
+
+#    if [ $testbed = "map" ]
+#    then
+#        echo "map!";
+#        ### SCP Scripts to MAP
+#        scp ${PERL_SCRIPTS_DIR}/* ditto@sp01.ecn.purdue.edu:/home/ditto/cmu/
+#        scp -r ${PERL_SCRIPTS_DIR}/setup ditto@sp01.ecn.purdue.edu:/home/ditto/cmu/
+#    fi
+
+    for chunksize in "8K" "16K" "32K"
+    do
+
+        INSTALL_DIR=${INSTALL_BASE_DIR}/$testbed/dot_$chunksize
+        cp ${SCRIPTS_DIR}/emulab_olsr_setup/setup-olsr.sh ${INSTALL_DIR}/bin/
+
+        cp ${INSTALL_DIR}/sbin/gtcd_$chunksize ${TAR_DIR}/dot/build/gtcd
+        cp ${SRC_DIR}/olsr_route.sh ${TAR_DIR}/dot/build/gtcd
+        cp ${INSTALL_DIR}/bin/gcp ${TAR_DIR}/dot/build/gcp
+        cp ${INSTALL_DIR}/bin/sniffTcp_$chunksize ${TAR_DIR}/dot/build
+        cp ${SCRIPTS_DIR}/dot.conf ${TAR_DIR}/dot/conf 
+
+    done
+    cd ${TAR_DIR}
+    tar -czf all.tar.gz dot
+
+    if [ $testbed = "emulab" ]
+    then
+        echo "emulab!";
+        ### SCP TARBALL to Emulab
+        scp ${TAR_DIR}/all.tar.gz ${EMULAB_USER_NAME}@${EMULAB_EXPT_NAME}:~/${DST_DIR}
+        scp ${BASE_DIR}/ext/olsrd-0.5.4.tar.bz2 ${EMULAB_USER_NAME}@${EMULAB_EXPT_NAME}:~/OLSR/
+    fi
+
+    if [ $testbed = "map" ]
+    then
+        echo "map!";
+        ### SCP TARBALL to MAP
+        scp ${TAR_DIR}/all.tar.gz ditto@sp01.ecn.purdue.edu:/home/ditto/cmu/
+        scp ${BASE_DIR}/ext/olsrd-0.5.4.tar.bz2 ditto@sp01.ecn.purdue.edu:/home/ditto/OLSR/
+    fi
+
+    cd -
+
+done
diff -Naur src_dot_original/rebuild.sh src/rebuild.sh
--- src_dot_original/rebuild.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/rebuild.sh	2008-08-09 15:38:12.000000000 -0400
@@ -0,0 +1,15 @@
+#!/bin/bash -x
+
+BASE_DIR=/home/aphanish/life/research/dist/ditto
+SRC_DIR=${BASE_DIR}/dot_snap_20070206
+INSTALL_DIR=${SRC_DIR}/install
+
+rm -rf $INSTALL_DIR
+mkdir -p $INSTALL_DIR
+
+cd $SRC_DIR
+autoreconf -i -s
+./configure --with-sfs=${SRC_DIR}/sfslite --prefix=${INSTALL_DIR}
+make clean
+make
+make install
diff -Naur src_dot_original/sfslite/acinclude.m4 src/sfslite/acinclude.m4
--- src_dot_original/sfslite/acinclude.m4	2008-08-10 16:59:04.000000000 -0400
+++ src/sfslite/acinclude.m4	2008-08-10 16:43:13.000000000 -0400
@@ -1421,7 +1421,7 @@
 	sfs_gnu_CXXWFLAGS="$sfs_gnu_WFLAGS"
 	;;
     linux*|freebsd*)
-	sfs_gnu_WFLAGS="-Wall -Werror"
+	sfs_gnu_WFLAGS="-Wall"
 	sfs_gnu_CXXWFLAGS="$sfs_gnu_WFLAGS"
 	;;
     *)
diff -Naur src_dot_original/sniffer/contiguous_block.cc src/sniffer/contiguous_block.cc
--- src_dot_original/sniffer/contiguous_block.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/contiguous_block.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,151 @@
+#include "contiguous_block.h"
+
+ContiguousBlock::ContiguousBlock()   // Constructor
+{
+    bInit = true;
+    bModified = true;
+    starting_seq_number = 0;
+    next_expected_seq_number = 0;
+    p_s_contiguous_block = new string("");
+}
+
+ContiguousBlock::ContiguousBlock(const ContiguousBlock &copyin)   // Copy constructor to handle pass by value.
+{
+    starting_seq_number = copyin.starting_seq_number;
+    next_expected_seq_number = copyin.next_expected_seq_number;
+    p_s_contiguous_block = new string(*(copyin.p_s_contiguous_block));
+    bInit = copyin.bInit;
+    bModified = copyin.bModified;
+}
+
+ostream &operator<<(ostream &output, const ContiguousBlock &cb)
+{
+    output << cb.starting_seq_number << " " << cb.next_expected_seq_number << " yay" << endl;
+    return output;
+}
+
+ContiguousBlock& ContiguousBlock::operator=(const ContiguousBlock &rhs)
+{
+    this->starting_seq_number = rhs.starting_seq_number;
+    this->next_expected_seq_number = rhs.next_expected_seq_number;
+    return *this;
+}
+
+int ContiguousBlock::operator==(const ContiguousBlock &rhs) const
+{
+    if ( (this->starting_seq_number == rhs.starting_seq_number) && (this->next_expected_seq_number == rhs.next_expected_seq_number) ) return 1;
+    return 0;
+}
+
+// This function is required for built-in STL list functions like sort
+int ContiguousBlock::operator<(const ContiguousBlock &rhs) const
+{
+   if( this->next_expected_seq_number < rhs.starting_seq_number ) return 1;
+   return 0;
+}
+
+void ContiguousBlock::append(const char* str, const int size_payload, const tcp_seq start_seq_number)
+{
+    if (bInit) {
+        starting_seq_number = next_expected_seq_number = start_seq_number;
+        bInit = false;
+    }
+
+    // giving the size_payload param here makes sure that we append \0s too from the char*
+    p_s_contiguous_block->append(str, size_payload);
+    next_expected_seq_number  += size_payload;
+    //cout << "next_expected_seq_number : " << next_expected_seq_number << endl;
+    bModified = true;
+}
+
+// used while merging the next ContiguousBlock with the current one in the list
+void ContiguousBlock::append(const string* str, const tcp_seq end_seq_number)
+{
+    // we don't need the size_payload param as we are using a string and not a char*,
+    // hence the \0s will be copied
+    p_s_contiguous_block->append(*str);
+    next_expected_seq_number = end_seq_number;
+    bModified = true;
+}
+
+// used while merging the next ContiguousBlock with the current one in the list
+void ContiguousBlock::overlapping_append(const string* str, const unsigned int offset, const tcp_seq end_seq_number)
+{
+    // we don't need the size_payload param as we are using a string and not a char*,
+    // hence the \0s will be copied
+    p_s_contiguous_block->append(*str, offset, str->size() - offset);
+    next_expected_seq_number = end_seq_number;
+    bModified = true;
+}
+
+
+void ContiguousBlock::prepend(const char* str, const int size_payload, const tcp_seq start_seq_number)
+{
+    starting_seq_number = start_seq_number;
+
+    //string* new_str = new string(str);
+
+    // giving the size_payload param here makes sure that we append \0s too from the char*
+    string* new_str = new string();
+    new_str->append(str, size_payload);
+
+    new_str->append(*p_s_contiguous_block);
+    delete p_s_contiguous_block;
+    p_s_contiguous_block = new_str;
+    bModified = true;
+}
+
+/*
+int main()
+{
+   list<ContiguousBlock> L;
+   ContiguousBlock cb;
+
+   cb.last_seq_number = 10;
+   L.push_back(cb);  // Insert a new element at the end
+
+   cb.last_seq_number = 3;
+   L.push_back(cb);  // Object passed by value. Uses default member-wise copy constructor
+
+   cb.last_seq_number = 5;
+   L.push_back(cb);
+
+   list<ContiguousBlock>::iterator i;
+
+   for(i=L.begin(); i != L.end(); ++i) cout << (*i).last_seq_number << " "; // print member
+   cout << endl;
+   for(i=L.begin(); i != L.end(); ++i) cout << *i << " "; // print all
+   cout << endl;
+
+   cout << "Sorted: " << endl;
+   L.sort();
+   for(i=L.begin(); i != L.end(); ++i) cout << *i << " "; // print all
+   cout << endl;
+
+   return 0;
+    list<int> l;
+    l.push_back(1);
+    l.push_back(2);
+    l.push_back(3);
+    l.push_back(4);
+
+
+    list<int>::iterator i;
+    for (i = l.begin(); i != l.end(); ++i) {
+        if (*i == 3) {
+            l.insert(i, 5);
+        }
+    }
+
+    for(i=l.begin(); i != l.end(); ++i) {
+
+        if (*i == 5) {
+            list<int>::iterator i2(i);
+            i2++;
+            l.erase(i2);
+        }
+        cout << *i << " "; // print all
+    }
+    cout << endl;
+}
+*/
diff -Naur src_dot_original/sniffer/contiguous_block.h src/sniffer/contiguous_block.h
--- src_dot_original/sniffer/contiguous_block.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/contiguous_block.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,39 @@
+#ifndef _CONTIGUOUS_BLOCKS
+#define _CONTIGUOUS_BLOCKS 1
+
+#include <iostream>
+#include <list>
+#include <netinet/tcp.h>
+
+using namespace std;
+
+typedef u_int tcp_seq;
+
+// The List STL template requires overloading operators =, == and <.
+class ContiguousBlock
+{
+   friend ostream &operator<<(ostream &, const ContiguousBlock &);
+
+ public:
+   tcp_seq starting_seq_number;
+   tcp_seq next_expected_seq_number;
+   string* p_s_contiguous_block;
+   bool bInit;
+   bool bModified;
+
+   ContiguousBlock();
+   ContiguousBlock(const ContiguousBlock &);
+   ~ContiguousBlock()
+       {
+           if(p_s_contiguous_block) delete p_s_contiguous_block;
+       };
+   ContiguousBlock &operator=(const ContiguousBlock &rhs);
+   int operator==(const ContiguousBlock &rhs) const;
+   int operator<(const ContiguousBlock &rhs) const;
+   void append(const char* str, const int size_payload, const tcp_seq start_seq_number);
+   void append(const string* str, const tcp_seq end_seq_number);
+   void overlapping_append(const string* str, const unsigned int offset, const tcp_seq end_seq_number);
+   void prepend(const char* str, const int size_payload, const tcp_seq start_seq_number);
+};
+
+#endif // _CONTIGUOUS_BLOCKS
diff -Naur src_dot_original/sniffer/crc32.cc src/sniffer/crc32.cc
--- src_dot_original/sniffer/crc32.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/crc32.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,143 @@
+/* crc32.c
+ * CRC-32 routine
+ *
+ * $Id: crc32.cpp,v 1.1 2007/02/14 00:05:50 jpang Exp $
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * Copied from README.developer
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Credits:
+ *
+ * Table from Solomon Peachy
+ * Routine from Chris Waters
+ */
+
+#include "types.h"
+
+/*
+ * Table for the AUTODIN/HDLC/802.x CRC.
+ *
+ * Polynomial is
+ *
+ *  x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^8 + x^7 +
+ *      x^5 + x^4 + x^2 + x + 1
+ */
+const guint32 crc32_ccitt_table[256] = {
+        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
+        0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
+        0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
+        0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
+        0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
+        0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
+        0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+        0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
+        0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
+        0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
+        0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
+        0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
+        0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
+        0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+        0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
+        0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
+        0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
+        0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
+        0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
+        0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
+        0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
+        0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
+        0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
+        0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
+        0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
+        0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
+        0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
+        0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
+        0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
+        0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
+        0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
+        0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
+        0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
+        0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
+        0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
+        0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
+        0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
+        0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
+        0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
+        0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
+        0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
+        0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
+        0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
+        0x2d02ef8d
+};
+
+#define CRC32_CCITT_SEED    0xFFFFFFFF
+
+guint32
+crc32_ccitt_seed(const guint8 *buf, guint len, guint32 seed);
+
+guint32
+crc32_ccitt(const guint8 *buf, guint len)
+{
+  return ( crc32_ccitt_seed(buf, len, CRC32_CCITT_SEED) );
+}
+
+guint32
+crc32_ccitt_seed(const guint8 *buf, guint len, guint32 seed)
+{
+  guint i;
+  guint32 crc32 = seed;
+
+  for (i = 0; i < len; i++)
+    crc32 = crc32_ccitt_table[(crc32 ^ buf[i]) & 0xff] ^ (crc32 >> 8);
+
+  return ( ~crc32 );
+}
+
+/*
+ * IEEE 802.x version (Ethernet and 802.11, at least) - byte-swap
+ * the result of "crc32()".
+ *
+ * XXX - does this mean we should fetch the Ethernet and 802.11
+ * FCS with "tvb_get_letohl()" rather than "tvb_get_ntohl()",
+ * or is fetching it big-endian and byte-swapping the CRC done
+ * to cope with 802.x sending stuff out in reverse bit order?
+ */
+guint32
+crc32_802(const guint8 *buf, guint len)
+{
+  guint32 c_crc;
+
+  c_crc = crc32_ccitt(buf, len);
+
+  /* Byte reverse. */
+  c_crc = ((unsigned char)(c_crc>>0)<<24) |
+    ((unsigned char)(c_crc>>8)<<16) |
+    ((unsigned char)(c_crc>>16)<<8) |
+    ((unsigned char)(c_crc>>24)<<0);
+
+  return ( c_crc );
+}
diff -Naur src_dot_original/sniffer/dot_test_2.dump src/sniffer/dot_test_2.dump
--- src_dot_original/sniffer/dot_test_2.dump	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/dot_test_2.dump	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,1305 @@
+               E@ J   J                E  <v@ @     w      @
+     EG J   J                E  <  @ @<     w h  @
+  EL B   B                E  4v@ @     w   
+  Ef J   J                E  <@ @.'    |q    !  @
+     Eu 6   6                E  (  @ @<    |    rP  s  E J   J                E  <?@ @    O      @
+     E 6   6                E  (  @ @<        PP    E J   J                E  <p@ @I    %    B  @
+     E  6   6                E  (  @ @<        %P    Eb J   J                E  <=@ @z|    A_    &  @
+     Eg 6   6                E  (  @ @<    A    _P    Et x   x                E  j@ @$     w  ^  
+  SSH-2.0-OpenSSH_3.8.1p1  Debian-krb5 3.8.1p1-10build1
+E B   B                E  4v@ @     wF L  
+  E+ x   x                E  jv@ @v     wF ^  
+  SSH-2.0-OpenSSH_3.8.1p1  Debian-krb5 3.8.1p1-10build1
+E@ B   B                E  4@ @$     Fw'    
+  E                  E @ @"n     Fw'     
+    \XmH#j,  E%lXS   =diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1   ssh-rsa,ssh-dss   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   	none,zlib   	none,zlib                    Ev0 B   B                E  4v@ @     w'   
+  E                  E v@ @J     w'    
+    \a}-+z]   =diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1   ssh-rsa,ssh-dss   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   	none,zlib   	none,zlib                    E B   B                E  4@ @$     w  $  
+  E Z   Z                E  Lv@ @     w @  
+     "                E B   B                E  4@ @$     w    
+  E                    E  @ @$3     w    
+         :9r17q~qv#sfZ.'zc?)X9h7W}E-zvKH%NEf4I5H;v">]I
+%$^k           E B   B                E  4v@ @     w> b  
+  E                    E  v@ @     w>   
+         7z]KEQ)=tkDl[]'mLB0N+K 
+A;.M~%WD;;	O&y6NJ L  e-      EL                  E @ @"     >w/    
+    
+!      ssh-rsa   #    G(n-fr@j9kX8ExT
+yu>J$6:|s_:
+6)5X~]'^s+   HS#fZ\/YQ5zV#JAuD[(6[CV\q@Q}h}e_6>eL{,t%{^3 A      ssh-rsa   qJb@s4J?~#yC?I7G;	yjK`8 'VR :bhhwCU!O sE             
+          E~ R   R                E  Dv@ @     w/ 8  
+     
+          E*W B   B                E  4@ @$     w?    
+  E1W r   r                E  dv@ @u     w? X  
+  5xN '{$=G>[zyS)+E7W B   B                E  4@ @$     wo    
+  EcW r   r                E  d@ @$     wo  X  
+  Z 	ex=	~nK'ZvL-&jE
+X                    E  tv@ @d     wo> h  
+  s0puQ[:z]g4d?g6`V	k>3gluEd                    E  @ @$f     >w    
+  6C,g0Fb]^YR9s8`7
+yu|)A}@Gr>*	C$,%ryEEf                    E  v@ @C     w   
+  KTt
+} {_RD\`&YMYWR$MqsS\)F 9gmJ	F"M"0E\k                    E  @ @$e     w    
+  -w`{kIsm@~8f`.M;iNstU/kR?2C"8M9\2.:(}LT;S+#L[E=m                    E  v@ @B     w   
+  |	E>R,Q3izL%K~RX}0*<CL?-
+X\9!]*$Epm                    E  @ @$d     wo    
+  $2vYeyZU#k_MlF -`7cn2nWD*wRi6AVEm 2  2               E $v @ @     wo^   
+  .F 2_L@%[0y*KEaQ<8b
+_9^3Ad	Ij&+tk_~1r-X++HN#r3+e=YsU."Fjj31$wy_)d;K
+~'Is\4/rbD1n(([?`7En                    E  @ @$c     ^w_    
+  iV|~b/iC^i4~_?>>[XfjU/~~8	Lw(Vzu ZqT;Q@Qfz_Eo                    E  v!@ @@     w_   
+  *0p&#`^	Y[~dN18"9>.C)U0SU!IH"~8aoEUp                    E  t @ @$     w  h  
+  I&O C$	1Up2G	qt9-D0ll3`K;uB\E B   B                E  4v"@ @     w \  
+  Ex                    E  v#@ @N     w x  
+  &WY"E),%Ca,/F`[46OA)Nxkx<!A=MQ1(6eEE r   r                E  d@ @$     w  X  
+  NT1n ER j3_N$qvp#,**E B   B                E  4v$@ @     w.   
+  E
+                    E  v%@ @L     w. x  
+  aX 1i/;q	D2 GB<)\c\/"Y OsLeSAG07~(Php]]OE b   b                E  T@ @$     .w_  H  
+  'YyX+];c_2EYE                    E  tv&@ @[     w_N h  
+  }:;<y!d#z1@  BJ*79*fM*#sXGE$ r   r                E  d@ @$     Nw  X  
+  #O{Qsb 	eA+i/pW0?Ks+sET                    E tv'@ @R     w~ h  
+  0h"j ^-
+ OGg/?l$hf(X6_\E r   r                E d@ @$     ~w  X  
+  ^4=p&$s	K%n#$Ei 2  2               E$v(@ @     w   
+  C,zP"O4rjwERc8qK.+`a_\^3LX"wtKXB1OO)AH
+b^)cYN4RM&f<i7Se1#8Mp)|_DA[
+^TnKi,0rk_ `9h\}ED*QFf0&l!pa(U9K"CwGy;Yu$$|EJ                    E @ @$E     w    
+  jA[!}F0oGy|'*#d#sE}I#<6}k$}JRY@*63-?6E J   J                E  <D@ @7##:      @
+     E& J   J                E  <  @ @|p##:78 s  @
+  E4 B   B                E  4D@ @7##:79 <  
+  E                    E  D@ @7=##:79   
+    m                                 w"sL
+9^0      NET    
+oid++_key0     
+oid++_val0     NOOP   
+oid++_key0     
+oid++_val0          E B   B                E  4!@ @V##:79"  <$  
+  E 6  6               E ("@ @a##:79"  f  
+    m                                        5m!toK&  @       NOOP   dl_key0    dl_val0    {!
+A#qbn)rf)  @       NOOP   dl_key0    dl_val0    @kq[R  *O      NOOP   dl_key0    dl_val0    E B   B                E  4D@ @7##:"7- ;*  
+  E> J   J                E  <L%@ @    =      @
+     EF 6   6                E  (  @ @<        >P  T  E J   J                E  <@ @        !  @
+     E 6   6                E  (  @ @<        P    E J   J                E  <@ @    .E6    =  @
+     E 6   6                E  (  @ @<    .    E6P  d  E1 J   J                E  <s_@ @Z    G    B  @
+     E6 6   6                E  (  @ @<        HP     E{ J   J                E  <D@ @u    <\    7  @
+     E 6   6                E  (  @ @<        <]P    E1                    E  D@ @7##:"7-   
+    P`J                                  5m!toK&  @             Eg                    E  D@ @7##:v7-   
+    P;	                                 {!
+A#qbn)rf)  @             E
+ B@  B@               E @4#@ @T##:7-  r  
+   @0`J                                @ This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by dot configure 0.2, which was
+generated by GNU Autoconf 2.60.  Invocation command line was
+
+  $ ./configure --with-sfs=/home/aphanish/research/overhear/dot_snap_20070206/sfslite
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = GS6172
+uname -m = i686
+uname -r = 2.6.17-10-generic
+uname -s = Linux
+uname -v = #2 SMP Tue Dec 5 22:28:26 UTC 2006
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = i686
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/lib/jvm/java-1.5.0-sun/bin
+PATH: /usr/local/sbin
+PATH: /usr/local/bin
+PATH: /usr/sbin
+PATH: /usr/bin
+PATH: /sbin
+PATH: /bin
+PATH: /usr/bin/X11
+PATH: /usr/games
+PATH: /home/aphanish/ns/ns-allinone-2.30/bin
+PATH: /home/aphanish/ns/ns-allinone-2.30/tcl8.4.11/unix
+PATH: /home/aphanish/ns/ns-allinone-2.30/tk8.4.11/unix
+PATH: /home/aphanish/ns/ns-allinone-2.30/ns-2.30
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:2015: checking for a BSD-compatible install
+configure:2071: result: /usr/bin/install -c
+configure:2082: checking whether build environment is sane
+configure:2125: result: yes
+configure:2190: checking for gawk
+configure:2220: result: no
+configure:2190: checking for mawk
+configure:2206: found /usr/bin/mawk
+configure:2217: result: mawk
+configure:2228: checking whether make sets $(MAKE)
+configure:2249: result: yes
+configure:2440: checking build system type
+configure:2458: result: i686-pc-linux-gnu
+configure:2480: checking host system type
+configure:2495: result: i686-pc-linux-gnu
+configure:2567: checking for gcc
+configure:2583: found /usr/bin/gcc
+configure:2594: result: gcc
+configure:2832: checking for C compiler version
+configure:2839: gcc --version >&5
+gcc (GCC) 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+Copyright (C) 2006 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:2842: $? = 0
+configure:2849: gcc -v >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --enable-languages=c,c++,fortran,objc,obj-c++,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.1 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-mpfr --enable-checking=release i486-linux-gnu
+Thread model: posix
+gcc version 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+configure:2852: $? = 0
+configure:2859: gcc -V >&5
+gcc: '-V' option must have argument
+configure:2862: $? = 1
+configure:2885: checking for C compiler default output file name
+configure:2912: gcc    conftest.c  >&5
+configure:2915: $? = 0
+configure:2961: result: a.out
+configure:2966: checking whether the C compiler works
+configure:2976: ./a.out
+configure:2979: $? = 0
+configure:2996: result: yes
+configure:3003: checking whether we are cross compiling
+configure:3005: result: no
+configure:3008: checking for suffix of executables
+configure:3015: gcc -o conftest    conftest.c  >&5
+configure:3018: $? = 0
+configure:3042: result: 
+configure:3048: checking for suffix of object files
+configure:3074: gcc -c   conftest.c >&5
+configure:3077: $? = 0
+configure:3100: result: o
+configure:3104: checking whether we are using the GNU C compiler
+configure:3133: gcc -c   conftest.c >&5
+configure:3139: $? = 0
+configure:3146: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3149: $? = 0
+configure:3156: test -s conftest.o
+configure:3159: $? = 0
+configure:3173: result: yes
+configure:3178: checking whether gcc accepts -g
+configure:3208: gcc -c -g  conftest.c >&5
+configure:3214: $? = 0
+configure:3221: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3224: $? = 0
+configure:3231: test -s conftest.o
+configure:3234: $? = 0
+configure:3364: result: yes
+configure:3381: checking for gcc option to accept ISO C89
+configure:3455: gcc  -c -g -O2  conftest.c >&5
+configure:3461: $? = 0
+configure:3468: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3471: $? = 0
+configure:3478: test -s conftest.o
+configure:3481: $? = 0
+configure:3501: result: none needed
+configure:3530: checking for style of include used by make
+configure:3558: result: GNU
+configure:3586: checking dependency style of gcc
+configure:3676: result: gcc3
+configure:3698: checking how to run the C preprocessor
+configure:3738: gcc -E  conftest.c
+configure:3744: $? = 0
+configure:3782: gcc -E  conftest.c
+conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
+configure:3788: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3828: result: gcc -E
+configure:3857: gcc -E  conftest.c
+configure:3863: $? = 0
+configure:3901: gcc -E  conftest.c
+conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
+configure:3907: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:4009: checking for g++
+configure:4025: found /usr/bin/g++
+configure:4036: result: g++
+configure:4067: checking for C++ compiler version
+configure:4074: g++ --version >&5
+g++ (GCC) 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+Copyright (C) 2006 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:4077: $? = 0
+configure:4084: g++ -v >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --enable-languages=c,c++,fortran,objc,obj-c++,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.1 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-mpfr --enable-checking=release i486-linux-gnu
+Thread model: posix
+gcc version 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+configure:4087: $? = 0
+configure:4094: g++ -V >&5
+g++: '-V' option must have argument
+configure:4097: $? = 1
+configure:4100: checking whether we are using the GNU C++ compiler
+configure:4129: g++ -c   conftest.cpp >&5
+configure:4135: $? = 0
+configure:4142: test -z "$ac_cxx_werror_flag" || test ! -s conftest.err
+configure:4145: $? = 0
+configure:4152: test -s conftest.o
+configure:4155: $? = 0
+configure:4169: result: yes
+configure:4174: checking whether g++ accepts -g
+configure:4204: g++ -c -g  conftest.cpp >&5
+configure:4210: $? = 0
+configure:4217: test -z "$ac_cxx_werror_flag" || test ! -s conftest.err
+configure:4220: $? = 0
+configure:4227: test -s conftest.o
+configure:4230: $? = 0
+configure:4360: result: yes
+configure:4385: checking dependency style of g++
+configure:4475: result: gcc3
+configure:4539: checking for cpp
+configure:4558: found /usr/bin/cpp
+configure:4570: result: /usr/bin/cpp
+configure:4610: checking for a BSD-compatible install
+configure:4666: result: /usr/bin/install -c
+configure:4677: checking whether ln -s works
+configure:4681: result: yes
+configure:4689: checking for ssize_t
+configure:4727: gcc -c -g -O2  conftest.c >&5
+configure:4733: $? = 0
+configure:4740: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:4743: $? = 0
+configure:4750: test -s conftest.o
+configure:4753: $? = 0
+configure:4765: result: yes
+configure:4849: checking for a sed that does not truncate output
+configure:4903: result: /bin/sed
+configure:4906: checking for grep that handles long lines and -e
+configure:4980: result: /bin/grep
+configure:4985: checking for egrep
+configure:5063: result: /bin/grep -E
+configure:5079: checking for ld used by gcc
+configure:5146: result: /usr/bin/ld
+configure:5155: checking if the linker (/usr/bin/ld) is GNU ld
+configure:5170: result: yes
+configure:5175: checking for /usr/bin/ld option to reload object files
+configure:5182: result: -r
+configure:5200: checking for BSD-compatible nm
+configure:5249: result: /usr/bin/nm -B
+configure:5253: checking how to recognise dependent libraries
+configure:5429: result: pass_all
+configure:5674: checking for ANSI C header files
+configure:5704: gcc -c -g -O2  conftest.c >&5
+configure:5710: $? = 0
+configure:5717: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5720: $? = 0
+configure:5727: test -s conftest.o
+configure:5730: $? = 0
+configure:5826: gcc -o conftest -g -O2   conftest.c  >&5
+configure:5829: $? = 0
+configure:5835: ./conftest
+configure:5838: $? = 0
+configure:5855: result: yes
+configure:5879: checking for sys/types.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for sys/stat.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for stdlib.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for string.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for memory.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for strings.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for inttypes.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for stdint.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for unistd.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5966: checking dlfcn.h usability
+configure:5983: gcc -c -g -O2  conftest.c >&5
+configure:5989: $? = 0
+configure:5996: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5999: $? = 0
+configure:6006: test -s conftest.o
+configure:6009: $? = 0
+configure:6020: result: yes
+configure:6024: checking dlfcn.h presence
+configure:6039: gcc -E  conftest.c
+configure:6045: $? = 0
+configure:6066: result: yes
+configure:6094: checking for dlfcn.h
+configure:6102: result: yes
+configure:6125: checking how to run the C++ preprocessor
+configure:6161: g++ -E  conftest.cpp
+configure:6167: $? = 0
+configure:6205: g++ -E  conftest.cpp
+conftest.cpp:23:28: error: ac_nonexistent.h: No such file or directory
+configure:6211: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:6251: result: g++ -E
+configure:6280: g++ -E  conftest.cpp
+configure:6286: $? = 0
+configure:6324: g++ -E  conftest.cpp
+conftest.cpp:23:28: error: ac_nonexistent.h: No such file or directory
+configure:6330: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:6430: checking for g77
+configure:6460: result: no
+configure:6430: checking for f77
+configure:6460: result: no
+configure:6430: checking for xlf
+configure:6460: result: no
+configure:6430: checking for frt
+configure:6460: result: no
+configure:6430: checking for pgf77
+configure:6460: result: no
+configure:6430: checking for cf77
+configure:6460: result: no
+configure:6430: checking for fort77
+configure:6460: result: no
+configure:6430: checking for fl32
+configure:6460: result: no
+configure:6430: checking for af77
+configure:6460: result: no
+configure:6430: checking for f90
+configure:6460: result: no
+configure:6430: checking for xlf90
+configure:6460: result: no
+configure:6430: checking for pgf90
+configure:6460: result: no
+configure:6430: checking for pghpf
+configure:6460: result: no
+configure:6430: checking for epcf90
+configure:6460: result: no
+configure:6430: checking for gfortran
+configure:6460: result: no
+configure:6430: checking for g95
+configure:6460: result: no
+configure:6430: checking for f95
+configure:6460: result: no
+configure:6430: checking for fort
+configure:6460: result: no
+configure:6430: checking for xlf95
+configure:6460: result: no
+configure:6430: checking for ifort
+configure:6460: result: no
+configure:6430: checking for ifc
+configure:6460: result: no
+configure:6430: checking for efc
+configure:6460: result: no
+configure:6430: checking for pgf95
+configure:6460: result: no
+configure:6430: checking for lf95
+configure:6460: result: no
+configure:6430: checking for ftn
+configure:6460: result: no
+configure:6487: checking for Fortran 77 compiler version
+configure:6494:  --version >&5
+./configure: line 6495: --version: command not found
+configure:6497: $? = 127
+configure:6504:  -v >&5
+./configure: line 6505: -v: command not found
+configure:6507: $? = 127
+configure:6514:  -V >&5
+./configure: line 6515: -V: command not found
+configure:6517: $? = 127
+configure:6525: checking whether we are using the GNU Fortran 77 compiler
+configure:6544:  -c  conftest.F >&5
+./configure: line 6545: -c: command not found
+configure:6550: $? = 127
+configure: failed program was:
+|       program main
+| #ifndef __GNUC__
+|        choke me
+| #endif
+| 
+|       end
+configure:6584: result: no
+configure:6590: checking whetheE                    E  D@ @7##:7X-@  
+    P41Q                                 @kq[R  *O            E v   v                E  h$@ @##:7X-    
+  r  accepts -g
+configure:6607:  -c -g conftes       E B@  B@               E @4%@ @R##:7Xa  r  
+   @0;	                                @ t.f >&5
+./configure: line 6608: -c: command not found
+configure:6613: $? = 127
+configure: failed program was:
+|       program main
+| 
+|       end
+configure:6646: result: no
+configure:6676: checking the maximum length of command line arguments
+configure:6785: result: 32768
+configure:6796: checking command to parse /usr/bin/nm -B output from gcc object
+configure:6901: gcc -c -g -O2  conftest.c >&5
+configure:6904: $? = 0
+configure:6908: /usr/bin/nm -B conftest.o \| sed -n -e 's/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
+configure:6911: $? = 0
+configure:6963: gcc -o conftest -g -O2   conftest.c conftstm.o >&5
+configure:6966: $? = 0
+configure:7004: result: ok
+configure:7008: checking for objdir
+configure:7023: result: .libs
+configure:7115: checking for ar
+configure:7131: found /usr/bin/ar
+configure:7142: result: ar
+configure:7211: checking for ranlib
+configure:7227: found /usr/bin/ranlib
+configure:7238: result: ranlib
+configure:7307: checking for strip
+configure:7323: found /usr/bin/strip
+configure:7334: result: strip
+configure:7620: checking if gcc supports -fno-rtti -fno-exceptions
+configure:7638: gcc -c -g -O2  -fno-rtti -fno-exceptions conftest.c >&5
+cc1: warning: command line option "-fno-rtti" is valid for C++/ObjC++ but not for C
+configure:7642: $? = 0
+configure:7655: result: no
+configure:7670: checking for gcc option to produce PIC
+configure:7880: result: -fPIC
+configure:7888: checking if gcc PIC flag -fPIC works
+configure:7906: gcc -c -g -O2  -fPIC -DPIC conftest.c >&5
+configure:7910: $? = 0
+configure:7923: result: yes
+configure:7951: checking if gcc static flag -static works
+configure:7979: result: yes
+configure:7989: checking if gcc supports -c -o file.o
+configure:8010: gcc -c -g -O2  -o out/conftest2.o conftest.c >&5
+configure:8014: $? = 0
+configure:8036: result: yes
+configure:8062: checking whether the gcc linker (/usr/bin/ld) supports shared libraries
+configure:9049: result: yes
+configure:9116: checking dynamic linker characteristics
+configure:9692: result: GNU/Linux ld.so
+configure:9701: checking how to hardcode library paths into programs
+configure:9726: result: immediate
+configure:9740: checking whether stripping libraries is possible
+configure:9745: result: yes
+configure:10658: checking if libtool supports shared libraries
+configure:10660: result: yes
+configure:10663: checking whether to build shared libraries
+configure:10684: result: no
+configure:10687: checking whether to build static libraries
+configure:10691: result: yes
+configure:10783: creating libtool
+configure:11371: checking for ld used by g++
+configure:11438: result: /usr/bin/ld
+configure:11447: checking if the linker (/usr/bin/ld) is GNU ld
+configure:11462: result: yes
+configure:11513: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
+configure:12479: result: yes
+configure:12497: g++ -c -g -O2  conftest.cpp >&5
+configure:12500: $? = 0
+configure:12619: checking for g++ option to produce PIC
+configure:12893: result: -fPIC
+configure:12901: checking if g++ PIC flag -fPIC works
+configure:12919: g++ -c -g -O2  -fPIC -DPIC conftest.cpp >&5
+configure:12923: $? = 0
+configure:12936: result: yes
+configure:12964: checking if g++ static flag -static works
+configure:12992: result: yes
+configure:13002: checking if g++ supports -c -o file.o
+configure:13023: g++ -c -g -O2  -o out/conftest2.o conftest.cpp >&5
+configure:13027: $? = 0
+configure:13049: result: yes
+configure:13075: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
+configure:13103: result: yes
+configure:13170: checking dynamic linker characteristics
+configure:13746: result: GNU/Linux ld.so
+configure:13755: checking how to hardcode library paths into programs
+configure:13780: result: immediate
+configure:19992: checking for SFS libraries
+configure:20022: result: /home/aphanish/research/overhear/dot_snap_20070206/sfslite
+configure:20114: checking for GMP library
+configure:20183: result: yes
+configure:20207: checking for overloaded C++ operators in gmp.h
+In file included from conftest.c:24:
+/usr/include/gmp.h:26:70: error: iosfwd: No such file or directory
+/usr/include/gmp.h:52:40: error: cstddef: No such file or directory
+configure:20236: result: yes
+configure:20244: checking for mpz_xor
+configure:20270: result: yes
+configure:20278: checking size of GMP mp_limb_t
+configure:20306: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:29: error: duplicate case value
+conftest.c:29: error: previously used here
+configure:20312: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| /* end confdefs.h.  */
+| #include <gmp.h>
+| int
+| main ()
+| {
+| switch (0) case 0: case (sizeof (mp_limb_t) == 2):;
+|   ;
+|   return 0;
+| }
+configure:20306: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc conftest.c >&5
+configure:20312: $? = 0
+configure:20319: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:20322: $? = 0
+configure:20329: test -s conftest.o
+configure:20332: $? = 0
+configure:20345: result: 4
+configure:20365: checking for memory.h
+configure:20371: result: yes
+configure:20566: checking for getpeereid
+configure:20622: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc  conftest.c  >&5
+/tmp/ccS9dRYD.o: In function `main':
+/home/aphanish/research/overhear/dot_snap_20070206/conftest.c:61: undefined reference to `getpeereid'
+collect2: ld returned 1 exit status
+configure:20628: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| /* Define getpeereid to an innocuous variant, in case <limits.h> declares getpeereid.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define getpeereid innocuous_getpeereid
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char getpeereid (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef getpeereid
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char getpeereid ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_getpeereid || defined __stub___getpeereid
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return getpeereid ();
+|   ;
+|   return 0;
+| }
+configure:20662: result: no
+configure:20672: checking for xdrmem_create in -lrpc
+configure:20707: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc  conftest.c -lrpc   >&5
+/usr/bin/ld: cannot find -lrpc
+collect2: ld returned 1 exit status
+configure:20713: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char xdrmem_create ();
+| int
+| main ()
+| {
+| return xdrmem_create ();
+|   ;
+|   return 0;
+| }
+configure:20747: result: no
+configure:20803: checking for pkg-config
+configure:20821: found /usr/bin/pkg-config
+configure:20833: result: /usr/bin/pkg-config
+configure:20862: checking pkg-config is at least version 0.9.0
+configure:20865: result: yes
+configure:20876: checking for OPENSSL
+configure:20884: $PKG_CONFIG --exists --print-errors "openssl"
+configure:20887: $? = 0
+configure:20902: $PKG_CONFIG --exists --print-errors "openssl"
+configure:20905: $? = 0
+configure:20981: result: yes
+configure:21012: checking for inet_aton
+configure:21068: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21074: $? = 0
+configure:21081: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21084: $? = 0
+configure:21091: test -s conftest
+configure:21094: $? = 0
+configure:21107: result: yes
+configure:21213: checking for socket
+configure:21269: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21275: $? = 0
+configure:21282: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21285: $? = 0
+configure:21292: test -s conftest
+configure:21295: $? = 0
+configure:21308: result: yes
+configure:21414: checking for gethostbyname
+configure:21470: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21476: $? = 0
+configure:21483: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21486: $? = 0
+configure:21493: test -s conftest
+configure:21496: $? = 0
+configure:21509: result: yes
+configure:21633: checking libmilter/mfapi.h usability
+configure:21650: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   conftest.c >&5
+conftest.c:60:29: error: libmilter/mfapi.h: No such file or directory
+configure:21656: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #if HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #if HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #if STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # if HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #if HAVE_STRING_H
+| # if !STDC_HEADERS && HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #if HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #if HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #endif
+| #if HAVE_STDINT_H
+| # include <stdint.h>
+| #endif
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| #include <libmilter/mfapi.h>
+configure:21687: result: no
+configure:21691: checking libmilter/mfapi.h presence
+configure:21706: gcc -E  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   conftest.c
+conftest.c:27:29: error: libmilter/mfapi.h: No such file or directory
+configure:21712: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #defineE B   B                E  4D@ @7##:7aJ,  
+  Ef v   v                E  h&@ @##:7a    
+   HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #       E *  *               E *'@ @##:7    
+   *41Q                                *Odefine HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| #include <libmilter/mfapi.h>
+configure:21733: result: no
+configure:21761: checking for libmilter/mfapi.h
+configure:21768: result: no
+configure:21894: checking for sendmail base directory in ../ 
+configure:21934: result: no
+configure:21936: checking for sendmail base from /etc/mail/sendmail.cf
+configure:21965: result: no
+configure:22309: checking if files required by libmilter are present
+configure:22319: result: no
+configure:22322: libmilter not found; not building mailfilter dir
+configure:22505: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by dot config.status 0.2, which was
+generated by GNU Autoconf 2.60.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on GS6172
+
+config.status:697: creating Makefile
+config.status:697: creating util/Makefile
+config.status:697: creating gtcd/prot/Makefile
+config.status:697: creating gtcd/xfer/Makefile
+config.status:697: creating gtcd/chunker/Makefile
+config.status:697: creating gtcd/storage/Makefile
+config.status:697: creating gtcd/Makefile
+config.status:697: creating gcp/Makefile
+config.status:697: creating cdht/Makefile
+config.status:697: creating mailfilter/Makefile
+config.status:697: creating config.h
+config.status:970: executing depfiles commands
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=i686-pc-linux-gnu
+ac_cv_c_compiler_gnu=yes
+ac_cv_cxx_compiler_gnu=yes
+ac_cv_env_CCC_set=
+ac_cv_env_CCC_value=
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=
+ac_cv_env_CPPFLAGS_value=
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_CXXCPP_set=
+ac_cv_env_CXXCPP_value=
+ac_cv_env_CXXFLAGS_set=
+ac_cv_env_CXXFLAGS_value=
+ac_cv_env_CXX_set=
+ac_cv_env_CXX_value=
+ac_cv_env_F77_set=
+ac_cv_env_F77_value=
+ac_cv_env_FFLAGS_set=
+ac_cv_env_FFLAGS_value=
+ac_cv_env_LDFLAGS_set=
+ac_cv_env_LDFLAGS_value=
+ac_cv_env_OPENSSL_CFLAGS_set=
+ac_cv_env_OPENSSL_CFLAGS_value=
+ac_cv_env_OPENSSL_LIBS_set=
+ac_cv_env_OPENSSL_LIBS_value=
+ac_cv_env_PKG_CONFIG_set=
+ac_cv_env_PKG_CONFIG_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_f77_compiler_gnu=no
+ac_cv_func_gethostbyname=yes
+ac_cv_func_getpeereid=no
+ac_cv_func_inet_aton=yes
+ac_cv_func_socket=yes
+ac_cv_header_dlfcn_h=yes
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_unistd_h=yes
+ac_cv_host=i686-pc-linux-gnu
+ac_cv_lib_rpc_xdrmem_create=no
+ac_cv_objext=o
+ac_cv_path_EGREP='/bin/grep -E'
+ac_cv_path_GREP=/bin/grep
+ac_cv_path__PATH_CPP=/usr/bin/cpp
+ac_cv_path_ac_pt_PKG_CONFIG=/usr/bin/pkg-config
+ac_cv_path_install='/usr/bin/install -c'
+ac_cv_prog_AWK=mawk
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_CXXCPP='g++ -E'
+ac_cv_prog_ac_ct_AR=ar
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_ac_ct_CXX=g++
+ac_cv_prog_ac_ct_RANLIB=ranlib
+ac_cv_prog_ac_ct_STRIP=strip
+ac_cv_prog_cc_c89=
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cxx_g=yes
+ac_cv_prog_f77_g=no
+ac_cv_prog_make_make_set=yes
+am_cv_CC_dependencies_compiler_type=gcc3
+am_cv_CXX_dependencies_compiler_type=gcc3
+lt_cv_deplibs_check_method=pass_all
+lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_ld_reload_flag=-r
+lt_cv_objdir=.libs
+lt_cv_path_LD=/usr/bin/ld
+lt_cv_path_LDCXX=/usr/bin/ld
+lt_cv_path_NM='/usr/bin/nm -B'
+lt_cv_path_SED=/bin/sed
+lt_cv_prog_compiler_c_o=yes
+lt_cv_prog_compiler_c_o_CXX=yes
+lt_cv_prog_compiler_rtti_exceptions=no
+lt_cv_prog_gnu_ld=yes
+lt_cv_prog_gnu_ldcxx=yes
+lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
+lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \([^ ]*\) \([^ ]*\)$/  {"\2", (lt_ptr) \&\2},/p'\'''
+lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^. .* \(.*\)$/extern int \1;/p'\'''
+lt_cv_sys_max_cmd_len=32768
+lt_lt_cv_prog_compiler_c_o='"yes"'
+lt_lt_cv_prog_compiler_c_o_CXX='"yes"'
+lt_lt_cv_sys_global_symbol_pipe='"sed -n -e '\''s/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2 \\2/p'\''"'
+lt_lt_cv_sys_global_symbol_to_c_name_address='"sed -n -e '\''s/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'\''"'
+lt_lt_cv_sys_global_symbol_to_cdecl='"sed -n -e '\''s/^. .* \\(.*\\)\$/extern int \\1;/p'\''"'
+pkg_cv_OPENSSL_CFLAGS=' '
+pkg_cv_OPENSSL_LIBS='-lssl -lcrypto  '
+sfs_cv_gmp_cxx_ops=yes
+sfs_cv_have_mpz_xor=yes
+sfs_cv_mp_limb_t_size=4
+sfs_cv_type_ssize_t=yes
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+ACLOCAL='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run aclocal-1.9'
+AMDEPBACKSLASH='\'
+AMDEP_FALSE='#'
+AMDEP_TRUE=''
+AMTAR='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run tar'
+AR='ar'
+AUTOCONF='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run autoconf'
+AUTOHEADER='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run autoheader'
+AUTOMAKE='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run automake-1.9'
+AWK='mawk'
+CC='gcc'
+CCDEPMODE='depmode=gcc3'
+CFLAGS='$(DEBUG) $(WFLAGS) $(ECFLAGS)'
+CPP='gcc -E'
+CPPFLAGS=' -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   -I$(top_srcdir) -I$(top_srcdir)/util -I$(top_srcdir)/gtcd -I$(top_builddir)/gtcd/prot'
+CXX='g++'
+CXXCPP='g++ -E'
+CXXDEBUG='-g -O2'
+CXXDEPMODE='depmode=gcc3'
+CXXFLAGS='$(CXXDEBUG) $(CXXWFLAGS) $(ECXXFLAGS)'
+CXXNOERR='-Wno-error'
+CXXWFLAGS='-Wall -Werror'
+CYGPATH_W='echo'
+DEBUG='-g -O2'
+DEFS='-DHAVE_CONFIG_H'
+DEPDIR='.deps'
+DMALLOC_FALSE=''
+DMALLOC_TRUE='#'
+ECFLAGS=''
+ECHO='echo'
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+ECXXFLAGS=''
+EGREP='/bin/grep -E'
+EXEEXT=''
+F77=''
+FFLAGS=''
+GMP_DIR=''
+GREP='/bin/grep'
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+INSTALL_STRIP_PROGRAM='${SHELL} $(install_sh) -c -s'
+LDADD='$(LIBSFSMISC) $(LIBSFSCRYPT) $(LIBARPC) $(LIBASYNC) $(LIBGMP) $(LIBPY) -lssl -lcrypto   $(LIBDOTUTIL)'
+LDEPS='$(LIBSFSMISC) $(LIBSFSCRYPT) $(LIBARPC) $(LIBASYNC) $(LIBDOTUTIL)'
+LDFLAGS=''
+LIBARPC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/arpc/libarpc.la'
+LIBASYNC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/async/libasync.la'
+LIBDOTUTIL='$(top_builddir)/util/libdotutil.la'
+LIBGMP='/usr/lib/libgmp.la'
+LIBGTC='$(top_builddir)/gtcd/libgtc.la'
+LIBOBJS=''
+LIBS=''
+LIBSFS='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/libsfs/libsfs.la'
+LIBSFSCRYPT='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/crypt/libsfscrypt.la'
+LIBSFSMISC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/sfsmisc/libsfsmisc.la'
+LIBSVC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc/libsvc.la'
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+LN_S='ln -s'
+LTLIBOBJS=''
+MAKEINFO='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run makeinfo'
+MALLOCK='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/sfsmisc/mallock.o'
+MILTER_CPPFLAGS=''
+MILTER_LDFLAGS=''
+MILTER_LIBS=''
+NOPAGING=''
+NW='-w'
+OBJEXT='o'
+OPENSSL_CFLAGS=' '
+OPENSSL_LIBS='-lssl -lcrypto  '
+PACKAGE='dot'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME='dot'
+PACKAGE_STRING='dot 0.2'
+PACKAGE_TARNAME='dot'
+PACKAGE_VERSION='0.2'
+PATH_SEPARATOR=':'
+PKG_CONFIG='/usr/bin/pkg-config'
+RANLIB='ranlib'
+RPCC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/rpcc/rpcc'
+SENDMAIL_BASE_DIR=''
+SENDMAIL_OBJ_DIR=''
+SET_MAKE=''
+SHELL='/bin/bash'
+STATIC_FALSE='#'
+STATIC_TRUE=''
+STRIP='strip'
+TAME='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/tame/tame'
+USE_MILTER_FALSE=''
+USE_MILTER_TRUE='#'
+VERSION='0.2'
+WFLAGS='-Wall -Werror'
+_PATH_CPP='/usr/bin/cpp'
+ac_ct_CC='gcc'
+ac_ct_CXX='g++'
+ac_ct_F77=''
+am__fastdepCC_FALSE='#'
+am__fastdepCC_TRUE=''
+am__fastdepCXX_FALSE='#'
+am__fastdepCXX_TRUE=''
+am__include='include'
+am__leading_dot='.'
+am__quote=''
+am__tar='${AMTAR} chof - "$$tardir"'
+am__untar='${AMTAR} xf -'
+bindir='${exec_prefix}/bin'
+build='i686-pc-linux-gnu'
+build_alias=''
+build_cpu='i686'
+build_os='linux-gnu'
+build_vendor='pc'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+dvidir='${docdir}'
+exec_prefix='${prefix}'
+host='i686-pc-linux-gnu'
+host_alias=''
+host_cpu='i686'
+host_os='linux-gnu'
+host_vendor='pc'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${datarootdir}/info'
+install_sh='/home/aphanish/research/overhear/dot_snap_20070206/install-sh'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localedir='${datarootdir}/locale'
+localstatedir='${prefix}/var'
+mandir='${datarootdir}/man'
+mkdir_p='mkdir -p --'
+oldincludedir='/usr/include'
+pdfdir='${docdir}'
+prefix='/usr/local'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+sbindir='${exec_prefix}/sbin'
+sfsincludedir='$(libdir)/include'
+sfslibdir='$(libdir)/sfs'
+sharedstatedir='${prefix}/com'
+subdirs=' '
+sysconfdir='${prefix}/etc'
+target_alias=''
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define PACKAGE_NAME "dot"
+#define PACKAGE_TARNAME "dot"
+#define PACKAGE_VERSION "0.2"
+#define PACKAGE_STRING "dot 0.2"
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE "dot"
+#define VERSION "0.2"
+#define PATH_CPP "/usr/bin/cpp"
+#define HAVE_SSIZE_T 1
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_UNISTD_H 1
+#define HAVE_DLFCN_H 1
+#define HAVE_GMP_CXX_OPS 1
+#define HAVE_MPZ_XOR 1
+#define GMP_LIMB_SIZE 4
+#define HAVE_MEMORY_H 1
+
+configure: exit 0
+        EX B   B                E 4v)@ @     w    
+ " EX "  "               E@ @#     w    
+ " "
+2vU&Gm^%cj_/T,`416uRNU_0Ur1#k%#8qILy]w*QooJ0h%P2kNid!Eq9N ]U0FS+Q pfc*Pj$T7,%EX B   B                E 4v*@ @     w 6  
+ " "E@[ b   b                E Tv+@ @n     w H  
+ " "r1_PQk8l`AqE\                    E @ @$S     w    
+ " "E BDyWAEPyvr	P	AQbL/)Nazd;&lJ FT%a\sE B   B                E  4D@ @7##:7V Y7  
+ % E2 B   B                E 4v,@ @     w^   
+ , "EC                    E @ @$2     ^w    
+ , ,38%|U?lD-Cb|cV0;g$!5?#e_*lq*V!d{:l nSVNjH{q2*vl;KEL B   B                E 4v-@ @     w "  
+ , ,E b   b                E Tv.@ @k     w H  
+ , ,-,qA
+#O4X&E"  B   B                E 4v/@ @     w   
+ , ,E) B   B                E 4	@ @$     w    
+ , ,E: B   B                E 4v0@ @     w    
+ , ,
\ No newline at end of file
diff -Naur src_dot_original/sniffer/dot_test.dump src/sniffer/dot_test.dump
--- src_dot_original/sniffer/dot_test.dump	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/dot_test.dump	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,1305 @@
+               E@ J   J                E  <v@ @     w      @
+     EG J   J                E  <  @ @<     w h  @
+  EL B   B                E  4v@ @     w   
+  Ef J   J                E  <@ @.'    |q    !  @
+     Eu 6   6                E  (  @ @<    |    rP  s  E J   J                E  <?@ @    O      @
+     E 6   6                E  (  @ @<        PP    E J   J                E  <p@ @I    %    B  @
+     E  6   6                E  (  @ @<        %P    Eb J   J                E  <=@ @z|    A_    &  @
+     Eg 6   6                E  (  @ @<    A    _P    Et x   x                E  j@ @$     w  ^  
+  SSH-2.0-OpenSSH_3.8.1p1  Debian-krb5 3.8.1p1-10build1
+E B   B                E  4v@ @     wF L  
+  E+ x   x                E  jv@ @v     wF ^  
+  SSH-2.0-OpenSSH_3.8.1p1  Debian-krb5 3.8.1p1-10build1
+E@ B   B                E  4@ @$     Fw'    
+  E                  E @ @"n     Fw'     
+    \XmH#j,  E%lXS   =diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1   ssh-rsa,ssh-dss   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   	none,zlib   	none,zlib                    Ev0 B   B                E  4v@ @     w'   
+  E                  E v@ @J     w'    
+    \a}-+z]   =diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1   ssh-rsa,ssh-dss   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96   	none,zlib   	none,zlib                    E B   B                E  4@ @$     w  $  
+  E Z   Z                E  Lv@ @     w @  
+     "                E B   B                E  4@ @$     w    
+  E                    E  @ @$3     w    
+         :9r17q~qv#sfZ.'zc?)X9h7W}E-zvKH%NEf4I5H;v">]I
+%$^k           E B   B                E  4v@ @     w> b  
+  E                    E  v@ @     w>   
+         7z]KEQ)=tkDl[]'mLB0N+K 
+A;.M~%WD;;	O&y6NJ L  e-      EL                  E @ @"     >w/    
+    
+!      ssh-rsa   #    G(n-fr@j9kX8ExT
+yu>J$6:|s_:
+6)5X~]'^s+   HS#fZ\/YQ5zV#JAuD[(6[CV\q@Q}h}e_6>eL{,t%{^3 A      ssh-rsa   qJb@s4J?~#yC?I7G;	yjK`8 'VR :bhhwCU!O sE             
+          E~ R   R                E  Dv@ @     w/ 8  
+     
+          E*W B   B                E  4@ @$     w?    
+  E1W r   r                E  dv@ @u     w? X  
+  5xN '{$=G>[zyS)+E7W B   B                E  4@ @$     wo    
+  EcW r   r                E  d@ @$     wo  X  
+  Z 	ex=	~nK'ZvL-&jE
+X                    E  tv@ @d     wo> h  
+  s0puQ[:z]g4d?g6`V	k>3gluEd                    E  @ @$f     >w    
+  6C,g0Fb]^YR9s8`7
+yu|)A}@Gr>*	C$,%ryEEf                    E  v@ @C     w   
+  KTt
+} {_RD\`&YMYWR$MqsS\)F 9gmJ	F"M"0E\k                    E  @ @$e     w    
+  -w`{kIsm@~8f`.M;iNstU/kR?2C"8M9\2.:(}LT;S+#L[E=m                    E  v@ @B     w   
+  |	E>R,Q3izL%K~RX}0*<CL?-
+X\9!]*$Epm                    E  @ @$d     wo    
+  $2vYeyZU#k_MlF -`7cn2nWD*wRi6AVEm 2  2               E $v @ @     wo^   
+  .F 2_L@%[0y*KEaQ<8b
+_9^3Ad	Ij&+tk_~1r-X++HN#r3+e=YsU."Fjj31$wy_)d;K
+~'Is\4/rbD1n(([?`7En                    E  @ @$c     ^w_    
+  iV|~b/iC^i4~_?>>[XfjU/~~8	Lw(Vzu ZqT;Q@Qfz_Eo                    E  v!@ @@     w_   
+  *0p&#`^	Y[~dN18"9>.C)U0SU!IH"~8aoEUp                    E  t @ @$     w  h  
+  I&O C$	1Up2G	qt9-D0ll3`K;uB\E B   B                E  4v"@ @     w \  
+  Ex                    E  v#@ @N     w x  
+  &WY"E),%Ca,/F`[46OA)Nxkx<!A=MQ1(6eEE r   r                E  d@ @$     w  X  
+  NT1n ER j3_N$qvp#,**E B   B                E  4v$@ @     w.   
+  E
+                    E  v%@ @L     w. x  
+  aX 1i/;q	D2 GB<)\c\/"Y OsLeSAG07~(Php]]OE b   b                E  T@ @$     .w_  H  
+  'YyX+];c_2EYE                    E  tv&@ @[     w_N h  
+  }:;<y!d#z1@  BJ*79*fM*#sXGE$ r   r                E  d@ @$     Nw  X  
+  #O{Qsb 	eA+i/pW0?Ks+sET                    E tv'@ @R     w~ h  
+  0h"j ^-
+ OGg/?l$hf(X6_\E r   r                E d@ @$     ~w  X  
+  ^4=p&$s	K%n#$Ei 2  2               E$v(@ @     w   
+  C,zP"O4rjwERc8qK.+`a_\^3LX"wtKXB1OO)AH
+b^)cYN4RM&f<i7Se1#8Mp)|_DA[
+^TnKi,0rk_ `9h\}ED*QFf0&l!pa(U9K"CwGy;Yu$$|EJ                    E @ @$E     w    
+  jA[!}F0oGy|'*#d#sE}I#<6}k$}JRY@*63-?6E J   J                E  <D@ @7##:      @
+     E& J   J                E  <  @ @|p##:78 s  @
+  E4 B   B                E  4D@ @7##:79 <  
+  E                    E  D@ @7=##:79   
+    m                                 w"sL
+9^0      NET    
+oid++_key0     
+oid++_val0     NOOP   
+oid++_key0     
+oid++_val0          E B   B                E  4!@ @V##:79"  <$  
+  E 6  6               E ("@ @a##:79"  f  
+    m                                        5m!toK&  @       NOOP   dl_key0    dl_val0    {!
+A#qbn)rf)  @       NOOP   dl_key0    dl_val0    @kq[R  *O      NOOP   dl_key0    dl_val0    E B   B                E  4D@ @7##:"7- ;*  
+  E> J   J                E  <L%@ @    =      @
+     EF 6   6                E  (  @ @<        >P  T  E J   J                E  <@ @        !  @
+     E 6   6                E  (  @ @<        P    E J   J                E  <@ @    .E6    =  @
+     E 6   6                E  (  @ @<    .    E6P  d  E1 J   J                E  <s_@ @Z    G    B  @
+     E6 6   6                E  (  @ @<        HP     E{ J   J                E  <D@ @u    <\    7  @
+     E 6   6                E  (  @ @<        <]P    E1                    E  D@ @7##:"7-   
+    P`J                                  5m!toK&  @             Eg                    E  D@ @7##:v7-   
+    P;	                                 {!
+A#qbn)rf)  @             E
+ B@  B@               E @4#@ @T##:7-  r  
+   @0`J                                @ This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by dot configure 0.2, which was
+generated by GNU Autoconf 2.60.  Invocation command line was
+
+  $ ./configure --with-sfs=/home/aphanish/research/overhear/dot_snap_20070206/sfslite
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = GS6172
+uname -m = i686
+uname -r = 2.6.17-10-generic
+uname -s = Linux
+uname -v = #2 SMP Tue Dec 5 22:28:26 UTC 2006
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = i686
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/lib/jvm/java-1.5.0-sun/bin
+PATH: /usr/local/sbin
+PATH: /usr/local/bin
+PATH: /usr/sbin
+PATH: /usr/bin
+PATH: /sbin
+PATH: /bin
+PATH: /usr/bin/X11
+PATH: /usr/games
+PATH: /home/aphanish/ns/ns-allinone-2.30/bin
+PATH: /home/aphanish/ns/ns-allinone-2.30/tcl8.4.11/unix
+PATH: /home/aphanish/ns/ns-allinone-2.30/tk8.4.11/unix
+PATH: /home/aphanish/ns/ns-allinone-2.30/ns-2.30
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:2015: checking for a BSD-compatible install
+configure:2071: result: /usr/bin/install -c
+configure:2082: checking whether build environment is sane
+configure:2125: result: yes
+configure:2190: checking for gawk
+configure:2220: result: no
+configure:2190: checking for mawk
+configure:2206: found /usr/bin/mawk
+configure:2217: result: mawk
+configure:2228: checking whether make sets $(MAKE)
+configure:2249: result: yes
+configure:2440: checking build system type
+configure:2458: result: i686-pc-linux-gnu
+configure:2480: checking host system type
+configure:2495: result: i686-pc-linux-gnu
+configure:2567: checking for gcc
+configure:2583: found /usr/bin/gcc
+configure:2594: result: gcc
+configure:2832: checking for C compiler version
+configure:2839: gcc --version >&5
+gcc (GCC) 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+Copyright (C) 2006 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:2842: $? = 0
+configure:2849: gcc -v >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --enable-languages=c,c++,fortran,objc,obj-c++,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.1 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-mpfr --enable-checking=release i486-linux-gnu
+Thread model: posix
+gcc version 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+configure:2852: $? = 0
+configure:2859: gcc -V >&5
+gcc: '-V' option must have argument
+configure:2862: $? = 1
+configure:2885: checking for C compiler default output file name
+configure:2912: gcc    conftest.c  >&5
+configure:2915: $? = 0
+configure:2961: result: a.out
+configure:2966: checking whether the C compiler works
+configure:2976: ./a.out
+configure:2979: $? = 0
+configure:2996: result: yes
+configure:3003: checking whether we are cross compiling
+configure:3005: result: no
+configure:3008: checking for suffix of executables
+configure:3015: gcc -o conftest    conftest.c  >&5
+configure:3018: $? = 0
+configure:3042: result: 
+configure:3048: checking for suffix of object files
+configure:3074: gcc -c   conftest.c >&5
+configure:3077: $? = 0
+configure:3100: result: o
+configure:3104: checking whether we are using the GNU C compiler
+configure:3133: gcc -c   conftest.c >&5
+configure:3139: $? = 0
+configure:3146: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3149: $? = 0
+configure:3156: test -s conftest.o
+configure:3159: $? = 0
+configure:3173: result: yes
+configure:3178: checking whether gcc accepts -g
+configure:3208: gcc -c -g  conftest.c >&5
+configure:3214: $? = 0
+configure:3221: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3224: $? = 0
+configure:3231: test -s conftest.o
+configure:3234: $? = 0
+configure:3364: result: yes
+configure:3381: checking for gcc option to accept ISO C89
+configure:3455: gcc  -c -g -O2  conftest.c >&5
+configure:3461: $? = 0
+configure:3468: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:3471: $? = 0
+configure:3478: test -s conftest.o
+configure:3481: $? = 0
+configure:3501: result: none needed
+configure:3530: checking for style of include used by make
+configure:3558: result: GNU
+configure:3586: checking dependency style of gcc
+configure:3676: result: gcc3
+configure:3698: checking how to run the C preprocessor
+configure:3738: gcc -E  conftest.c
+configure:3744: $? = 0
+configure:3782: gcc -E  conftest.c
+conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
+configure:3788: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3828: result: gcc -E
+configure:3857: gcc -E  conftest.c
+configure:3863: $? = 0
+configure:3901: gcc -E  conftest.c
+conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
+configure:3907: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:4009: checking for g++
+configure:4025: found /usr/bin/g++
+configure:4036: result: g++
+configure:4067: checking for C++ compiler version
+configure:4074: g++ --version >&5
+g++ (GCC) 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+Copyright (C) 2006 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:4077: $? = 0
+configure:4084: g++ -v >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --enable-languages=c,c++,fortran,objc,obj-c++,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.1 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-mpfr --enable-checking=release i486-linux-gnu
+Thread model: posix
+gcc version 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
+configure:4087: $? = 0
+configure:4094: g++ -V >&5
+g++: '-V' option must have argument
+configure:4097: $? = 1
+configure:4100: checking whether we are using the GNU C++ compiler
+configure:4129: g++ -c   conftest.cpp >&5
+configure:4135: $? = 0
+configure:4142: test -z "$ac_cxx_werror_flag" || test ! -s conftest.err
+configure:4145: $? = 0
+configure:4152: test -s conftest.o
+configure:4155: $? = 0
+configure:4169: result: yes
+configure:4174: checking whether g++ accepts -g
+configure:4204: g++ -c -g  conftest.cpp >&5
+configure:4210: $? = 0
+configure:4217: test -z "$ac_cxx_werror_flag" || test ! -s conftest.err
+configure:4220: $? = 0
+configure:4227: test -s conftest.o
+configure:4230: $? = 0
+configure:4360: result: yes
+configure:4385: checking dependency style of g++
+configure:4475: result: gcc3
+configure:4539: checking for cpp
+configure:4558: found /usr/bin/cpp
+configure:4570: result: /usr/bin/cpp
+configure:4610: checking for a BSD-compatible install
+configure:4666: result: /usr/bin/install -c
+configure:4677: checking whether ln -s works
+configure:4681: result: yes
+configure:4689: checking for ssize_t
+configure:4727: gcc -c -g -O2  conftest.c >&5
+configure:4733: $? = 0
+configure:4740: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:4743: $? = 0
+configure:4750: test -s conftest.o
+configure:4753: $? = 0
+configure:4765: result: yes
+configure:4849: checking for a sed that does not truncate output
+configure:4903: result: /bin/sed
+configure:4906: checking for grep that handles long lines and -e
+configure:4980: result: /bin/grep
+configure:4985: checking for egrep
+configure:5063: result: /bin/grep -E
+configure:5079: checking for ld used by gcc
+configure:5146: result: /usr/bin/ld
+configure:5155: checking if the linker (/usr/bin/ld) is GNU ld
+configure:5170: result: yes
+configure:5175: checking for /usr/bin/ld option to reload object files
+configure:5182: result: -r
+configure:5200: checking for BSD-compatible nm
+configure:5249: result: /usr/bin/nm -B
+configure:5253: checking how to recognise dependent libraries
+configure:5429: result: pass_all
+configure:5674: checking for ANSI C header files
+configure:5704: gcc -c -g -O2  conftest.c >&5
+configure:5710: $? = 0
+configure:5717: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5720: $? = 0
+configure:5727: test -s conftest.o
+configure:5730: $? = 0
+configure:5826: gcc -o conftest -g -O2   conftest.c  >&5
+configure:5829: $? = 0
+configure:5835: ./conftest
+configure:5838: $? = 0
+configure:5855: result: yes
+configure:5879: checking for sys/types.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for sys/stat.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for stdlib.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for string.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for memory.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for strings.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for inttypes.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for stdint.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5879: checking for unistd.h
+configure:5900: gcc -c -g -O2  conftest.c >&5
+configure:5906: $? = 0
+configure:5913: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5916: $? = 0
+configure:5923: test -s conftest.o
+configure:5926: $? = 0
+configure:5939: result: yes
+configure:5966: checking dlfcn.h usability
+configure:5983: gcc -c -g -O2  conftest.c >&5
+configure:5989: $? = 0
+configure:5996: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:5999: $? = 0
+configure:6006: test -s conftest.o
+configure:6009: $? = 0
+configure:6020: result: yes
+configure:6024: checking dlfcn.h presence
+configure:6039: gcc -E  conftest.c
+configure:6045: $? = 0
+configure:6066: result: yes
+configure:6094: checking for dlfcn.h
+configure:6102: result: yes
+configure:6125: checking how to run the C++ preprocessor
+configure:6161: g++ -E  conftest.cpp
+configure:6167: $? = 0
+configure:6205: g++ -E  conftest.cpp
+conftest.cpp:23:28: error: ac_nonexistent.h: No such file or directory
+configure:6211: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:6251: result: g++ -E
+configure:6280: g++ -E  conftest.cpp
+configure:6286: $? = 0
+configure:6324: g++ -E  conftest.cpp
+conftest.cpp:23:28: error: ac_nonexistent.h: No such file or directory
+configure:6330: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:6430: checking for g77
+configure:6460: result: no
+configure:6430: checking for f77
+configure:6460: result: no
+configure:6430: checking for xlf
+configure:6460: result: no
+configure:6430: checking for frt
+configure:6460: result: no
+configure:6430: checking for pgf77
+configure:6460: result: no
+configure:6430: checking for cf77
+configure:6460: result: no
+configure:6430: checking for fort77
+configure:6460: result: no
+configure:6430: checking for fl32
+configure:6460: result: no
+configure:6430: checking for af77
+configure:6460: result: no
+configure:6430: checking for f90
+configure:6460: result: no
+configure:6430: checking for xlf90
+configure:6460: result: no
+configure:6430: checking for pgf90
+configure:6460: result: no
+configure:6430: checking for pghpf
+configure:6460: result: no
+configure:6430: checking for epcf90
+configure:6460: result: no
+configure:6430: checking for gfortran
+configure:6460: result: no
+configure:6430: checking for g95
+configure:6460: result: no
+configure:6430: checking for f95
+configure:6460: result: no
+configure:6430: checking for fort
+configure:6460: result: no
+configure:6430: checking for xlf95
+configure:6460: result: no
+configure:6430: checking for ifort
+configure:6460: result: no
+configure:6430: checking for ifc
+configure:6460: result: no
+configure:6430: checking for efc
+configure:6460: result: no
+configure:6430: checking for pgf95
+configure:6460: result: no
+configure:6430: checking for lf95
+configure:6460: result: no
+configure:6430: checking for ftn
+configure:6460: result: no
+configure:6487: checking for Fortran 77 compiler version
+configure:6494:  --version >&5
+./configure: line 6495: --version: command not found
+configure:6497: $? = 127
+configure:6504:  -v >&5
+./configure: line 6505: -v: command not found
+configure:6507: $? = 127
+configure:6514:  -V >&5
+./configure: line 6515: -V: command not found
+configure:6517: $? = 127
+configure:6525: checking whether we are using the GNU Fortran 77 compiler
+configure:6544:  -c  conftest.F >&5
+./configure: line 6545: -c: command not found
+configure:6550: $? = 127
+configure: failed program was:
+|       program main
+| #ifndef __GNUC__
+|        choke me
+| #endif
+| 
+|       end
+configure:6584: result: no
+configure:6590: checking whetheE                    E  D@ @7##:7X-@  
+    P41Q                                 @kq[R  *O            E v   v                E  h$@ @##:7X-    
+  r  accepts -g
+configure:6607:  -c -g conftes       E B@  B@               E @4%@ @R##:7Xa  r  
+   @0;	                                @ t.f >&5
+./configure: line 6608: -c: command not found
+configure:6613: $? = 127
+configure: failed program was:
+|       program main
+| 
+|       end
+configure:6646: result: no
+configure:6676: checking the maximum length of command line arguments
+configure:6785: result: 32768
+configure:6796: checking command to parse /usr/bin/nm -B output from gcc object
+configure:6901: gcc -c -g -O2  conftest.c >&5
+configure:6904: $? = 0
+configure:6908: /usr/bin/nm -B conftest.o \| sed -n -e 's/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
+configure:6911: $? = 0
+configure:6963: gcc -o conftest -g -O2   conftest.c conftstm.o >&5
+configure:6966: $? = 0
+configure:7004: result: ok
+configure:7008: checking for objdir
+configure:7023: result: .libs
+configure:7115: checking for ar
+configure:7131: found /usr/bin/ar
+configure:7142: result: ar
+configure:7211: checking for ranlib
+configure:7227: found /usr/bin/ranlib
+configure:7238: result: ranlib
+configure:7307: checking for strip
+configure:7323: found /usr/bin/strip
+configure:7334: result: strip
+configure:7620: checking if gcc supports -fno-rtti -fno-exceptions
+configure:7638: gcc -c -g -O2  -fno-rtti -fno-exceptions conftest.c >&5
+cc1: warning: command line option "-fno-rtti" is valid for C++/ObjC++ but not for C
+configure:7642: $? = 0
+configure:7655: result: no
+configure:7670: checking for gcc option to produce PIC
+configure:7880: result: -fPIC
+configure:7888: checking if gcc PIC flag -fPIC works
+configure:7906: gcc -c -g -O2  -fPIC -DPIC conftest.c >&5
+configure:7910: $? = 0
+configure:7923: result: yes
+configure:7951: checking if gcc static flag -static works
+configure:7979: result: yes
+configure:7989: checking if gcc supports -c -o file.o
+configure:8010: gcc -c -g -O2  -o out/conftest2.o conftest.c >&5
+configure:8014: $? = 0
+configure:8036: result: yes
+configure:8062: checking whether the gcc linker (/usr/bin/ld) supports shared libraries
+configure:9049: result: yes
+configure:9116: checking dynamic linker characteristics
+configure:9692: result: GNU/Linux ld.so
+configure:9701: checking how to hardcode library paths into programs
+configure:9726: result: immediate
+configure:9740: checking whether stripping libraries is possible
+configure:9745: result: yes
+configure:10658: checking if libtool supports shared libraries
+configure:10660: result: yes
+configure:10663: checking whether to build shared libraries
+configure:10684: result: no
+configure:10687: checking whether to build static libraries
+configure:10691: result: yes
+configure:10783: creating libtool
+configure:11371: checking for ld used by g++
+configure:11438: result: /usr/bin/ld
+configure:11447: checking if the linker (/usr/bin/ld) is GNU ld
+configure:11462: result: yes
+configure:11513: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
+configure:12479: result: yes
+configure:12497: g++ -c -g -O2  conftest.cpp >&5
+configure:12500: $? = 0
+configure:12619: checking for g++ option to produce PIC
+configure:12893: result: -fPIC
+configure:12901: checking if g++ PIC flag -fPIC works
+configure:12919: g++ -c -g -O2  -fPIC -DPIC conftest.cpp >&5
+configure:12923: $? = 0
+configure:12936: result: yes
+configure:12964: checking if g++ static flag -static works
+configure:12992: result: yes
+configure:13002: checking if g++ supports -c -o file.o
+configure:13023: g++ -c -g -O2  -o out/conftest2.o conftest.cpp >&5
+configure:13027: $? = 0
+configure:13049: result: yes
+configure:13075: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
+configure:13103: result: yes
+configure:13170: checking dynamic linker characteristics
+configure:13746: result: GNU/Linux ld.so
+configure:13755: checking how to hardcode library paths into programs
+configure:13780: result: immediate
+configure:19992: checking for SFS libraries
+configure:20022: result: /home/aphanish/research/overhear/dot_snap_20070206/sfslite
+configure:20114: checking for GMP library
+configure:20183: result: yes
+configure:20207: checking for overloaded C++ operators in gmp.h
+In file included from conftest.c:24:
+/usr/include/gmp.h:26:70: error: iosfwd: No such file or directory
+/usr/include/gmp.h:52:40: error: cstddef: No such file or directory
+configure:20236: result: yes
+configure:20244: checking for mpz_xor
+configure:20270: result: yes
+configure:20278: checking size of GMP mp_limb_t
+configure:20306: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:29: error: duplicate case value
+conftest.c:29: error: previously used here
+configure:20312: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| /* end confdefs.h.  */
+| #include <gmp.h>
+| int
+| main ()
+| {
+| switch (0) case 0: case (sizeof (mp_limb_t) == 2):;
+|   ;
+|   return 0;
+| }
+configure:20306: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc conftest.c >&5
+configure:20312: $? = 0
+configure:20319: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:20322: $? = 0
+configure:20329: test -s conftest.o
+configure:20332: $? = 0
+configure:20345: result: 4
+configure:20365: checking for memory.h
+configure:20371: result: yes
+configure:20566: checking for getpeereid
+configure:20622: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc  conftest.c  >&5
+/tmp/ccS9dRYD.o: In function `main':
+/home/aphanish/research/overhear/dot_snap_20070206/conftest.c:61: undefined reference to `getpeereid'
+collect2: ld returned 1 exit status
+configure:20628: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| /* Define getpeereid to an innocuous variant, in case <limits.h> declares getpeereid.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define getpeereid innocuous_getpeereid
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char getpeereid (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef getpeereid
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char getpeereid ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_getpeereid || defined __stub___getpeereid
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return getpeereid ();
+|   ;
+|   return 0;
+| }
+configure:20662: result: no
+configure:20672: checking for xdrmem_create in -lrpc
+configure:20707: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc  conftest.c -lrpc   >&5
+/usr/bin/ld: cannot find -lrpc
+collect2: ld returned 1 exit status
+configure:20713: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char xdrmem_create ();
+| int
+| main ()
+| {
+| return xdrmem_create ();
+|   ;
+|   return 0;
+| }
+configure:20747: result: no
+configure:20803: checking for pkg-config
+configure:20821: found /usr/bin/pkg-config
+configure:20833: result: /usr/bin/pkg-config
+configure:20862: checking pkg-config is at least version 0.9.0
+configure:20865: result: yes
+configure:20876: checking for OPENSSL
+configure:20884: $PKG_CONFIG --exists --print-errors "openssl"
+configure:20887: $? = 0
+configure:20902: $PKG_CONFIG --exists --print-errors "openssl"
+configure:20905: $? = 0
+configure:20981: result: yes
+configure:21012: checking for inet_aton
+configure:21068: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21074: $? = 0
+configure:21081: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21084: $? = 0
+configure:21091: test -s conftest
+configure:21094: $? = 0
+configure:21107: result: yes
+configure:21213: checking for socket
+configure:21269: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21275: $? = 0
+configure:21282: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21285: $? = 0
+configure:21292: test -s conftest
+configure:21295: $? = 0
+configure:21308: result: yes
+configure:21414: checking for gethostbyname
+configure:21470: gcc -o conftest -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc    conftest.c  >&5
+configure:21476: $? = 0
+configure:21483: test -z "$ac_c_werror_flag" || test ! -s conftest.err
+configure:21486: $? = 0
+configure:21493: test -s conftest
+configure:21496: $? = 0
+configure:21509: result: yes
+configure:21633: checking libmilter/mfapi.h usability
+configure:21650: gcc -c -g -O2  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   conftest.c >&5
+conftest.c:60:29: error: libmilter/mfapi.h: No such file or directory
+configure:21656: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #define HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #if HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #if HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #if STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # if HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #if HAVE_STRING_H
+| # if !STDC_HEADERS && HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #if HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #if HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #endif
+| #if HAVE_STDINT_H
+| # include <stdint.h>
+| #endif
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| #include <libmilter/mfapi.h>
+configure:21687: result: no
+configure:21691: checking libmilter/mfapi.h presence
+configure:21706: gcc -E  -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   conftest.c
+conftest.c:27:29: error: libmilter/mfapi.h: No such file or directory
+configure:21712: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+| #define PACKAGE_NAME "dot"
+| #define PACKAGE_TARNAME "dot"
+| #define PACKAGE_VERSION "0.2"
+| #define PACKAGE_STRING "dot 0.2"
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE "dot"
+| #define VERSION "0.2"
+| #define PATH_CPP "/usr/bin/cpp"
+| #defineE B   B                E  4D@ @7##:7aJ,  
+  Ef v   v                E  h&@ @##:7a    
+   HAVE_SSIZE_T 1
+| #define STDC_HEADERS 1
+| #       E *  *               E *'@ @##:7    
+   *41Q                                *Odefine HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_DLFCN_H 1
+| #define HAVE_GMP_CXX_OPS 1
+| #define HAVE_MPZ_XOR 1
+| #define GMP_LIMB_SIZE 4
+| #define HAVE_MEMORY_H 1
+| /* end confdefs.h.  */
+| #include <libmilter/mfapi.h>
+configure:21733: result: no
+configure:21761: checking for libmilter/mfapi.h
+configure:21768: result: no
+configure:21894: checking for sendmail base directory in ../ 
+configure:21934: result: no
+configure:21936: checking for sendmail base from /etc/mail/sendmail.cf
+configure:21965: result: no
+configure:22309: checking if files required by libmilter are present
+configure:22319: result: no
+configure:22322: libmilter not found; not building mailfilter dir
+configure:22505: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by dot config.status 0.2, which was
+generated by GNU Autoconf 2.60.  Invocation command line was
+
+  CONFIG_FILES    = 
+  CONFIG_HEADERS  = 
+  CONFIG_LINKS    = 
+  CONFIG_COMMANDS = 
+  $ ./config.status 
+
+on GS6172
+
+config.status:697: creating Makefile
+config.status:697: creating util/Makefile
+config.status:697: creating gtcd/prot/Makefile
+config.status:697: creating gtcd/xfer/Makefile
+config.status:697: creating gtcd/chunker/Makefile
+config.status:697: creating gtcd/storage/Makefile
+config.status:697: creating gtcd/Makefile
+config.status:697: creating gcp/Makefile
+config.status:697: creating cdht/Makefile
+config.status:697: creating mailfilter/Makefile
+config.status:697: creating config.h
+config.status:970: executing depfiles commands
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=i686-pc-linux-gnu
+ac_cv_c_compiler_gnu=yes
+ac_cv_cxx_compiler_gnu=yes
+ac_cv_env_CCC_set=
+ac_cv_env_CCC_value=
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=
+ac_cv_env_CPPFLAGS_value=
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_CXXCPP_set=
+ac_cv_env_CXXCPP_value=
+ac_cv_env_CXXFLAGS_set=
+ac_cv_env_CXXFLAGS_value=
+ac_cv_env_CXX_set=
+ac_cv_env_CXX_value=
+ac_cv_env_F77_set=
+ac_cv_env_F77_value=
+ac_cv_env_FFLAGS_set=
+ac_cv_env_FFLAGS_value=
+ac_cv_env_LDFLAGS_set=
+ac_cv_env_LDFLAGS_value=
+ac_cv_env_OPENSSL_CFLAGS_set=
+ac_cv_env_OPENSSL_CFLAGS_value=
+ac_cv_env_OPENSSL_LIBS_set=
+ac_cv_env_OPENSSL_LIBS_value=
+ac_cv_env_PKG_CONFIG_set=
+ac_cv_env_PKG_CONFIG_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_f77_compiler_gnu=no
+ac_cv_func_gethostbyname=yes
+ac_cv_func_getpeereid=no
+ac_cv_func_inet_aton=yes
+ac_cv_func_socket=yes
+ac_cv_header_dlfcn_h=yes
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_unistd_h=yes
+ac_cv_host=i686-pc-linux-gnu
+ac_cv_lib_rpc_xdrmem_create=no
+ac_cv_objext=o
+ac_cv_path_EGREP='/bin/grep -E'
+ac_cv_path_GREP=/bin/grep
+ac_cv_path__PATH_CPP=/usr/bin/cpp
+ac_cv_path_ac_pt_PKG_CONFIG=/usr/bin/pkg-config
+ac_cv_path_install='/usr/bin/install -c'
+ac_cv_prog_AWK=mawk
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_CXXCPP='g++ -E'
+ac_cv_prog_ac_ct_AR=ar
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_ac_ct_CXX=g++
+ac_cv_prog_ac_ct_RANLIB=ranlib
+ac_cv_prog_ac_ct_STRIP=strip
+ac_cv_prog_cc_c89=
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cxx_g=yes
+ac_cv_prog_f77_g=no
+ac_cv_prog_make_make_set=yes
+am_cv_CC_dependencies_compiler_type=gcc3
+am_cv_CXX_dependencies_compiler_type=gcc3
+lt_cv_deplibs_check_method=pass_all
+lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_ld_reload_flag=-r
+lt_cv_objdir=.libs
+lt_cv_path_LD=/usr/bin/ld
+lt_cv_path_LDCXX=/usr/bin/ld
+lt_cv_path_NM='/usr/bin/nm -B'
+lt_cv_path_SED=/bin/sed
+lt_cv_prog_compiler_c_o=yes
+lt_cv_prog_compiler_c_o_CXX=yes
+lt_cv_prog_compiler_rtti_exceptions=no
+lt_cv_prog_gnu_ld=yes
+lt_cv_prog_gnu_ldcxx=yes
+lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
+lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \([^ ]*\) \([^ ]*\)$/  {"\2", (lt_ptr) \&\2},/p'\'''
+lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^. .* \(.*\)$/extern int \1;/p'\'''
+lt_cv_sys_max_cmd_len=32768
+lt_lt_cv_prog_compiler_c_o='"yes"'
+lt_lt_cv_prog_compiler_c_o_CXX='"yes"'
+lt_lt_cv_sys_global_symbol_pipe='"sed -n -e '\''s/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2 \\2/p'\''"'
+lt_lt_cv_sys_global_symbol_to_c_name_address='"sed -n -e '\''s/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'\''"'
+lt_lt_cv_sys_global_symbol_to_cdecl='"sed -n -e '\''s/^. .* \\(.*\\)\$/extern int \\1;/p'\''"'
+pkg_cv_OPENSSL_CFLAGS=' '
+pkg_cv_OPENSSL_LIBS='-lssl -lcrypto  '
+sfs_cv_gmp_cxx_ops=yes
+sfs_cv_have_mpz_xor=yes
+sfs_cv_mp_limb_t_size=4
+sfs_cv_type_ssize_t=yes
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+ACLOCAL='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run aclocal-1.9'
+AMDEPBACKSLASH='\'
+AMDEP_FALSE='#'
+AMDEP_TRUE=''
+AMTAR='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run tar'
+AR='ar'
+AUTOCONF='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run autoconf'
+AUTOHEADER='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run autoheader'
+AUTOMAKE='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run automake-1.9'
+AWK='mawk'
+CC='gcc'
+CCDEPMODE='depmode=gcc3'
+CFLAGS='$(DEBUG) $(WFLAGS) $(ECFLAGS)'
+CPP='gcc -E'
+CPPFLAGS=' -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./async -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./arpc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./crypt -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/./sfsmisc -I/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc   -I$(top_srcdir) -I$(top_srcdir)/util -I$(top_srcdir)/gtcd -I$(top_builddir)/gtcd/prot'
+CXX='g++'
+CXXCPP='g++ -E'
+CXXDEBUG='-g -O2'
+CXXDEPMODE='depmode=gcc3'
+CXXFLAGS='$(CXXDEBUG) $(CXXWFLAGS) $(ECXXFLAGS)'
+CXXNOERR='-Wno-error'
+CXXWFLAGS='-Wall -Werror'
+CYGPATH_W='echo'
+DEBUG='-g -O2'
+DEFS='-DHAVE_CONFIG_H'
+DEPDIR='.deps'
+DMALLOC_FALSE=''
+DMALLOC_TRUE='#'
+ECFLAGS=''
+ECHO='echo'
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+ECXXFLAGS=''
+EGREP='/bin/grep -E'
+EXEEXT=''
+F77=''
+FFLAGS=''
+GMP_DIR=''
+GREP='/bin/grep'
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+INSTALL_STRIP_PROGRAM='${SHELL} $(install_sh) -c -s'
+LDADD='$(LIBSFSMISC) $(LIBSFSCRYPT) $(LIBARPC) $(LIBASYNC) $(LIBGMP) $(LIBPY) -lssl -lcrypto   $(LIBDOTUTIL)'
+LDEPS='$(LIBSFSMISC) $(LIBSFSCRYPT) $(LIBARPC) $(LIBASYNC) $(LIBDOTUTIL)'
+LDFLAGS=''
+LIBARPC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/arpc/libarpc.la'
+LIBASYNC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/async/libasync.la'
+LIBDOTUTIL='$(top_builddir)/util/libdotutil.la'
+LIBGMP='/usr/lib/libgmp.la'
+LIBGTC='$(top_builddir)/gtcd/libgtc.la'
+LIBOBJS=''
+LIBS=''
+LIBSFS='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/libsfs/libsfs.la'
+LIBSFSCRYPT='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/crypt/libsfscrypt.la'
+LIBSFSMISC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/sfsmisc/libsfsmisc.la'
+LIBSVC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/svc/libsvc.la'
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+LN_S='ln -s'
+LTLIBOBJS=''
+MAKEINFO='${SHELL} /home/aphanish/research/overhear/dot_snap_20070206/missing --run makeinfo'
+MALLOCK='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/sfsmisc/mallock.o'
+MILTER_CPPFLAGS=''
+MILTER_LDFLAGS=''
+MILTER_LIBS=''
+NOPAGING=''
+NW='-w'
+OBJEXT='o'
+OPENSSL_CFLAGS=' '
+OPENSSL_LIBS='-lssl -lcrypto  '
+PACKAGE='dot'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME='dot'
+PACKAGE_STRING='dot 0.2'
+PACKAGE_TARNAME='dot'
+PACKAGE_VERSION='0.2'
+PATH_SEPARATOR=':'
+PKG_CONFIG='/usr/bin/pkg-config'
+RANLIB='ranlib'
+RPCC='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/rpcc/rpcc'
+SENDMAIL_BASE_DIR=''
+SENDMAIL_OBJ_DIR=''
+SET_MAKE=''
+SHELL='/bin/bash'
+STATIC_FALSE='#'
+STATIC_TRUE=''
+STRIP='strip'
+TAME='/home/aphanish/research/overhear/dot_snap_20070206/sfslite/tame/tame'
+USE_MILTER_FALSE=''
+USE_MILTER_TRUE='#'
+VERSION='0.2'
+WFLAGS='-Wall -Werror'
+_PATH_CPP='/usr/bin/cpp'
+ac_ct_CC='gcc'
+ac_ct_CXX='g++'
+ac_ct_F77=''
+am__fastdepCC_FALSE='#'
+am__fastdepCC_TRUE=''
+am__fastdepCXX_FALSE='#'
+am__fastdepCXX_TRUE=''
+am__include='include'
+am__leading_dot='.'
+am__quote=''
+am__tar='${AMTAR} chof - "$$tardir"'
+am__untar='${AMTAR} xf -'
+bindir='${exec_prefix}/bin'
+build='i686-pc-linux-gnu'
+build_alias=''
+build_cpu='i686'
+build_os='linux-gnu'
+build_vendor='pc'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+dvidir='${docdir}'
+exec_prefix='${prefix}'
+host='i686-pc-linux-gnu'
+host_alias=''
+host_cpu='i686'
+host_os='linux-gnu'
+host_vendor='pc'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${datarootdir}/info'
+install_sh='/home/aphanish/research/overhear/dot_snap_20070206/install-sh'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localedir='${datarootdir}/locale'
+localstatedir='${prefix}/var'
+mandir='${datarootdir}/man'
+mkdir_p='mkdir -p --'
+oldincludedir='/usr/include'
+pdfdir='${docdir}'
+prefix='/usr/local'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+sbindir='${exec_prefix}/sbin'
+sfsincludedir='$(libdir)/include'
+sfslibdir='$(libdir)/sfs'
+sharedstatedir='${prefix}/com'
+subdirs=' '
+sysconfdir='${prefix}/etc'
+target_alias=''
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define PACKAGE_NAME "dot"
+#define PACKAGE_TARNAME "dot"
+#define PACKAGE_VERSION "0.2"
+#define PACKAGE_STRING "dot 0.2"
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE "dot"
+#define VERSION "0.2"
+#define PATH_CPP "/usr/bin/cpp"
+#define HAVE_SSIZE_T 1
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_UNISTD_H 1
+#define HAVE_DLFCN_H 1
+#define HAVE_GMP_CXX_OPS 1
+#define HAVE_MPZ_XOR 1
+#define GMP_LIMB_SIZE 4
+#define HAVE_MEMORY_H 1
+
+configure: exit 0
+        EX B   B                E 4v)@ @     w    
+ " EX "  "               E@ @#     w    
+ " "
+2vU&Gm^%cj_/T,`416uRNU_0Ur1#k%#8qILy]w*QooJ0h%P2kNid!Eq9N ]U0FS+Q pfc*Pj$T7,%EX B   B                E 4v*@ @     w 6  
+ " "E@[ b   b                E Tv+@ @n     w H  
+ " "r1_PQk8l`AqE\                    E @ @$S     w    
+ " "E BDyWAEPyvr	P	AQbL/)Nazd;&lJ FT%a\sE B   B                E  4D@ @7##:7V Y7  
+ % E2 B   B                E 4v,@ @     w^   
+ , "EC                    E @ @$2     ^w    
+ , ,38%|U?lD-Cb|cV0;g$!5?#e_*lq*V!d{:l nSVNjH{q2*vl;KEL B   B                E 4v-@ @     w "  
+ , ,E b   b                E Tv.@ @k     w H  
+ , ,-,qA
+#O4X&E"  B   B                E 4v/@ @     w   
+ , ,E) B   B                E 4	@ @$     w    
+ , ,E: B   B                E 4v0@ @     w    
+ , ,
\ No newline at end of file
diff -Naur src_dot_original/sniffer/ethertype.h src/sniffer/ethertype.h
--- src_dot_original/sniffer/ethertype.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/ethertype.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 1993, 1994, 1996
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/ethertype.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Ethernet types.
+ *
+ * We wrap the declarations with #ifdef, so that if a file includes
+ * <netinet/if_ether.h>, which may declare some of these, we don't
+ * get a bunch of complaints from the C compiler about redefinitions
+ * of these values.
+ *
+ * We declare all of them here so that no file has to include
+ * <netinet/if_ether.h> if all it needs are ETHERTYPE_ values.
+ */
+
+#ifndef ETHERTYPE_LEN
+#define ETHERTYPE_LEN           2
+#endif
+
+#ifndef ETHERTYPE_GRE_ISO
+#define ETHERTYPE_GRE_ISO       0x00FE  /* not really an ethertype only used in GRE */
+#endif
+#ifndef ETHERTYPE_PUP
+#define	ETHERTYPE_PUP		0x0200	/* PUP protocol */
+#endif
+#ifndef ETHERTYPE_IP
+#define	ETHERTYPE_IP		0x0800	/* IP protocol */
+#endif
+#ifndef ETHERTYPE_ARP
+#define ETHERTYPE_ARP		0x0806	/* Addr. resolution protocol */
+#endif
+#ifndef ETHERTYPE_REVARP
+#define ETHERTYPE_REVARP	0x8035	/* reverse Addr. resolution protocol */
+#endif
+#ifndef ETHERTYPE_NS
+#define ETHERTYPE_NS		0x0600
+#endif
+#ifndef	ETHERTYPE_SPRITE
+#define	ETHERTYPE_SPRITE	0x0500
+#endif
+#ifndef ETHERTYPE_TRAIL
+#define ETHERTYPE_TRAIL		0x1000
+#endif
+#ifndef	ETHERTYPE_MOPDL
+#define	ETHERTYPE_MOPDL		0x6001
+#endif
+#ifndef	ETHERTYPE_MOPRC
+#define	ETHERTYPE_MOPRC		0x6002
+#endif
+#ifndef	ETHERTYPE_DN
+#define	ETHERTYPE_DN		0x6003
+#endif
+#ifndef	ETHERTYPE_LAT
+#define	ETHERTYPE_LAT		0x6004
+#endif
+#ifndef ETHERTYPE_SCA
+#define ETHERTYPE_SCA		0x6007
+#endif
+#ifndef	ETHERTYPE_LANBRIDGE
+#define	ETHERTYPE_LANBRIDGE	0x8038
+#endif
+#ifndef	ETHERTYPE_DECDNS
+#define	ETHERTYPE_DECDNS	0x803c
+#endif
+#ifndef	ETHERTYPE_DECDTS
+#define	ETHERTYPE_DECDTS	0x803e
+#endif
+#ifndef	ETHERTYPE_VEXP
+#define	ETHERTYPE_VEXP		0x805b
+#endif
+#ifndef	ETHERTYPE_VPROD
+#define	ETHERTYPE_VPROD		0x805c
+#endif
+#ifndef ETHERTYPE_ATALK
+#define ETHERTYPE_ATALK		0x809b
+#endif
+#ifndef ETHERTYPE_AARP
+#define ETHERTYPE_AARP		0x80f3
+#endif
+#ifndef	ETHERTYPE_8021Q
+#define	ETHERTYPE_8021Q		0x8100
+#endif
+#ifndef ETHERTYPE_IPX
+#define ETHERTYPE_IPX		0x8137
+#endif
+#ifndef ETHERTYPE_IPV6
+#define ETHERTYPE_IPV6		0x86dd
+#endif
+#ifndef ETHERTYPE_PPP
+#define	ETHERTYPE_PPP		0x880b
+#endif
+#ifndef ETHERTYPE_SLOW
+#define	ETHERTYPE_SLOW		0x8809
+#endif
+#ifndef	ETHERTYPE_MPLS
+#define	ETHERTYPE_MPLS		0x8847
+#endif
+#ifndef	ETHERTYPE_MPLS_MULTI
+#define	ETHERTYPE_MPLS_MULTI	0x8848
+#endif
+#ifndef ETHERTYPE_PPPOED
+#define ETHERTYPE_PPPOED	0x8863
+#endif
+#ifndef ETHERTYPE_PPPOES
+#define ETHERTYPE_PPPOES	0x8864
+#endif
+#ifndef ETHERTYPE_JUMBO
+#define ETHERTYPE_JUMBO         0x8870
+#endif
+#ifndef ETHERTYPE_EAPOL
+#define ETHERTYPE_EAPOL  	0x888e
+#endif
+#ifndef	ETHERTYPE_LOOPBACK
+#define	ETHERTYPE_LOOPBACK	0x9000
+#endif
+#ifndef	ETHERTYPE_VMAN
+#define	ETHERTYPE_VMAN	        0x9100 /* Extreme VMAN Protocol */ 
+#endif
+#ifndef	ETHERTYPE_ISO
+#define	ETHERTYPE_ISO           0xfefe  /* nonstandard - used in Cisco HDLC encapsulation */
+#endif
+
+extern const struct tok ethertype_values[];
diff -Naur src_dot_original/sniffer/extract.h src/sniffer/extract.h
--- src_dot_original/sniffer/extract.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/extract.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 1992, 1993, 1994, 1995, 1996
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/extract.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Macros to extract possibly-unaligned big-endian integral values.
+ */
+#ifdef LBL_ALIGN
+/*
+ * The processor doesn't natively handle unaligned loads.
+ */
+#ifdef HAVE___ATTRIBUTE__
+/*
+ * We have __attribute__; we assume that means we have __attribute__((packed)).
+ * Declare packed structures containing a u_int16_t and a u_int32_t,
+ * cast the pointer to point to one of those, and fetch through it;
+ * the GCC manual doesn't appear to explicitly say that
+ * __attribute__((packed)) causes the compiler to generate unaligned-safe
+ * code, but it apppears to do so.
+ *
+ * We do this in case the compiler can generate, for this instruction set,
+ * better code to do an unaligned load and pass stuff to "ntohs()" or
+ * "ntohl()" than the code to fetch the bytes one at a time and
+ * assemble them.  (That might not be the case on a little-endian platform,
+ * where "ntohs()" and "ntohl()" might not be done inline.)
+ */
+typedef struct {
+	u_int16_t	val;
+} __attribute__((packed)) unaligned_u_int16_t;
+
+typedef struct {
+	u_int32_t	val;
+} __attribute__((packed)) unaligned_u_int32_t;
+
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)ntohs(((const unaligned_u_int16_t *)(p))->val))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)ntohl(((const unaligned_u_int32_t *)(p))->val))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)(((u_int64_t)ntohl(((const unaligned_u_int32_t *)(p) + 0)->val)) << 32 | \
+		     ((u_int64_t)ntohl(((const unaligned_u_int32_t *)(p) + 1)->val)) << 0))
+
+#else /* HAVE___ATTRIBUTE__ */
+/*
+ * We don't have __attribute__, so do unaligned loads of big-endian
+ * quantities the hard way - fetch the bytes one at a time and
+ * assemble them.
+ */
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)((u_int16_t)*((const u_int8_t *)(p) + 0) << 8 | \
+		     (u_int16_t)*((const u_int8_t *)(p) + 1)))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 0) << 24 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 3)))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)((u_int64_t)*((const u_int8_t *)(p) + 0) << 56 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 1) << 48 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 2) << 40 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 3) << 32 | \
+	             (u_int64_t)*((const u_int8_t *)(p) + 4) << 24 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 5) << 16 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 6) << 8 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 7)))
+#endif /* HAVE___ATTRIBUTE__ */
+#else /* LBL_ALIGN */
+/*
+ * The processor natively handles unaligned loads, so we can just
+ * cast the pointer and fetch through it.
+ */
+#define EXTRACT_16BITS(p) \
+	((u_int16_t)ntohs(*(const u_int16_t *)(p)))
+#define EXTRACT_32BITS(p) \
+	((u_int32_t)ntohl(*(const u_int32_t *)(p)))
+#define EXTRACT_64BITS(p) \
+	((u_int64_t)(((u_int64_t)ntohl(*((const u_int32_t *)(p) + 0))) << 32 | \
+		     ((u_int64_t)ntohl(*((const u_int32_t *)(p) + 1))) << 0))
+#endif /* LBL_ALIGN */
+
+#define EXTRACT_24BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 0) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2)))
+
+/*
+ * Macros to extract possibly-unaligned little-endian integral values.
+ * XXX - do loads on little-endian machines that support unaligned loads?
+ */
+#define EXTRACT_LE_8BITS(p) (*(p))
+#define EXTRACT_LE_16BITS(p) \
+	((u_int16_t)((u_int16_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int16_t)*((const u_int8_t *)(p) + 0)))
+#define EXTRACT_LE_32BITS(p) \
+	((u_int32_t)((u_int32_t)*((const u_int8_t *)(p) + 3) << 24 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 2) << 16 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int32_t)*((const u_int8_t *)(p) + 0)))
+#define EXTRACT_LE_64BITS(p) \
+	((u_int64_t)((u_int64_t)*((const u_int8_t *)(p) + 7) << 56 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 6) << 48 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 5) << 40 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 4) << 32 | \
+	             (u_int64_t)*((const u_int8_t *)(p) + 3) << 24 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 2) << 16 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 1) << 8 | \
+		     (u_int64_t)*((const u_int8_t *)(p) + 0)))
diff -Naur src_dot_original/sniffer/flow_id.cc src/sniffer/flow_id.cc
--- src_dot_original/sniffer/flow_id.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/flow_id.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,138 @@
+#include <map>
+#include <vector>
+#include "flow_id.h"
+
+// Call using FlowId fid = new FlowId(inet_ntoa(ip->ip_src), inet_ntoa(ip->ip_dst), inet_ntoa(ip->ip_src), inet_ntoa(ip->ip_dst));
+
+FlowId::FlowId(const char *sip, const char *dip, unsigned int sp, unsigned int dp) { 
+    srcIp = (char *)malloc(sizeof(char) * (strlen(sip) + 1));
+    dstIp = (char *)malloc(sizeof(char) * (strlen(dip) + 1));
+
+    strcpy(srcIp, sip);
+    strcpy(dstIp, dip);
+
+    srcPort = sp;
+    dstPort = dp;
+}
+
+FlowId::FlowId(const FlowId& fid) { 
+
+    srcIp = (char *)malloc(sizeof(char) * (strlen(fid.srcIp) + 1));
+    dstIp = (char *)malloc(sizeof(char) * (strlen(fid.dstIp) + 1));
+
+    strcpy(srcIp, fid.srcIp);
+    strcpy(dstIp, fid.dstIp);
+
+    srcPort = fid.srcPort;
+    dstPort = fid.dstPort;
+}
+
+FlowId::~FlowId() { 
+    //cout << "d'tor called" << endl;
+    if (srcIp != NULL) {
+        delete srcIp; 
+    }
+    if (dstIp != NULL) {
+        delete dstIp; 
+    }
+}
+
+bool FlowId::operator==(FlowId fid2) {
+    bool retVal = false;
+    if ( (strcmp(this->srcIp, fid2.srcIp) == 0) && (strcmp(this->dstIp, fid2.dstIp) == 0)
+         && (this->srcPort == fid2.srcPort) && (this->dstPort == fid2.dstPort) ) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+bool FlowId::operator<(const FlowId& fid2) {
+    bool retVal = false;
+    if ( (this->srcPort + this->dstPort) < (fid2.srcPort + fid2.dstPort) ) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+void FlowId::print() {
+    cout << this->srcIp << ":" << this->srcPort << " => " << this->dstIp << ":" << this->dstPort << endl;
+}
+
+string* FlowId::toString() {
+    string* ps = new string();
+
+    char buffer[32];
+
+    ps->append(this->srcIp);
+    ps->append(":");
+    sprintf(buffer, "%d", this->srcPort);
+    ps->append(buffer);
+    ps->append(" => ");
+    ps->append(this->dstIp);
+    ps->append(":");
+    sprintf(buffer, "%d", this->dstPort);
+    ps->append(buffer);
+
+    return ps;
+}
+
+
+/*
+struct FlowIdCmp {
+    bool operator()(FlowId* f1, FlowId* f2) const {
+        if (*f1 < *f2) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+};
+
+int main(void) {
+
+    string s1 = "1.1.1.1";
+    string s2 = "2.2.2.2";
+
+    FlowId *fid1 = new FlowId(s1.c_str(), s2.c_str(), 11, 22);
+    FlowId *fid2 = new FlowId(s1.c_str(), s2.c_str(), 11, 23);
+
+    if (*fid1==*fid2) {
+        cout << "yoohoo" << endl;
+    } else {
+        cout << "nada" << endl;
+    }
+
+    vector< pair< FlowId*, vector<string*> > > flow_list;
+
+    vector<string*> v;
+    string* s = new string("a");
+    v.push_back(s);
+    pair< FlowId*, vector<string*> >* p = new pair< FlowId*, vector<string*> >(fid1, v);
+    flow_list.push_back(*p);
+
+    for( unsigned int i = 0; i < flow_list.size(); i++ ) {
+        if ( *(flow_list[i].first) ==  *fid1 ) {
+            cout << "yay!" << endl;
+        }
+        else {
+            cout << "boo!" << endl;
+        }
+    }
+
+    map<FlowId*, string*, FlowIdCmp> flow_map;
+    flow_map[fid1] = new string("hola!");
+    if (NULL == flow_map[fid2]) {
+        flow_map[fid2] = new string("hola again!");
+    }
+
+    map<FlowId*, string*>::iterator mi;
+    
+    cout << "fid1 => " << *(flow_map[fid1]) << endl;
+    cout << "fid2 => " << *(flow_map[fid2]) << endl;
+
+    delete fid1;
+    delete fid2;
+
+    return 0;
+}
+*/
diff -Naur src_dot_original/sniffer/flow_id.h src/sniffer/flow_id.h
--- src_dot_original/sniffer/flow_id.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/flow_id.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,26 @@
+#ifndef _FLOW_ID
+#define _FLOW_ID 1
+
+#include <iostream>
+#include <stdio.h>
+#include <sstream>
+#include <string>
+
+using namespace std;
+
+class FlowId {
+protected:
+    char *srcIp, *dstIp;
+    unsigned int srcPort, dstPort;
+
+public:
+    FlowId(const char *sip, const char *dip, unsigned int sp, unsigned int dp);
+    FlowId(const FlowId& fid);
+    virtual ~FlowId();
+    virtual bool operator==(FlowId);
+    virtual bool operator<(const FlowId&);
+    virtual void print();
+    virtual string* toString();
+};
+
+#endif //_FLOW_ID
diff -Naur src_dot_original/sniffer/ieee802_11.h src/sniffer/ieee802_11.h
--- src_dot_original/sniffer/ieee802_11.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/ieee802_11.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,357 @@
+/* $Id: ieee802_11.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ */
+/* @(#) $Header: /home/cvs/wifitools/wifipcap/ieee802_11.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL) */
+/*
+ * Copyright (c) 2001
+ *	Fortress Technologies
+ *      Charlie Lenahan ( clenahan@fortresstech.com )
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _WLANSEC_IEEE802_11_H
+#define _WLANSEC_IEEE802_11_H 1
+
+/* Lengths of 802.11 header components. */
+#define	IEEE802_11_FC_LEN		2
+#define	IEEE802_11_DUR_LEN		2
+#define	IEEE802_11_DA_LEN		6
+#define	IEEE802_11_SA_LEN		6
+#define	IEEE802_11_BSSID_LEN		6
+#define	IEEE802_11_RA_LEN		6
+#define	IEEE802_11_TA_LEN		6
+#define	IEEE802_11_SEQ_LEN		2
+#define	IEEE802_11_IV_LEN		3
+#define	IEEE802_11_KID_LEN		1
+
+/* Frame check sequence length. */
+#define	IEEE802_11_FCS_LEN		4
+
+/* Lengths of beacon components. */
+#define	IEEE802_11_TSTAMP_LEN		8
+#define	IEEE802_11_BCNINT_LEN		2
+#define	IEEE802_11_CAPINFO_LEN		2
+#define	IEEE802_11_LISTENINT_LEN	2
+
+#define	IEEE802_11_AID_LEN		2
+#define	IEEE802_11_STATUS_LEN		2
+#define	IEEE802_11_REASON_LEN		2
+
+/* Length of previous AP in reassocation frame */
+#define	IEEE802_11_AP_LEN		6
+
+#define	T_MGMT 0x0		/* management */
+#define	T_CTRL 0x1		/* control */
+#define	T_DATA 0x2		/* data */
+#define	T_RESV 0x3		/* reserved */
+
+#define	ST_ASSOC_REQUEST   	0x0
+#define	ST_ASSOC_RESPONSE 	0x1
+#define	ST_REASSOC_REQUEST   	0x2
+#define	ST_REASSOC_RESPONSE  	0x3
+#define	ST_PROBE_REQUEST   	0x4
+#define	ST_PROBE_RESPONSE   	0x5
+/* RESERVED 			0x6  */
+/* RESERVED 			0x7  */
+#define	ST_BEACON   		0x8
+#define	ST_ATIM			0x9
+#define	ST_DISASSOC		0xA
+#define	ST_AUTH			0xB
+#define	ST_DEAUTH		0xC
+/* RESERVED 			0xD  */
+/* RESERVED 			0xE  */
+/* RESERVED 			0xF  */
+
+
+#define	CTRL_PS_POLL	0xA
+#define	CTRL_RTS	0xB
+#define	CTRL_CTS	0xC
+#define	CTRL_ACK	0xD
+#define	CTRL_CF_END	0xE
+#define	CTRL_END_ACK	0xF
+
+#define	DATA_DATA		0x0
+#define	DATA_DATA_CF_ACK	0x1
+#define	DATA_DATA_CF_POLL	0x2
+#define	DATA_DATA_CF_ACK_POLL	0x3
+#define	DATA_NODATA		0x4
+#define	DATA_NODATA_CF_ACK	0x5
+#define	DATA_NODATA_CF_POLL	0x6
+#define	DATA_NODATA_CF_ACK_POLL	0x7
+
+/*
+ * Bits in the frame control field.
+ */
+#define	FC_VERSION(fc)		((fc) & 0x3)
+#define	FC_TYPE(fc)		(((fc) >> 2) & 0x3)
+#define	FC_SUBTYPE(fc)		(((fc) >> 4) & 0xF)
+#define	FC_TO_DS(fc)		((fc) & 0x0100)
+#define	FC_FROM_DS(fc)		((fc) & 0x0200)
+#define	FC_MORE_FLAG(fc)	((fc) & 0x0400)
+#define	FC_RETRY(fc)		((fc) & 0x0800)
+#define	FC_POWER_MGMT(fc)	((fc) & 0x1000)
+#define	FC_MORE_DATA(fc)	((fc) & 0x2000)
+#define	FC_WEP(fc)		((fc) & 0x4000)
+#define	FC_ORDER(fc)		((fc) & 0x8000)
+
+struct mgmt_header_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC da;
+    MAC sa;
+    MAC bssid;
+    
+    u_int16_t seq;
+    u_int8_t  frag;
+};
+
+#define	MGMT_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_DA_LEN+IEEE802_11_SA_LEN+\
+			 IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)
+
+#define	CAPABILITY_ESS(cap)	((cap) & 0x0001)
+#define	CAPABILITY_IBSS(cap)	((cap) & 0x0002)
+#define	CAPABILITY_CFP(cap)	((cap) & 0x0004)
+#define	CAPABILITY_CFP_REQ(cap)	((cap) & 0x0008)
+#define	CAPABILITY_PRIVACY(cap)	((cap) & 0x0010)
+
+typedef enum {
+	NOT_PRESENT,
+	PRESENT,
+	TRUNCATED
+} elem_status_t;
+
+
+struct ssid_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_char		ssid[33];  /* 32 + 1 for null */
+};
+
+struct rates_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	rate[16];
+};
+
+struct challenge_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	text[254]; /* 1-253 + 1 for null */
+};
+
+struct fh_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int16_t	dwell_time;
+	u_int8_t	hop_set;
+	u_int8_t 	hop_pattern;
+	u_int8_t	hop_index;
+};
+
+struct ds_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	channel;
+};
+
+struct cf_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	count;
+	u_int8_t	period;
+	u_int16_t	max_duration;
+	u_int16_t	dur_remaing;
+};
+
+struct tim_t {
+	u_int8_t	element_id;
+	u_int8_t	length;
+	u_int8_t	count;
+	u_int8_t	period;
+	u_int8_t	bitmap_control;
+	u_int8_t	bitmap[251];
+};
+
+#define	E_SSID 		0
+#define	E_RATES 	1
+#define	E_FH	 	2
+#define	E_DS 		3
+#define	E_CF	 	4
+#define	E_TIM	 	5
+#define	E_IBSS 		6
+/* reserved 		7 */
+/* reserved 		8 */
+/* reserved 		9 */
+/* reserved 		10 */
+/* reserved 		11 */
+/* reserved 		12 */
+/* reserved 		13 */
+/* reserved 		14 */
+/* reserved 		15 */
+/* reserved 		16 */
+
+#define	E_CHALLENGE 	16
+/* reserved 		17 */
+/* reserved 		18 */
+/* reserved 		19 */
+/* reserved 		16 */
+/* reserved 		16 */
+
+struct mgmt_body_t {
+	u_int8_t   	timestamp[IEEE802_11_TSTAMP_LEN];
+	u_int16_t  	beacon_interval;
+	u_int16_t 	listen_interval;
+	u_int16_t 	status_code;
+	u_int16_t 	aid;
+	u_char		ap[IEEE802_11_AP_LEN];
+	u_int16_t	reason_code;
+	u_int16_t	auth_alg;
+	u_int16_t	auth_trans_seq_num;
+	elem_status_t	challenge_status;
+	struct challenge_t  challenge;
+	u_int16_t	capability_info;
+	elem_status_t	ssid_status;
+	struct ssid_t	ssid;
+	elem_status_t	rates_status;
+	struct rates_t 	rates;
+	elem_status_t	ds_status;
+	struct ds_t	ds;
+	elem_status_t	cf_status;
+	struct cf_t	cf;
+	elem_status_t	fh_status;
+	struct fh_t	fh;
+	elem_status_t	tim_status;
+	struct tim_t	tim;
+};
+
+// XXX Jeff: no FCS fields are filled in right now
+
+struct ctrl_rts_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC ta;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_RTS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_RA_LEN+IEEE802_11_TA_LEN)
+
+struct ctrl_cts_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_CTS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)
+
+struct ctrl_ack_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_ACK_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+IEEE802_11_RA_LEN)
+
+struct ctrl_ps_poll_t {
+    u_int16_t fc;
+    u_int16_t aid;
+    MAC bssid;
+    MAC ta;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_PS_POLL_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_AID_LEN+\
+				 IEEE802_11_BSSID_LEN+IEEE802_11_TA_LEN)
+
+struct ctrl_end_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_END_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)
+
+struct ctrl_end_ack_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    MAC ra;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+#define	CTRL_END_ACK_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+				 IEEE802_11_RA_LEN+IEEE802_11_BSSID_LEN)
+
+#define	IV_IV(iv)	((iv) & 0xFFFFFF)
+#define	IV_PAD(iv)	(((iv) >> 24) & 0x3F)
+#define	IV_KEYID(iv)	(((iv) >> 30) & 0x03)
+
+struct data_hdr_ibss_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    u_int8_t fcs[4];
+};
+
+struct data_hdr_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    MAC sa;
+    MAC da;
+    MAC bssid;
+    u_int8_t fcs[4];
+};
+
+struct data_hdr_wds_t {
+    u_int16_t fc;
+    u_int16_t duration;
+    u_int16_t seq;
+    u_int8_t frag;
+    MAC ra;
+    MAC ta;
+    MAC sa;
+    MAC da;
+    u_int8_t fcs[4];
+};
+
+#define	DATA_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+\
+			 IEEE802_11_SA_LEN+IEEE802_11_DA_LEN+\
+			 IEEE802_11_BSSID_LEN+IEEE802_11_SEQ_LEN)
+
+#define	DATA_WDS_HDRLEN	(IEEE802_11_FC_LEN+IEEE802_11_DUR_LEN+	\
+			 IEEE802_11_RA_LEN+IEEE802_11_TA_LEN+\
+			 IEEE802_11_SA_LEN+IEEE802_11_DA_LEN+IEEE802_11_SEQ_LEN)
+
+/* Jeff: added for fully-decoded wep info */
+struct wep_hdr_t {
+    u_int32_t iv;
+    u_int32_t pad;
+    u_int32_t keyid;
+};
+
+// XXX TKIP/CCMP ?
+
+#endif /* _WLANSEC_IEEE802_11_H */
diff -Naur src_dot_original/sniffer/llc.h src/sniffer/llc.h
--- src_dot_original/sniffer/llc.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/llc.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 1993, 1994, 1997
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code distributions
+ * retain the above copyright notice and this paragraph in its entirety, (2)
+ * distributions including binary code include the above copyright notice and
+ * this paragraph in its entirety in the documentation or other materials
+ * provided with the distribution, and (3) all advertising materials mentioning
+ * features or use of this software display the following acknowledgement:
+ * ``This product includes software developed by the University of California,
+ * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+ * the University nor the names of its contributors may be used to endorse
+ * or promote products derived from this software without specific prior
+ * written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * @(#) $Header: /home/cvs/wifitools/wifipcap/llc.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL)
+ */
+
+/*
+ * Definitions for information in the LLC header.
+ */
+
+#define	LLC_U_FMT	3
+#define	LLC_GSAP	1
+#define	LLC_IG	        1 /* Individual / Group */
+#define LLC_S_FMT	1
+
+#define	LLC_U_POLL	0x10
+#define	LLC_IS_POLL	0x0100
+#define	LLC_XID_FI	0x81
+
+#define	LLC_U_CMD(u)	((u) & 0xef)
+#define	LLC_UI		0x03
+#define	LLC_UA		0x63
+#define	LLC_DISC	0x43
+#define	LLC_DM		0x0f
+#define	LLC_SABME	0x6f
+#define	LLC_TEST	0xe3
+#define	LLC_XID		0xaf
+#define	LLC_FRMR	0x87
+
+#define	LLC_S_CMD(is)	(((is) >> 2) & 0x03)
+#define	LLC_RR		0x0001
+#define	LLC_RNR		0x0005
+#define	LLC_REJ		0x0009
+
+#define LLC_IS_NR(is)	(((is) >> 9) & 0x7f)
+#define LLC_I_NS(is)	(((is) >> 1) & 0x7f)
+
+#ifndef LLCSAP_NULL
+#define	LLCSAP_NULL		0x00
+#endif
+#ifndef LLCSAP_GLOBAL
+#define	LLCSAP_GLOBAL		0xff
+#endif
+#ifndef LLCSAP_8021B_I
+#define	LLCSAP_8021B_I		0x02
+#endif
+#ifndef LLCSAP_8021B_G
+#define	LLCSAP_8021B_G		0x03
+#endif
+#ifndef LLCSAP_SNA
+#define	LLCSAP_SNA		0x04
+#endif
+#ifndef LLCSAP_IP
+#define	LLCSAP_IP		0x06
+#endif
+#ifndef LLCSAP_PROWAYNM
+#define	LLCSAP_PROWAYNM		0x0e
+#endif
+#ifndef LLCSAP_8021D
+#define	LLCSAP_8021D		0x42
+#endif
+#ifndef LLCSAP_RS511
+#define	LLCSAP_RS511		0x4e
+#endif
+#ifndef LLCSAP_ISO8208
+#define	LLCSAP_ISO8208		0x7e
+#endif
+#ifndef LLCSAP_PROWAY
+#define	LLCSAP_PROWAY		0x8e
+#endif
+#ifndef LLCSAP_SNAP
+#define	LLCSAP_SNAP		0xaa
+#endif
+#ifndef LLCSAP_IPX
+#define LLCSAP_IPX		0xe0
+#endif
+#ifndef LLCSAP_NETBEUI
+#define LLCSAP_NETBEUI		0xf0
+#endif
+#ifndef LLCSAP_ISONS
+#define	LLCSAP_ISONS		0xfe
+#endif
+
+/*
+ * PIDs for use with OUI_CISCO.
+ */
+#define	PID_CISCO_CDP		0x2000	/* Cisco Discovery Protocol */
+
+/*
+ * PIDs for use with OUI_RFC2684.
+ */
+#define PID_RFC2684_ETH_FCS	0x0001	/* Ethernet, with FCS */
+#define PID_RFC2684_ETH_NOFCS	0x0007	/* Ethernet, without FCS */
+#define PID_RFC2684_802_4_FCS	0x0002	/* 802.4, with FCS */
+#define PID_RFC2684_802_4_NOFCS	0x0008	/* 802.4, without FCS */
+#define PID_RFC2684_802_5_FCS	0x0003	/* 802.5, with FCS */
+#define PID_RFC2684_802_5_NOFCS	0x0009	/* 802.5, without FCS */
+#define PID_RFC2684_FDDI_FCS	0x0004	/* FDDI, with FCS */
+#define PID_RFC2684_FDDI_NOFCS	0x000a	/* FDDI, without FCS */
+#define PID_RFC2684_802_6_FCS	0x0005	/* 802.6, with FCS */
+#define PID_RFC2684_802_6_NOFCS	0x000b	/* 802.6, without FCS */
+#define PID_RFC2684_BPDU	0x000e	/* BPDUs */
+
+/* Jeff: endian-fixed llc/snap header + ethernet type */
+struct llc_hdr_t {
+    uint8_t dsap;
+    uint8_t ssap;
+    uint8_t control;
+    uint16_t oui;
+    uint16_t type;
+};
diff -Naur src_dot_original/sniffer/Makefile.am src/sniffer/Makefile.am
--- src_dot_original/sniffer/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/Makefile.am	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,18 @@
+INCLUDES = -I$(top_srcdir)/gtcd/sniffer -I$(top_srcdir)/gtcd/xfer
+
+$(PROGRAMS): $(LDEPS) $(LIBGTC)
+AM_LDFLAGS = -all-static
+bin_PROGRAMS = sniffTcp
+noinst_HEADERS = contiguous_block.h  flow_id.h  reconstructed_chunk.h  types.h  ethertype.h  util.h  extract.h  ieee802_11.h  llc.h  oui.h  SniffTcp.h
+
+sniffTcp_SOURCES = contiguous_block.cc  flow_id.cc  reconstructed_chunk.cc  util.cc  crc32.cc  SniffTcp.cc
+sniffTcp_LDADD =  -lpcap  $(top_srcdir)/gtcd/sniffer/libsnifferPlugin.la $(LIBGTC) $(LDADD)
+
+SUFFIXES = .cc .h
+
+SniffTcp.o:  ../gtcd/xfer/xferPlugin_gtc_prot.h ../gtcd/sniffer/snifferPlugin_tcp_prot.h ../gtcd/prot/gtc_prot.h
+
+dist-hook:
+
+CLEANFILES = core *.core *~ 
+MAINTAINERCLEANFILES = Makefile.in
diff -Naur src_dot_original/sniffer/oui.h src/sniffer/oui.h
--- src_dot_original/sniffer/oui.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/oui.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,78 @@
+/* @(#) $Header: /home/cvs/wifitools/wifipcap/oui.h,v 1.1.1.1 2006/12/14 01:22:11 jpang Exp $ (LBL) */
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that: (1) source code
+ * distributions retain the above copyright notice and this paragraph
+ * in its entirety, and (2) distributions including binary code include
+ * the above copyright notice and this paragraph in its entirety in
+ * the documentation or other materials provided with the distribution.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND
+ * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
+ * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE.
+ *
+ * Original code by Hannes Gredler (hannes@juniper.net)
+ */
+
+extern struct tok oui_values[];
+extern struct tok smi_values[];
+
+#define OUI_ENCAP_ETHER 0x000000        /* encapsulated Ethernet */
+#define OUI_CISCO       0x00000c        /* Cisco protocols */
+#define OUI_NORTEL      0x000081        /* Nortel SONMP */
+#define OUI_CISCO_90    0x0000f8        /* Cisco bridging */
+#define OUI_RFC2684     0x0080c2        /* RFC 2427/2684 bridged Ethernet */
+#define OUI_ATM_FORUM   0x00A03E        /* ATM Forum */
+#define OUI_CABLE_BPDU  0x00E02F        /* DOCSIS spanning tree BPDU */
+#define OUI_APPLETALK   0x080007        /* Appletalk */
+#define OUI_JUNIPER     0x009069        /* Juniper */
+#define OUI_HP          0x080009        /* Hewlett-Packard */
+
+/*
+ * These are SMI Network Management Private Enterprise Codes for
+ * organizations; see
+ *
+ *	http://www.iana.org/assignments/enterprise-numbers
+ *
+ * for a list.
+ *
+ * List taken from Ethereal's epan/sminmpec.h.
+ */
+#define SMI_IETF                     0 /* reserved - used by the IETF in L2TP? */
+#define SMI_ACC                      5
+#define SMI_CISCO                    9
+#define SMI_HEWLETT_PACKARD          11
+#define SMI_SUN_MICROSYSTEMS         42
+#define SMI_MERIT                    61
+#define SMI_SHIVA                    166
+#define SMI_ERICSSON                 193
+#define SMI_CISCO_VPN5000            255
+#define SMI_LIVINGSTON               307
+#define SMI_MICROSOFT                311
+#define SMI_3COM                     429
+#define SMI_ASCEND                   529
+#define SMI_BAY                      1584
+#define SMI_FOUNDRY                  1991
+#define SMI_VERSANET                 2180
+#define SMI_REDBACK                  2352
+#define SMI_JUNIPER                  2636
+#define SMI_APTIS                    2637
+#define SMI_CISCO_VPN3000            3076
+#define SMI_COSINE                   3085
+#define SMI_SHASTA                   3199
+#define SMI_NETSCREEN                3224
+#define SMI_NOMADIX                  3309
+#define SMI_SIEMENS                  4329
+#define SMI_CABLELABS                4491
+#define SMI_UNISPHERE                4874
+#define SMI_CISCO_BBSM               5263
+#define SMI_THE3GPP2                 5535
+#define SMI_IP_UNPLUGGED             5925
+#define SMI_ISSANNI                  5948
+#define SMI_QUINTUM                  6618
+#define SMI_INTERLINK                6728
+#define SMI_COLUBRIS                 8744
+#define SMI_COLUMBIA_UNIVERSITY      11862
+#define SMI_THE3GPP                  10415
+#define SMI_GEMTEK_SYSTEMS           10529
+#define SMI_WIFI_ALLIANCE            14122
diff -Naur src_dot_original/sniffer/reconstructed_chunk.cc src/sniffer/reconstructed_chunk.cc
--- src_dot_original/sniffer/reconstructed_chunk.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/reconstructed_chunk.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,230 @@
+#include "reconstructed_chunk.h"
+
+
+ReconstructedChunk::ReconstructedChunk(string *p_cid, int len)
+{
+    p_chunk_id = new string(*p_cid);
+    length = len;
+    //p_chunk = (char*) malloc(sizeof(char) * len);
+    p_create_time = (struct timeval *) malloc(sizeof(struct timeval));
+    gettimeofday(p_create_time, NULL);
+}
+
+ReconstructedChunk::ReconstructedChunk(const ReconstructedChunk &copyin)
+{
+    p_chunk_id = new string(*(copyin.p_chunk_id));
+    length = copyin.length;
+    flow_seq_map = copyin.flow_seq_map;
+    uniquely_contributing_flows = copyin.uniquely_contributing_flows;
+
+    p_create_time = (struct timeval *) malloc(sizeof(struct timeval));
+    memcpy(p_create_time, copyin.p_create_time, sizeof(struct timeval));
+
+    //p_chunk = (char*) malloc(sizeof(char) * length);
+    //memcpy(p_chunk, copyin.p_chunk, length);
+
+    // XXX : dangerous - not doing deep copy 
+    // - but ok for time being as this presumably is called only when we first insert it into the map in SniffTcp.cc
+    lcb = copyin.lcb;
+}
+
+/*
+ostream &operator<<(ostream &output, const ReconstructedChunk &rc)
+{
+    output << *(rc.p_chunk_id) << " : " << rc.length << " : " << *(rc.p_chunk) << endl;
+    return output;
+}
+*/
+
+
+/* this function should be called only after an entry for the tcp flow 
+   is inserted into the flow_seq_map.
+*/
+bool ReconstructedChunk::fill_gaps_in_chunk(FlowId *pFid, string* pFidStr, 
+                                const u_char *payload, int size_payload, 
+                                tcp_seq seq_num, unsigned long *p_numDuplicateBytes) 
+{
+    map<string, tcp_seq>::iterator fsi = flow_seq_map.find(*pFidStr);
+    if (fsi != flow_seq_map.end()) {
+
+        bool b_duplicate = false;
+
+        // If it does, check if the current packet is a dup and if so discard.
+        // Else, check if contiguous
+        //    if so fuse
+        //    else append.
+
+
+        tcp_seq starting_seq_number = fsi->second;
+        tcp_seq normalized_seq_num = seq_num - starting_seq_number;
+
+#ifdef AMAR_DEBUG_1
+        cout << "ReconstructedChunk:: " << "Existing flow! For incoming packet => seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)
+             << ". normalized seq # = " << normalized_seq_num << ". Normalized next expected seq # = " << (normalized_seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG_1
+        std::list<ContiguousBlock*>::iterator li;
+        bool bDone = false;
+
+        // TODO :: maybe better to start from the end of the list and move back
+        for (li = lcb.begin(); li != lcb.end(); ++li) {
+            if ( *li !=  0 ) {
+
+                /*
+                  if ( ((seq_num + size_payload) == (*li)->next_expected_seq_number) && (seq_num == (*li)->starting_seq_number) ) {
+                  // duplicate - hence ignore
+                  bDone = true;
+                  break;
+                  }
+
+                  // TODO ::
+                  // there are also cases where
+                  // a) start boundary is the same and the end boundary is different
+                  // b) end bondary is the same and the start boundary is different
+                  // ignoring these cases for the time being
+                  */
+
+#ifdef AMAR_DEBUG_1
+                cout << "ReconstructedChunk:: " << "cb.starting_seq_number = " << (*li)->starting_seq_number 
+                     << "; cb.next_expected_seq_number = " << (*li)->next_expected_seq_number 
+                     << endl;
+#endif //AMAR_DEBUG_1
+
+
+                if ( normalized_seq_num < (*li)->starting_seq_number ) {
+                    if ( (normalized_seq_num + size_payload) == (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "pre-contiguous! prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        (*li)->prepend((const char*)payload, size_payload, normalized_seq_num);
+                    }
+                    else if ( (normalized_seq_num + size_payload) < (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "not pre-contiguous. inserting new cb ..." << endl;
+#endif //AMAR_DEBUG_1
+                        ContiguousBlock* p_cb = new ContiguousBlock();
+                        p_cb->append((const char*)payload, size_payload, normalized_seq_num);
+                        lcb.insert(li, p_cb);
+                    }
+                    else if ( (normalized_seq_num + size_payload) <= (*li)->next_expected_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "pre-contiguous-overlapping! pruning and prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload - ((*li)->starting_seq_number - normalized_seq_num);
+                        (*li)->prepend((const char*)payload, (*li)->starting_seq_number - normalized_seq_num, normalized_seq_num);
+                    }
+                    else {
+                        // ( (normalized_seq_num + size_payload) > (*li)->next_expected_seq_number )
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "overlapping packet! pruning and prepending ..." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload - ((*li)->starting_seq_number - normalized_seq_num);
+                        (*li)->prepend((const char*)payload, (*li)->starting_seq_number - normalized_seq_num, normalized_seq_num);
+
+                        // TODO :: there is stuff still remaining at the end of the packet.
+                    }
+
+                    bDone = true;
+                    break;
+                }
+                else if ( (normalized_seq_num >= (*li)->starting_seq_number) && 
+                          (normalized_seq_num <= (*li)->next_expected_seq_number) ) {
+                    // new contiguous packet
+#ifdef AMAR_DEBUG_1
+                    cout << "ReconstructedChunk:: " << "contiguous appending ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                    // do something, only if there is extra information
+                    if ( (normalized_seq_num  + size_payload) > (*li)->next_expected_seq_number) {
+
+                        // ignore the overlapping part and just append the extra stuff
+                        string *p_s = new string();
+                        p_s->append((const char*)payload, size_payload);
+
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "old value of numDuplicateBytes = " << *p_numDuplicateBytes << endl;
+                        cout << "ReconstructedChunk:: " << "adding " << ((*li)->next_expected_seq_number - normalized_seq_num) << " to numDuplicateBytes." << endl;
+#endif //AMAR_DEBUG_1
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + (*li)->next_expected_seq_number - normalized_seq_num;
+                        (*li)->overlapping_append(p_s, (*li)->next_expected_seq_number - normalized_seq_num, normalized_seq_num + size_payload);
+                        delete p_s;
+
+                        std::list<ContiguousBlock*>::iterator li2(li);
+                        li2++;
+                        while (li2 != lcb.end()) {
+                            if ( (*li2)->starting_seq_number <= (*li)->next_expected_seq_number ) {
+#ifdef AMAR_DEBUG_1
+                                cout << "ReconstructedChunk:: " << "merging ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                                if ( (*li2)->next_expected_seq_number > (*li)->next_expected_seq_number ) {
+                                    // time to merge the two
+                                    *p_numDuplicateBytes = *p_numDuplicateBytes + (*li)->next_expected_seq_number - (*li2)->starting_seq_number;
+                                    (*li)->overlapping_append( ((*li2)->p_s_contiguous_block), (*li)->next_expected_seq_number - (*li2)->starting_seq_number, (*li2)->next_expected_seq_number );
+                                    lcb.erase(li2);
+                                    break;
+                                }
+                                else {
+                                    // (*li2)->next_expected_seq_number <= (*li)->next_expected_seq_number
+                                    // the overlap goes beyond the next packet(indicated by li2)
+                                    *p_numDuplicateBytes = *p_numDuplicateBytes + (*li2)->next_expected_seq_number - (*li2)->starting_seq_number;
+				    std::list<ContiguousBlock*>::iterator li3(li2);
+                                    li2++;
+                                    lcb.erase(li3);
+                                }
+                            }
+                            else {
+                                break;
+                            }
+                        }
+                    }
+                    else {
+#ifdef AMAR_DEBUG_1
+                        cout << "ReconstructedChunk:: " << "we already have this information (from some other flow) ignoring ..." << endl;
+#endif //AMAR_DEBUG_1
+                        b_duplicate = true;
+                        *p_numDuplicateBytes = *p_numDuplicateBytes + size_payload;
+                    }
+
+                    bDone = true;
+                    break;
+                }
+            }
+        }
+
+        if (!bDone) {
+#ifdef AMAR_DEBUG_1
+            cout << "ReconstructedChunk:: " << "packet from the future, inserting at the end of the list." << endl;
+#endif //AMAR_DEBUG_1
+            ContiguousBlock* p_cb = new ContiguousBlock();
+            p_cb->append((const char*)payload, size_payload, normalized_seq_num);
+            lcb.push_back(p_cb);
+        }
+
+#ifdef AMAR_DEBUG_1
+        cout << "ReconstructedChunk:: " << "# of cbs = " << lcb.size() << endl;
+#endif //AMAR_DEBUG_1
+
+
+        if (false == b_duplicate) {
+            // we inserted something new !
+
+            uniquely_contributing_flows.insert(make_pair(*pFidStr, 0));
+            std::list<ContiguousBlock*>::iterator i = lcb.begin();
+            if (*i != NULL) {
+                if ( (*i)->p_s_contiguous_block->size() >= (unsigned int) length ) return true;
+            }
+        }
+        return false;
+    }
+    return false;
+}
+
+
+const char* ReconstructedChunk::get_data() {
+    const char* p_ret_data = NULL;
+    std::list<ContiguousBlock*>::iterator i = lcb.begin();
+    if (*i != NULL) {
+        p_ret_data = (*i)->p_s_contiguous_block->data();
+    }
+    return p_ret_data;
+}
diff -Naur src_dot_original/sniffer/reconstructed_chunk.h src/sniffer/reconstructed_chunk.h
--- src_dot_original/sniffer/reconstructed_chunk.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/reconstructed_chunk.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,66 @@
+#ifndef _RECONSTRUCTED_CHUNK
+#define _RECONSTRUCTED_CHUNK 1
+
+
+// this is very imp :-) - needed for gettimeofday! don't ask!
+#include <pcap.h>
+
+#include <map>
+#include <iostream>
+#include <netinet/tcp.h>
+
+#include "flow_id.h"
+#include "contiguous_block.h"
+
+using namespace std;
+
+//#define AMAR_DEBUG_1 1
+
+class ReconstructedChunk
+{
+    //friend ostream &operator<<(ostream &, const ReconstructedChunk &);
+
+ public:
+   string* p_chunk_id;
+   struct timeval *p_create_time;
+
+   //char* p_chunk;
+   std::list<ContiguousBlock*> lcb;
+
+   int length;
+   map<string, tcp_seq> flow_seq_map;
+   map<string, int> uniquely_contributing_flows;
+
+   ReconstructedChunk(string*, int);
+   ReconstructedChunk(const ReconstructedChunk &);
+   ~ReconstructedChunk() 
+   {
+       if (p_chunk_id)
+           delete p_chunk_id;
+
+       /*
+       if (p_chunk)
+           free(p_chunk);
+       */
+
+       std::list<ContiguousBlock*>::iterator i;
+       for (i = lcb.begin(); i != lcb.end(); ++i) {
+           //print_payload((const u_char*) (*i)->p_s_contiguous_block->c_str(), (*i)->p_s_contiguous_block->size());
+           delete *i;
+       }
+
+       flow_seq_map.clear();
+       uniquely_contributing_flows.clear();
+       free(p_create_time);
+   };
+   ReconstructedChunk &operator=(const ReconstructedChunk &rhs);
+   int get_flow_offset(FlowId* pFid);
+
+   bool fill_gaps_in_chunk(FlowId *pFid, string* pFidStr, 
+                           const u_char *payload, int size_payload, 
+                           tcp_seq seq_num, unsigned long *p_numDuplicateBytes);
+
+   const char* get_data();
+};
+
+#endif // _RECONSTRUCTED_CHUNK
diff -Naur src_dot_original/sniffer/SniffTcp.cc src/sniffer/SniffTcp.cc
--- src_dot_original/sniffer/SniffTcp.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/SniffTcp.cc	2008-08-11 12:59:25.000000000 -0400
@@ -0,0 +1,2235 @@
+#define DOT_OFFSET_FIELD_FROM_RPC_HEADER 32
+#define DOT_OFFSET_FIELD_LEN 8
+#define RPC_HEADER 0x80
+#define CHUNK_ID_LEN_FIELD 4
+#define LEN_OF_CHUNK_ID 20
+#define CHUNK_LEN_FIELD 4
+
+#include "SniffTcp.h"
+#include <string.h>
+
+#include <netinet/in.h>
+
+enum run_mode_t {
+  OFFLINE = 0,
+  ONLINE = 1,
+  OFFLINE_ONLINE = 2,
+  ONLINE_WIFI = 3,
+  OFFLINE_ONLINE_WIFI = 4
+};
+
+struct run_params_t {
+  int num_pkts;
+  char *interface;
+  char *socket;
+  run_mode_t mode;
+  char *ip_to_ignore;
+  int multi_chance;
+};
+
+run_params_t g_run_options;
+bool g_multi_chances = true;
+
+// XXX :: TESTING - BEGIN
+FlowId *g_pFid = NULL;
+string *g_pFidStr = NULL;
+// XXX :: TESTING - END
+
+dot_desc string_to_dot_desc (string s);
+
+
+SniffTcp::SniffTcp(const char* s)
+{
+    p_flow_list = new std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >();
+
+    mask_size_in_bytes = 24;
+    memset(mask, 0, mask_size_in_bytes);
+    mask[3] = 1;
+    mask[23] = 1;
+    //print_payload((const u_char*)mask, mask_size_in_bytes);
+
+    numChunksSniffed = 0;
+    numPacketsCaptured = 0;
+    numBytesOfTcpPacketsCaptured = 0;
+    numBytesOfChunksSniffed = 0;
+    numTcpPacketsCaptured = 0;
+    numDuplicateBytes = 0;
+
+    int fd = unixsocket_connect(s);
+    if (fd < 0)
+        fatal("%s: %m\n", s);
+
+    // warn("Connected via FD: %d\n", fd);
+
+    /* Setup GTC connection */
+    warn << "Connected to sniffer pluging listening at " << s << "\n";
+    ptr<axprt_unix> sniffer_x(axprt_unix::alloc(fd, MAX_PKTSIZE));
+    sniffer_c = aclnt::alloc(sniffer_x, sniffer_tcp_program_1);
+
+
+
+    // FOR TIMING
+
+    // used to time the e2e processing time of a TCP packet with a payload
+    g_p_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    // used to time the e2e processing time of a DOT TCP payload with a Chunk Id
+    g_p_with_cid_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_with_cid_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    // to time the e2e processing time of a DOT TCP payload without a Chunk Id
+    g_p_without_cid_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_without_cid_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    /* this is used to time the code which checks if any of the packets
+       for a given flow, in the global data structure p_flow_list, can complete 
+       a chunk. The code block to do this (deal_with_candidates_for_chunk) is 
+       only called when a packet containing a DOT chunk id is received AND this
+       chunk id has not been seen before.
+    */
+    g_p_deal_with_candidates_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_deal_with_candidates_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+    deal_delta_t = 0;
+
+    /* 
+       When we get a packet with a chunk id, we cycle thru the flow_chunk_map, 
+       to check if we have seen this chunk id before. This times that loop.
+    */
+    g_p_cid_iteration_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_cid_iteration_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+
+    /* 
+       when we get a packet *without* a chunk id, we cycle thru the flow_chunk_map, 
+       and for every chunk id associated with the flow we check to see if the 
+       packet that just came in fits-in. 
+       This times that loop.
+       Also captured in g_p_without_cid_*_time - these ones below just deal with
+       the OLD/Exisiting FLOW case.
+    */
+    g_p_cid_iteration_fit_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_cid_iteration_fit_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+
+    g_p_store_start_t = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_store_end_t = (struct timeval *) malloc(sizeof(struct timeval));
+
+    cid_iter_t = 0;
+    cid_iter_fit_t = 0;
+    g_store_time = 0;
+}
+
+SniffTcp::SniffTcp(SniffTcp& sniffer)
+{
+    // TODO
+}
+
+SniffTcp::~SniffTcp()
+{
+    //cout << "#####" << endl;
+    while(!p_flow_list->empty()) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = p_flow_list->back();
+        FlowId* pFid = p->first;
+	//pFid->print();
+        delete pFid;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+	//cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ++i) {
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            //print_payload((const u_char*) (*i)->p_s_contiguous_block->c_str(), (*i)->p_s_contiguous_block->size());
+            delete *i;
+        }
+        delete stream_blocks;
+        delete p;
+
+        p_flow_list->pop_back();
+	//cout << "*****" << endl;
+    }
+    delete p_flow_list;
+
+
+    flow_chunk_map.clear();
+    chunkId_reconstructedChunk_map.clear();
+
+    free(g_p_start_time);
+    free(g_p_end_time);
+    free(g_p_with_cid_start_time);
+    free(g_p_with_cid_end_time);
+    free(g_p_without_cid_start_time);
+    free(g_p_without_cid_end_time);
+
+    free(g_p_deal_with_candidates_start_time);
+    free(g_p_deal_with_candidates_end_time);
+    free(g_p_cid_iteration_start_time);
+    free(g_p_cid_iteration_end_time);
+    free(g_p_cid_iteration_fit_start_time);
+    free(g_p_cid_iteration_fit_end_time);
+
+    free(g_p_store_start_t);
+    free(g_p_store_end_t);
+
+    cout << "#####" << endl;
+}
+
+
+/*
+ * print data in rows of 16 bytes: offset   hex   ascii
+ *
+ * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+ */
+void SniffTcp::print_hex_ascii_line(const u_char *payload,
+                                    int len,
+                                    int offset)
+{
+    int i;
+    int gap;
+    const u_char *ch;
+
+    /* offset */
+    printf("%05d   ", offset);
+
+    /* hex */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        printf("%02x ", *ch);
+        ch++;
+        /* print extra space after 8th byte for visual aid */
+        if (i == 7)
+            printf(" ");
+    }
+    /* print space to handle line less than 8 bytes */
+    if (len < 8)
+        printf(" ");
+
+    /* fill hex gap with spaces if not full line */
+    if (len < 16) {
+        gap = 16 - len;
+        for (i = 0; i < gap; i++) {
+            printf("   ");
+        }
+    }
+    printf("   ");
+
+    /* ascii (if printable) */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        if (isprint(*ch))
+            printf("%c", *ch);
+        else
+            printf(".");
+        ch++;
+    }
+
+    printf("\n");
+
+    return;
+}
+
+/*
+ * print packet payload data (avoid printing binary data)
+ */
+void SniffTcp::print_payload(const u_char *payload,
+                             int len)
+{
+    int len_rem = len;
+    int line_width = 16;			/* number of bytes per line */
+    int line_len;
+    int offset = 0;					/* zero-based offset counter */
+    const u_char *ch = payload;
+
+    if (len <= 0)
+        return;
+
+    /* data fits on one line */
+    if (len <= line_width) {
+        print_hex_ascii_line(ch, len, offset);
+        return;
+    }
+
+    /* data spans multiple lines */
+    for ( ;; ) {
+        /* compute current line length */
+        line_len = line_width % len_rem;
+        /* print line */
+        print_hex_ascii_line(ch, line_len, offset);
+        /* compute total remaining */
+        len_rem = len_rem - line_len;
+        /* shift pointer to remaining bytes to print */
+        ch = ch + line_len;
+        /* add offset */
+        offset = offset + line_width;
+        /* check if we have line width chars or less */
+        if (len_rem <= line_width) {
+            /* print last line and get out */
+            print_hex_ascii_line(ch, len_rem, offset);
+            break;
+        }
+    }
+
+    return;
+}
+
+/* handle ethernet packets, much of this code gleaned from
+ * print-ether.c from tcpdump source
+ */
+u_int16_t SniffTcp::handle_ethernet(const struct pcap_pkthdr* pkthdr,
+                                    const u_char* packet)
+{
+    u_int caplen = pkthdr->caplen;
+#ifdef AMAR_DEBUG
+    u_int length = pkthdr->len;
+#endif //AMAR_DEBUG
+    struct ether_header *eptr;  /* net/ethernet.h */
+    u_short ether_type;
+
+    if (caplen < ETHER_HDRLEN) {
+        cout << "Packet length less than ethernet header length." << endl;
+        return ~0;
+    }
+
+    /* lets start with the ether header... */
+    eptr = (struct ether_header *) packet;
+    ether_type = ntohs(eptr->ether_type);
+
+#ifdef AMAR_DEBUG
+    /* print SOURCE DEST TYPE LENGTH */
+    fprintf(stdout,"ETH: ");
+    fprintf(stdout,"[%s => ", ether_ntoa((struct ether_addr*)eptr->ether_shost));
+    fprintf(stdout,"%s] ", ether_ntoa((struct ether_addr*)eptr->ether_dhost));
+
+    /* check to see if we have an ip packet */
+    if (ether_type == ETHERTYPE_IP) {
+        cout << "(IP)";
+    }
+    else  if (ether_type == ETHERTYPE_ARP) {
+        cout << "(ARP)";
+    }
+    else  if (eptr->ether_type == ETHERTYPE_REVARP) {
+        cout << "(RARP)";
+    }
+    else {
+        cout << "(?)";
+    }
+    cout << length << endl;
+#endif //AMAR_DEBUG
+
+    return ether_type;
+}
+
+
+void SniffTcp::handle_ip(u_int length,
+                         const u_char* ip_packet)
+{
+    const struct sniff_ip* ip;
+    u_int ip_hlen, off, version;
+    u_int len;
+    u_int size_tcp_header;
+    const struct sniff_tcp *tcp;
+    const u_char *payload; /* Packet payload */
+    int size_payload;
+
+    /* jump past the ethernet header */
+    ip = (struct sniff_ip*)(ip_packet);
+
+    /* check to see we have a packet of valid length */
+    if (length < sizeof(struct sniff_ip))
+        {
+            printf("Truncated ip packet (length = %d).\n", length);
+            return;
+        }
+
+    // length of the ip packet along with the ip header
+    len     = ntohs(ip->ip_len);
+    ip_hlen = IP_HL(ip)*4; /* header length */
+    version = IP_V(ip);  /* ip version */
+
+    /* check version */
+    if (version != 4) {
+        fprintf(stdout,"Unknown IP version %d\n", version);
+        return;
+    }
+
+    /* check header length */
+    if (ip_hlen < 20) {
+        fprintf(stdout,"Bad-ip-hlen %d \n", ip_hlen);
+        return;
+    }
+
+    /* see if we have as much packet as we should */
+    if(length < len) {
+        printf("Truncated IP - %d bytes missing\n", len - length);
+        return;
+    }
+
+    /* Check to see if we have the first fragment */
+    off = ntohs(ip->ip_off);
+    if ((off & IP_OFFMASK) == 0 ) /* aka no 1's in first 13 bits */
+        {
+#ifdef AMAR_DEBUG
+            /* print SOURCE DESTINATION hlen version len frag_offset */
+            cout << "\tIP: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+#endif //AMAR_DEBUG
+        } else {
+        //#ifdef AMAR_DEBUG
+            cout << "\tIP fragment has arrived: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+        //#endif //AMAR_DEBUG
+    }
+
+    // XXX
+    // IMPORTANT ASSUMPTION :: ignore ip reassembly for the time being !!!
+
+    /* determine protocol */
+    switch(ip->ip_p) {
+        case IPPROTO_TCP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: TCP" << endl;
+#endif //AMAR_DEBUG
+            break;
+
+        case IPPROTO_UDP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: UDP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_ICMP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: ICMP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_IP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: IP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        default:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: unknown" << endl;
+#endif //AMAR_DEBUG
+            return;
+    }
+
+
+    // handle_tcp
+    tcp = (struct sniff_tcp*)(ip_packet + ip_hlen);
+    size_tcp_header = TH_OFF(tcp)*4;
+    if (size_tcp_header < 20) {
+        fprintf(stdout, "\t*! Invalid TCP header length: %u bytes\n", size_tcp_header);
+    }
+    else {
+        payload = (u_char *)(ip_packet + ip_hlen + size_tcp_header);
+
+        /* compute tcp payload (segment) size */
+        size_payload = ntohs(ip->ip_len) - (ip_hlen + size_tcp_header);
+
+        /*
+         * Print payload data; it might be binary, so don't just
+         * treat it as a string.
+         */
+        if (size_payload > 0) {
+
+#ifdef AMAR_DEBUG_TIME
+            gettimeofday(g_p_start_time, NULL);
+#endif //AMAR_DEBUG_TIME
+
+            deal_delta_t = 0;
+            cid_iter_t = 0;
+            cid_iter_fit_t = 0;
+            g_store_time = 0;
+
+            numTcpPacketsCaptured++;
+            numBytesOfTcpPacketsCaptured += size_payload;
+
+            char *src_ip = strdup(inet_ntoa(ip->ip_src));
+            char *dst_ip = strdup(inet_ntoa(ip->ip_dst));
+
+#ifdef AMAR_DEBUG
+            //#if 1
+            cout << "----------" << endl;
+            cout << "\tTCP Src " << src_ip << ":" << ntohs(tcp->th_sport)
+                 << "; TCP Dst " << dst_ip << ":" << ntohs(tcp->th_dport);
+            cout << "\tPayload (" << size_payload << " bytes):" << endl;
+            print_payload(payload, size_payload);
+#endif //AMAR_DEBUG
+
+            tcp_seq seq_num = ntohl(tcp->th_seq);
+
+
+            /*
+            // XXX :: TESTING - BEGIN
+            //tcp_seq temp_seq0 = 3659991430;
+            tcp_seq temp_seq0 = 3659989982; // first flow
+            
+            if (seq_num == temp_seq0) {
+                cout << "dropping packet" << endl;
+
+                g_pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+                g_pFidStr = g_pFid->toString();
+
+                return;
+            }
+            // XXX :: TESTING - END
+            */
+
+            FlowId *pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+            string* pFidStr = pFid->toString();
+
+
+            free (src_ip);
+            free (dst_ip);
+
+
+            if (g_multi_chances == false) {
+                // insert payload into flow_list
+                insert(pFid, pFidStr, payload, size_payload, seq_num);
+            }
+            else {
+                // NEW - START
+#ifdef AMAR_DEBUG_1
+                cout << "@@@@@ ";
+                pFid->print();
+                cout << flow_chunk_map.size() << endl;
+#endif //AMAR_DEBUG_1
+
+
+                //  orig: map< string, std::list<string> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+                map< string, std::list<ChunkInfo> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+                         
+
+                if (fc_map_i == flow_chunk_map.end()) {
+                    // never seen this flow before (at least never seen a chunk of this flow)
+#ifdef AMAR_DEBUG_1
+                    cout << "never seen this flow before (at least never seen a chunk of this flow)" << endl;
+#endif //AMAR_DEBUG_1
+
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    // TODO :: for testing only - remove later and replace with line above
+                    p_cid_offset_pair = NULL;
+                    cout << "yo = " << seq_num << endl;
+
+                    tcp_seq temp_seq1 = 3659989982; // first flow
+                    tcp_seq temp_seq2 = 3667694287; // second flow
+
+#if 0
+                    if ( (seq_num == temp_seq1) || (seq_num == temp_seq2)) {
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+#endif //0
+                    if (seq_num == temp_seq2) {
+                        cout << "playing around with seq_num = " << seq_num << endl;
+                        seq_num = temp_seq1;
+                        
+                        // ignore delete for testing purposes
+                        pFid = g_pFid;
+                        pFidStr = g_pFidStr;
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+
+                    // XXX :: TESTING - END
+                    */
+
+
+                    // the packet has a chunk id - either at the starting or somewhere in the middle
+                    if (p_cid_offset_pair != NULL) {
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_with_cid_start_time, NULL);
+#endif //AMAR_DEBUG_TIME
+
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // insert payload into flow_list, size = offset
+                            insert(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        // yes! as this was a new flow, we have to add this flow to the flow_chunk_map
+
+						////start of new code///
+						// rather than just the cid, add seq no and length as well
+						int c_len = get_length_from_byte_stream((const char*) payload);
+						ChunkInfo *c_info = new ChunkInfo(*p_chunk_id, seq_num, c_len);
+		
+						std::list<ChunkInfo> cid_list;
+						cid_list.push_back(*c_info);
+						                   
+						flow_chunk_map[*pFidStr] = cid_list;
+						///////end of new code////
+
+                        /*
+                        // old code
+						std::list<string> cids;
+                        cids.push_back(*p_chunk_id);
+               			flow_chunk_map[*pFidStr] = cids;
+                        */
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            gettimeofday(g_p_deal_with_candidates_start_time, NULL);
+
+                            bool b_chunk_done2 = deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                            gettimeofday(g_p_deal_with_candidates_end_time, NULL);
+                            deal_delta_t = (g_p_deal_with_candidates_end_time->tv_sec - g_p_deal_with_candidates_start_time->tv_sec)*1000000 
+                            + g_p_deal_with_candidates_end_time->tv_usec - g_p_deal_with_candidates_start_time->tv_usec;
+
+
+                            /* cleanup */
+                            if (b_chunk_done || b_chunk_done2) {
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+
+                                /* cleanup */
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_with_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_with_cid_end_time->tv_sec - g_p_with_cid_start_time->tv_sec)*1000000 
+                            + g_p_with_cid_end_time->tv_usec - g_p_with_cid_start_time->tv_usec;
+                        cout << "[New Flow + pkt has chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+#endif //AMAR_DEBUG_TIME
+
+                    } else {
+                        // this packet does not have a chunk id and we have never seen a chunk on this flow,
+                        // go ahead and store it in the flow as a contiguous block
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_without_cid_start_time, NULL);
+#endif //AMAR_DEBUG_TIME
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. inserting into flow_list" << endl;
+#endif //AMAR_DEBUG_1
+                        insert(pFid, pFidStr, payload, size_payload, seq_num);
+
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_without_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_without_cid_end_time->tv_sec - g_p_without_cid_start_time->tv_sec)*1000000 
+                            + g_p_without_cid_end_time->tv_usec - g_p_without_cid_start_time->tv_usec;
+                        cout << "[New Flow + pkt does not have chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+#endif //AMAR_DEBUG_TIME
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                }
+                else {
+
+                    // ah! we have seen a chunk on this flow before
+#ifdef AMAR_DEBUG_1
+                    cout << "we have seen some chunk on this flow before." << endl;
+#endif //AMAR_DEBUG_1
+
+                    // so is the packet that just came in a part of a chunk that we have seen or is it a new one?
+                    // if it is a new one - 
+                    //    it either has the chunk id (if it is the first packet), 
+                    //    or it is an intermediate packet of a new chunk that we have not yet seen
+
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    tcp_seq temp_seq3 = 3659997222;
+                    if ( seq_num == temp_seq3 ) {
+                    cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                    p_cid_offset_pair = new pair<string*, int>(new string("aloha!"), 1004);
+                    }
+                    // XXX :: TESTING - END
+                    */
+
+
+                    if (p_cid_offset_pair != NULL) {
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_with_cid_start_time, NULL);
+#endif //AMAR_DEBUG_TIME
+
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " 
+			     << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // deal with the first part of the packet wich has no chunk id
+                            deal_with_pkt_without_chunkid(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        // PERF TODO :: ARG!!!! ouch! expensive ?!
+                        gettimeofday(g_p_cid_iteration_start_time, NULL);
+
+                        /*
+                        // OLD
+                        std::list<string>::iterator ci; 
+                        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+                            if (*ci == *p_chunk_id) break;
+                        }
+                        if (ci == fc_map_i->second.end()) {
+                            fc_map_i->second.push_back(*p_chunk_id);
+                        }
+                        */
+
+                        // NEW - BEGIN
+                        std::list<ChunkInfo>::iterator ci; 
+                        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+                            if (((*ci).chunk_id) == *p_chunk_id) break;
+                        }
+                        if (ci == fc_map_i->second.end()) {
+                            int c_len = get_length_from_byte_stream((const char*) payload);
+                            ChunkInfo *c_info = new ChunkInfo(*p_chunk_id, seq_num, c_len);
+		
+                            fc_map_i->second.push_back(*c_info);
+                        }
+                        // NEW - END
+
+                        gettimeofday(g_p_cid_iteration_end_time, NULL);
+                        cid_iter_t = (g_p_cid_iteration_end_time->tv_sec - g_p_cid_iteration_start_time->tv_sec)*1000000 
+                            + g_p_cid_iteration_end_time->tv_usec - g_p_cid_iteration_start_time->tv_usec;
+                        
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            gettimeofday(g_p_deal_with_candidates_start_time, NULL);
+
+                            bool b_chunk_done2 = deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                            gettimeofday(g_p_deal_with_candidates_end_time, NULL);
+                            deal_delta_t = (g_p_deal_with_candidates_end_time->tv_sec - g_p_deal_with_candidates_start_time->tv_sec)*1000000 
+                            + g_p_deal_with_candidates_end_time->tv_usec - g_p_deal_with_candidates_start_time->tv_usec;
+
+                            /* cleanup */
+                            if (b_chunk_done || b_chunk_done2) {
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+
+                                /* cleanup */
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_with_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_with_cid_end_time->tv_sec - g_p_with_cid_start_time->tv_sec)*1000000 
+                            + g_p_with_cid_end_time->tv_usec - g_p_with_cid_start_time->tv_usec;
+                        cout << "[Old Flow + pkt has chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+#endif //AMAR_DEBUG_TIME
+                    } else {
+                        // this packet does not have a chunk id 
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_without_cid_start_time, NULL);
+                        gettimeofday(g_p_cid_iteration_fit_start_time, NULL);
+#endif //AMAR_DEBUG_TIME
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. deal_with_pkt_without_chunkid()" << endl;
+#endif //AMAR_DEBUG_1
+                        deal_with_pkt_without_chunkid(pFid, pFidStr, payload, size_payload, seq_num);
+
+#ifdef AMAR_DEBUG_TIME
+                        gettimeofday(g_p_without_cid_end_time, NULL);
+                        gettimeofday(g_p_cid_iteration_fit_end_time, NULL);
+
+                        long inner_delta_t = (g_p_without_cid_end_time->tv_sec - g_p_without_cid_start_time->tv_sec)*1000000 
+                            + g_p_without_cid_end_time->tv_usec - g_p_without_cid_start_time->tv_usec;
+
+                        cid_iter_fit_t = (g_p_cid_iteration_fit_end_time->tv_sec - g_p_cid_iteration_fit_start_time->tv_sec)*1000000 
+                            + g_p_cid_iteration_fit_end_time->tv_usec - g_p_cid_iteration_fit_start_time->tv_usec;
+
+                        cout << "[Old Flow + pkt does not have chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+#endif //AMAR_DEBUG_TIME
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                    /*
+                      std::list<string>::iterator si;
+                      for (si = chunkIds.begin(); si != chunkIds.end(); ++si) {
+                      cout << "##### ";
+                      pFid->print();
+                      cout << "==> " << *si << endl;
+                      }
+                    */
+                }
+                // NEW - END
+            }
+
+            delete pFidStr;
+
+#ifdef AMAR_DEBUG_TIME
+            gettimeofday(g_p_end_time, NULL);
+            long delta_t = (g_p_end_time->tv_sec - g_p_start_time->tv_sec)*1000000 
+                + g_p_end_time->tv_usec - g_p_start_time->tv_usec;
+            cout << "TCP packet processing time (usec): Total = " << delta_t
+                 << "; deal_global = "  << deal_delta_t
+                 << "; cid_iter = "     << cid_iter_t
+                 << "; cid_iter_fit = " << cid_iter_fit_t
+                 << "; store_time = "   << g_store_time
+                 << endl;
+#endif //AMAR_DEBUG_TIME
+        }
+    }
+
+    //cout << "-------------------------" << endl;
+    return;
+}
+
+void SniffTcp::deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                             const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+    //map< string, std::list<string> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+    map< string, std::list<ChunkInfo> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr); // new
+    if (fc_map_i != flow_chunk_map.end()) {
+        //std::list<string>::iterator ci;
+        std::list<ChunkInfo>::iterator ci; // new
+        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+
+            /*
+            //OLD
+            map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*ci);
+
+            if (mapi != chunkId_reconstructedChunk_map.end()) {
+            tcp_seq starting_seq_number = mapi->second->flow_seq_map[(*pFidStr)];
+            int len = mapi->second->length;
+            */
+
+            tcp_seq starting_seq_number = (*ci).s_seq_num;
+            int len = (*ci).chunk_length;
+
+#ifdef AMAR_DEBUG_1
+            warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "checking " << string_to_dot_desc (((*ci).chunk_id)) 
+                 << "; starting_seq_number = " << starting_seq_number << "; len = " << len 
+                 << "; seq_num of incoming packet = " << seq_num << "\n";
+#endif // AMAR_DEBUG_1
+            // do something only if the packet lies within the chunk
+            if ( (seq_num > starting_seq_number) && (seq_num < (starting_seq_number + len) ) ) {
+#ifdef AMAR_DEBUG_1
+                warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet fits/overlaps in the chunk " 
+                     << string_to_dot_desc (((*ci).chunk_id)) << "\n";
+#endif // AMAR_DEBUG_1
+
+                map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find (((*ci).chunk_id)); // new
+
+                bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                if (b_chunk_done) {
+                    const char* p_data = mapi->second->get_data();
+                    if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                        cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                        cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                        warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                        send_chunk_to_sniffer_plugin (p_data);
+
+                        /* cleanup */
+                        // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                        // chunkId_reconstructedChunk_map.erase(mapi);
+                        // removing from flow_chunk_map is a little more complex in the current setting
+                    }
+                }
+                return;
+            } else {
+#ifdef AMAR_DEBUG_1
+                warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet does not fit/overlap the chunk "
+                     << string_to_dot_desc (*ci) << "\n";
+#endif // AMAR_DEBUG_1
+
+                /* cleanup */
+                // PERF TODO :: check if RC has aged enough and cleanup
+                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                // removing from flow_chunk_map is a little more complex in the current setting
+            }
+            /*
+            // OLD
+            }
+            */
+            
+        }
+
+        // if this packet did not fit into any of the exisiting chunks
+#ifdef AMAR_DEBUG_1
+        cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet did not fit/overlap any chunk. " 
+             << "Inserting into the global tcp flow state (flow_list)" << endl;
+#endif //AMAR_DEBUG_1
+        insert(pFid, pFidStr, payload, size_payload, seq_num);
+    }
+}
+
+bool SniffTcp::deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                             FlowId *pFid, string* pFidStr) 
+{
+    bool b_done = false;
+
+#ifdef AMAR_DEBUG_1
+    cout << "In SniffTcp::deal_with_candidates_for_chunk" << endl;
+#endif //AMAR_DEBUG_1
+    tcp_seq starting_seq_number = p_rc->flow_seq_map[(*pFidStr)];
+    int len = p_rc->length;
+
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0)
+        {
+            std::list<ContiguousBlock*>::iterator li;
+            for (li = p_lcb->begin(); li != p_lcb->end(); ) 
+            {
+                if ( ( *li !=  0 )  &&
+                     ( ((*li)->starting_seq_number > starting_seq_number) && 
+                       ((*li)->starting_seq_number < (starting_seq_number + len) ) )
+                     )
+                    {
+                        /* there is no chance of overlapping - because if it does 
+                           overlap then there would have been a chunk boundary
+                           and we would have already dealt with that case
+                        */
+                        bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, 
+                                                 (const u_char*) (*li)->p_s_contiguous_block->c_str(), 
+                                                 (*li)->p_s_contiguous_block->size(), 
+                                                 (*li)->starting_seq_number);
+
+                        if (b_chunk_done) {
+                            const char* p_data = p_rc->get_data();
+                            if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                cout << "SniffTcp::deal_with_candidates_for_chunk => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+
+                                warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                send_chunk_to_sniffer_plugin (p_data);
+                            }
+                            b_done = true;
+                        }
+
+                        // remove *li
+                        p_lcb->erase(li++);
+
+                        // TODO :: should we break out if b_done is true?
+                }
+                else {
+                    ++li;
+                }
+            }
+        }
+    }
+    return b_done;
+}
+
+bool SniffTcp::fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num)
+{
+
+    bool b_chunk_done = false;
+
+    map<string, tcp_seq>::iterator fsi = p_rc->flow_seq_map.find(*pFidStr);
+    if (fsi != p_rc->flow_seq_map.end()) {
+        tcp_seq starting_seq_num = fsi->second;
+        int chunk_len = p_rc->length;
+
+        int diff = ( (seq_num + size_payload) - (starting_seq_num + chunk_len) );
+
+        if (diff < 0) {
+            diff = 0;
+        }
+
+        if (diff  > 0 ) {
+            insert(pFid, pFidStr, payload + size_payload - diff, diff, seq_num + size_payload - diff);
+        }
+        
+        b_chunk_done = p_rc->fill_gaps_in_chunk(pFid, pFidStr, payload, size_payload - diff, seq_num, &numDuplicateBytes);
+    }
+
+    return b_chunk_done;
+}
+
+void SniffTcp::insert(FlowId *pFid, string* pFidStr, 
+                      const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+
+    // check if the fracking flow exists
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        // If it does, check if the current packet is a dup and if so discard.
+        // Else, check if contiguous
+        //    if so fuse
+        //    else append.
+#ifdef AMAR_DEBUG
+        cout << "Existing flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0) {
+            std::list<ContiguousBlock*>::iterator li;
+            bool bDone = false;
+
+            // TODO :: maybe better to start from the end of the list and move back
+            for (li = p_lcb->begin(); li != p_lcb->end(); ++li) {
+                if ( *li !=  0 ) {
+
+                    /*
+                      if ( ((seq_num + size_payload) == (*li)->next_expected_seq_number) && (seq_num == (*li)->starting_seq_number) ) {
+                      // duplicate - hence ignore
+                      bDone = true;
+                      break;
+                      }
+
+                      // TODO ::
+                      // there are also cases where
+                      // a) start boundary is the same and the end boundary is different
+                      // b) end bondary is the same and the start boundary is different
+                      // ignoring these cases for the time being
+                      */
+
+                    if ( seq_num < (*li)->next_expected_seq_number ) {
+                        if ( (seq_num + size_payload) == (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "pre-contiguous! prepending ..." << endl;
+#endif //AMAR_DEBUG
+                            (*li)->prepend((const char*)payload, size_payload, seq_num);
+                        }
+                        else if ( (seq_num + size_payload) < (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "not pre-contiguous. inserting new cb ..." << endl;
+#endif //AMAR_DEBUG
+                            ContiguousBlock* p_cb = new ContiguousBlock();
+                            p_cb->append((const char*)payload, size_payload, seq_num);
+                            p_lcb->insert(li, p_cb);
+                        }
+                        bDone = true;
+                        break;
+                    }
+                    else if (seq_num == (*li)->next_expected_seq_number) {
+                        // new contiguous packet
+#ifdef AMAR_DEBUG
+                        cout << "contiguous. appending ..." << endl;
+#endif //AMAR_DEBUG
+                        (*li)->append((const char*)payload, size_payload, seq_num + size_payload);
+
+                        std::list<ContiguousBlock*>::iterator li2(li);
+                        li2++;
+                        if (li2 != p_lcb->end()) {
+                            if ( (*li)->next_expected_seq_number == (*li2)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                                cout << "merging ..." << endl;
+#endif //AMAR_DEBUG
+                                // time to merge the two
+                                (*li)->append( ((*li2)->p_s_contiguous_block), (*li2)->next_expected_seq_number );
+                                p_lcb->erase(li2);
+                            }
+                        }
+                        bDone = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!bDone) {
+#ifdef AMAR_DEBUG
+                cout << "packet from the future, inserting at the end of the list." << endl;
+#endif //AMAR_DEBUG
+                ContiguousBlock* p_cb = new ContiguousBlock();
+                p_cb->append((const char*)payload, size_payload, seq_num);
+                p_lcb->push_back(p_cb);
+            }
+        }
+#ifdef AMAR_DEBUG
+        cout << "# of cbs = " << p_lcb->size() << endl;
+#endif //AMAR_DEBUG
+
+        //delete pFid;
+    }
+    else {
+#ifdef AMAR_DEBUG
+        cout << "New flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+
+        ContiguousBlock* p_cb = new ContiguousBlock();
+        p_cb->append((const char*)payload, size_payload, seq_num);
+
+        std::list<ContiguousBlock*>* p_lcb = new std::list<ContiguousBlock*>();
+        p_lcb->push_back(p_cb);
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p_pair = new pair< FlowId*, std::list<ContiguousBlock*>* >(pFid, p_lcb);
+        p_flow_list->push_back(p_pair);
+    }
+}
+
+int SniffTcp::get_flow_offset(FlowId* pFid)
+{
+    int offset = -1;
+    if (pFid != 0) {
+        for( unsigned int i = 0; i < (*p_flow_list).size(); i++ ) {
+            if ( *((*p_flow_list)[i]->first) ==  *pFid ) {
+                offset = i;
+                break;
+            }
+        }
+    }
+    return offset;
+}
+
+void SniffTcp::grep_flows_for_chunks()
+{
+    //cout << "In grep_flows_for_chunks" << endl;
+    //cout << "#####" << endl;
+    //cout << "#of flows = " << p_flow_list->size() << endl;
+    for (unsigned int numFlows = 0; numFlows < p_flow_list->size(); numFlows++) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = (*p_flow_list)[numFlows];
+        FlowId* pFid = p->first;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+        //cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ) { // remember to increment i inside!
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            
+            while((*i)->bModified && ((*i)->starting_seq_number < (*i)->next_expected_seq_number) ) {
+                cout << "grepping flow => ";
+                pFid->print();
+                grep_contiguous_block_for_chunks(*i,i,stream_blocks); //enchance this call by passing list and iterator
+            }
+              
+            if ((*i)->starting_seq_number == (*i)->next_expected_seq_number) {
+                // we are done with this block!
+                stream_blocks->erase(i++);
+            }
+            else {
+                ++i;
+            }
+        }
+        //cout << "*****" << endl;
+    }
+    //cout << "#####" << endl;
+}
+
+int SniffTcp::get_length_from_byte_stream(const char *b)
+{
+    int i = 0;
+    //printf("converter# = %d, %x, %x %x %x\n", i, b[0], b[1],b[2],b[3]);
+    i |= b[0] & 0x7F;
+    //printf("# = %d \n", i);
+    i = (i << 8);
+    //printf("# = %d \n", i);
+    i |= b[1] & 0xFF;
+    i = (i << 8);
+    i |= b[2] & 0xFF;
+    i = (i << 8);
+    i |= b[3] & 0xFF;
+
+    //cout<<"return val of converter is"<<i<<endl;
+    return i;
+}
+
+char *seen_chunks[4] = {0, 0, 0, 0};
+
+void
+check_chunk_against_prev (char *buf, int len)
+{
+    static int num_seen = 0;
+    int i;
+
+    for (i = 0; i < num_seen; i++) {
+        if (seen_chunks[i]) {
+            if (memcmp (seen_chunks[i], buf, len) == 0) {
+                warn("chunk of len %d matched %d th chunk \n",len,i);
+                // warn << "will now print chunk id of prev seen chunk \n";
+                //     print_chunk_id (seen_chunks[i], len);
+                // warn << "will now print chunk id of  new chunk \n";
+                // print_chunk_id (buf, len);
+                return;
+            }
+        }
+    }
+    if (num_seen < 4) {
+        seen_chunks[num_seen] = New char[len];		
+        memcpy (seen_chunks[num_seen], buf, len);	
+        warn ("Entering chunk as %d th entry \n",num_seen);
+        num_seen++;
+    }
+}
+
+// Given a pointer to an rpc header in a byte stream, if the byte stream
+// is a DOT chunk response return true and populate (passed by ref) arg chunk_res.
+// If it is not a a chunk response return false.
+// A Dot chunk response is currently expected to have the following features
+// 1. RPC payload >= MIN_PAYLOAD_LENGTH
+// 2. Successful bytes2xdr() on dot chunk response portion of byte stream
+// 3. Chunk size >= MIN_CHUNK_SIZE
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res)
+{
+#define RPC_HEADER_LEN 28
+  assert (chunk_res != NULL);
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+    return false;
+  }
+
+  const u_char *tmp = rpc_header + RPC_HEADER_LEN;
+  rpc_bytes <> value;
+  value.set((char *)tmp, payload_length - RPC_HEADER_LEN);
+#ifdef AMAR_DEBUG_PAYLOAD
+  print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+  if (!bytes2xdr(*chunk_res, value)) {
+      warn << "problem in bytes2xdr\n";
+    return false;
+  }
+  if (chunk_res->resok->data.size () < MIN_CHUNK_SIZE) {
+    return false;
+  }
+
+  return true;
+}
+
+
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res) 
+{
+    assert (chunk_res != NULL);
+
+    int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+    if (payload_length < MIN_PAYLOAD_LENGTH) {
+        return false;
+    }
+    const u_char *tmp = rpc_header + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+    chunk_res->chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+    if (chunk_res->chunk_id_len != LEN_OF_CHUNK_ID) {
+        return false;
+    }
+
+    chunk_res->chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+    chunk_res->chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+    if (chunk_res->chunk_data_len < MIN_CHUNK_SIZE) {
+        return false;
+    }
+    chunk_res->chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+#ifdef AMAR_DEBUG_PAYLOAD
+    print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+
+    return true;
+}
+
+void SniffTcp::send_chunk_to_sniffer_plugin (const char *rpc_buffer)
+{
+
+#ifdef AMAR_DEBUG_TIME
+    gettimeofday(g_p_store_start_t, NULL);
+#endif //AMAR_DEBUG_TIME
+
+#ifdef AMAR_DEBUG_1
+    cout << "SniffTcp::send_chunk_to_sniffer_plugin => " << "sending to sniffer plugin ..." << endl;
+#endif //AMAR_DEBUG_1
+#if 1
+    dot_chunk_res_t chunk_res;
+    if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+      return;
+    }
+    sniffer_tcp_put_chunk_arg arg;
+    ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+    arg.end = true;
+    arg.data.set ((char *)chunk_res.chunk_data_base, chunk_res.chunk_data_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+    return;
+  }
+  sniffer_tcp_put_chunk_arg arg;
+  ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+  arg.end = true;
+  arg.data.set ((char *)chunk_res.resok->data.base(), chunk_res.resok->data.size());
+#endif 
+  numChunksSniffed++;
+  numBytesOfChunksSniffed += (arg.data.size());
+  sniffer_c->call (SNIFFER_TCP_PROC_PUT_CHUNK, &arg, res,
+		   wrap (this, &SniffTcp::put_chunk_cb, res));
+  if (g_run_options.mode == OFFLINE || g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    usleep (1000);
+  }
+
+#ifdef AMAR_DEBUG_TIME
+  gettimeofday(g_p_store_end_t, NULL);
+  
+  g_store_time = (g_p_store_end_t->tv_sec - g_p_store_start_t->tv_sec)*1000000 
+      + g_p_store_end_t->tv_usec - g_p_store_start_t->tv_usec;
+#endif //AMAR_DEBUG_TIME
+}
+
+void SniffTcp::put_chunk_cb (ref<sniffer_tcp_put_chunk_res> res, clnt_stat err) 
+{
+    if (err) {
+        warn << "Could not send chunk to sniffer plugin \n";
+    }
+    if (!res->ok) {
+        warn << " put chunk to sniffer plugin returned " << *res->errmsg << "\n";
+    }
+    warn << "put chunk to sniffer plugin successful \n" ;
+}
+
+void SniffTcp::grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator it, std::list<ContiguousBlock*>* stream_block)
+{
+    char rpc_header = 0x80;
+    //unsigned int data_size; 
+    string chunk;
+    string tempString;
+
+    //cout << "in grep function to check block starting with seq no = "<< pcb->starting_seq_number << " and size= " << pcb->p_s_contiguous_block->size() << endl;
+    const char *cb_data = pcb->p_s_contiguous_block->c_str();
+    for (unsigned int i = 0; i < pcb->p_s_contiguous_block->size(); i++) {
+        if ( *(cb_data + i) == rpc_header) {
+            //cout << "!!! Found something that looks like the RPC HEADER at " << i << endl;
+
+            if ( (i + 3) < pcb->p_s_contiguous_block->size()) {
+                int payload_length = get_length_from_byte_stream((cb_data + i));
+                
+                //unsigned int payload_length1=*(cb_data+i);
+		
+                unsigned int j = i + 8;
+
+                if ( (j + mask_size_in_bytes) < pcb->p_s_contiguous_block->size() ) {
+
+                    int cmp_result = memcmp((cb_data + j), mask, mask_size_in_bytes);
+                    if (cmp_result == 0) {
+                        //cout << "!!! Found something that looks like a DOT RESPONSE at " << i << endl;
+
+                        unsigned int start = i;
+                        i += (payload_length + 4);
+
+                        //cout << "payload length of RPC =" << payload_length << endl;
+
+
+                        if(i <= pcb->p_s_contiguous_block->size()) {  //enough data in the block
+            		
+                            if (start == 0) {
+                                // chunk at the begining of the cb
+
+                                // Amar :: debug start
+                                //cout << "chunk at the start" << endl;
+                                //cout << "size of contiguous block before trimming = " << pcb->p_s_contiguous_block->size() << endl;
+                                // print_payload((const u_char*) (cb_data + start), i);
+                                // Amar :: debug end
+
+				send_chunk_to_sniffer_plugin (cb_data + start);
+				pcb->starting_seq_number += i;
+                                pcb->p_s_contiguous_block->erase(start, i); // FOR TESTING :: use i-1 for middle chunk test
+
+                                // Amar :: debug start
+                                //cout << "size of contiguous block after trimming = "<< pcb->p_s_contiguous_block->size() << endl;
+                                // Amar :: debug start
+                                //it--;
+
+                                return;
+                            }
+                            else if ( i == (pcb->p_s_contiguous_block->size()+1) ) //when chunk starts from the middle and goes till the end
+                                {
+                                    send_chunk_to_sniffer_plugin (cb_data + start);
+                                    //cout << "chunk is at the end. resizing contiguous block." << endl;
+                                    pcb->next_expected_seq_number = start;    
+                                    //cout << "old size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->p_s_contiguous_block->resize(pcb->p_s_contiguous_block->size() - payload_length - 4);
+                                    //cout << "new size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->bModified = false;
+                                    return;
+                                }
+                            else {  //chunk is in the middle of the block like A-chunk-B
+
+                                send_chunk_to_sniffer_plugin (cb_data + start);
+                                //cout << "chunk in the middle" << endl;
+                                ContiguousBlock* p_cb = new ContiguousBlock(); //creating new block to store A
+                                char * tempPointer = (char *)pcb->p_s_contiguous_block;
+                                p_cb->append(tempPointer, start, pcb->starting_seq_number); //filling the new block with A
+                                p_cb->bModified=false;                                    //marking that it has been checked
+                                stream_block->insert(it, p_cb);  //inserting the new block in the new list
+
+                                pcb->starting_seq_number += i;         //changing the initial sequence of the original block
+                                pcb->p_s_contiguous_block->erase(0, i); //erasing the part upto the start of B
+            			       
+                                it--;
+                                return;
+                            }
+                        }
+                        else {
+                            //cout << "waiting for more data to come!" << endl;
+                            pcb->bModified = false;
+                        }
+                      
+                        i--; // i will be incremented in the loop, hence compensating
+                    }
+                }
+            }
+        }
+    }
+    pcb->bModified = false; //indicating that this round has been checked
+}
+
+void 
+run_pcap_live ()
+{
+    //char *dev = "lo";
+  char *dev = g_run_options.interface;
+    char *net = g_run_options.ip_to_ignore; /* dot notation of the network address */
+    char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+    pcap_t* h_pcap;
+    struct bpf_program fp;      /* hold compiled program     */
+    bpf_u_int32 maskp;          /* subnet mask               */
+    bpf_u_int32 netp;           /* ip                        */
+    struct in_addr tmp_addr;
+
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    int ret = pcap_lookupnet(dev, &netp, &maskp, errbuf);
+    if(ret == -1)
+    {
+        printf("%s\n",errbuf);
+        exit(1);
+    }
+
+    /* get the network address in a human readable form */
+    tmp_addr.s_addr = netp;
+    //net = strdup(inet_ntoa(tmp_addr));
+
+    //if(net == NULL)
+    //{
+    //    perror("inet_ntoa");
+    //    exit(1);
+    //}
+    //printf("NET: %s\n", net);
+
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    char *default_filter = "tcp and not port 22 and not port 6010"; 
+    char *host_filter = " and not dst host "; 
+    int filter_len = strlen(default_filter) + strlen(host_filter) + strlen(net) + 1;
+    char* final_filter = (char *)malloc(sizeof(char *) * filter_len);
+    memset(final_filter, 0, filter_len);
+    sprintf(final_filter, "%s%s%s", default_filter, host_filter, net);
+    cout << "Final Filter: " << final_filter << endl;
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, final_filter, 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+        //pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_ethernet, (u_char *)pSt);
+        pSt->numPacketsCaptured += pcap_dispatch(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    
+#ifdef AMAR_DEBUG_TIME
+        time_t start1, end1;
+        time (&start1);
+#endif //AMAR_DEBUG_TIME
+
+        /*      
+            We need grep_flows_for_chunk as we might get packets where
+            the RPC header and the chunkid are split across
+            packets. These will be just thrown into the flow_list and
+            it is only grep_flows_for_chunk that can get such chunks
+            out.
+
+            Unfortunately in the above example we can extract a chunk
+            out of the flow_list only if we have the entire chunk for
+            a given flow. So this rules out cases where the flow_list
+            might have 2 flows where - Flow1 has the first half of the
+            chunk, and Flow2 has the first packet with the chunk-id +
+            the second hald of the chunk. Ideally we should be able to
+            extract this chunk out of the flow list but we don't  do
+            this right now.
+
+            TODO :: Fix the above case! :-)
+        */
+        pSt->grep_flows_for_chunks();
+
+#ifdef AMAR_DEBUG_TIME
+        time (&end1);
+        double dif1 = difftime (end1, start1);
+        cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+#endif //AMAR_DEBUG_TIME
+
+        cout << "-----" << endl;
+        cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+        cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+        cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+        cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+	cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+        cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+        cout << "~~~~~" << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+    free(net);
+}
+
+void 
+run_pcap_live_wifi ()
+{
+  //char *dev = "lo";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+  
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+      pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_wifi, (u_char *)pSt);
+      
+      time_t start1, end1;
+      time (&start1);
+      
+      pSt->grep_flows_for_chunks();
+      
+      time (&end1);
+      double dif1 = difftime (end1, start1);
+      cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+}
+
+void
+run_pcap_offline ()
+{
+    //char *dev = "eth0";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;  
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    //h_pcap = pcap_open_offline("./dot_test_2.dump", errbuf);
+    //h_pcap = pcap_open_offline("./dotdump", errbuf);
+    //h_pcap = pcap_open_offline("./wifidump", errbuf);
+    h_pcap = pcap_open_offline("./dump2", errbuf);
+
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    /*
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+    */
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp and not port 22 and not port 6010", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+  
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+  
+    pcap_loop(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    //pcap_loop(h_pcap, -1, my_callback_wifi, (u_char *)pSt);
+
+    time_t start1, end1;
+    time (&start1);
+
+    cout << "!!!!! Done with pcap_loop - in grep_flows_for_chunks !!!!!" << endl;
+    pSt->grep_flows_for_chunks();
+      
+    time (&end1);
+    double dif1 = difftime (end1, start1);
+    cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+        cout << "-----" << endl;
+        cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+        cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+        cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+        cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+	cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+        cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+        cout << "~~~~~" << endl;
+    delete pSt;
+}
+
+void print_usage () 
+{
+  cout << "Usage: sudo ./binary_name" << endl
+       << "              numpackets"  << endl
+       << "              interface"   << endl
+       << "              unix_socket_fqn" << endl 
+       << "              mode" << endl
+       << "              self_interface_ip_to_ignore" << endl
+       << "              multi_chances [0 | 1    default = 1]" << endl;
+  //cout << "mode => 0 = offline | 1 = online | 2 = offline+online | 3 = online_wifi | 4 = offline+online_wifi" << endl;
+  cout << "mode => 0 = offline | 1 = online | 2 = offline+online" << endl;
+  cout << "e.g.: sudo ./sniffTcp 1000 lo /tmp/gtcd_sniff.sock 1 128.2.223.103 1" << endl;
+}
+
+bool parse_command_line_args (int argc, char **argv)
+{
+  if (argc < 6) {
+    return false;
+  }
+  g_run_options.num_pkts = atoi(argv[1]);
+  g_run_options.interface = argv[2];
+  g_run_options.socket = argv[3];
+  switch (atoi(argv[4])) {
+  case 0:
+    g_run_options.mode = OFFLINE;
+    break;
+  case 1:
+    g_run_options.mode = ONLINE;
+    break;
+  case 2:
+    g_run_options.mode = OFFLINE_ONLINE;
+    break;
+  case 3:
+    g_run_options.mode = ONLINE_WIFI;
+    break;
+  case 4:
+    g_run_options.mode = OFFLINE_ONLINE_WIFI;
+    break;
+  default:
+    return false;
+  }
+  g_run_options.ip_to_ignore = argv[5];
+  if (argc == 7) {
+    g_run_options.multi_chance = atoi (argv[6]);
+  }
+  return true;
+}
+
+int main(int argc, char **argv)
+{
+    //printf("Sizeof unsinged int = %d\n", sizeof(u_int));
+  
+    /* grab a device to peek into ... */
+    /*
+      dev = pcap_lookupdev(errbuf);
+      if(dev == NULL)
+      {
+      printf("%s\n", errbuf);
+      exit(1);
+      }
+    */
+  if (!parse_command_line_args (argc, argv)) {
+    print_usage ();
+    return 0;
+  }
+  if (g_run_options.multi_chance == 0) {
+    g_multi_chances = false;
+  }
+  if (g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    // run_pcap_offline();
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == ONLINE_WIFI) {
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == OFFLINE_ONLINE) {
+    run_pcap_offline ();
+    run_pcap_live (); 
+  }
+  else if (g_run_options.mode == ONLINE) {
+    run_pcap_live (); 
+  }
+  else {
+    run_pcap_offline ();
+  }
+  
+  cout << endl << "Finished" << endl;
+  return 0;
+}
+
+
+extern guint32 crc32_802(const guint8 *buf, guint len);
+
+/* Translate Ethernet address, as seen in struct ether_header, to type MAC. */
+static inline MAC ether2MAC(const uint8_t * ether)
+{
+    return MAC(ether);
+}
+
+/* Extract header length. */
+u_int8_t SniffTcp::extract_header_length(u_int16_t fc)
+{
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            return MGMT_HDRLEN;
+        case T_CTRL:
+            switch (FC_SUBTYPE(fc)) {
+                case CTRL_PS_POLL:
+                    return CTRL_PS_POLL_HDRLEN;
+                case CTRL_RTS:
+                    return CTRL_RTS_HDRLEN;
+                case CTRL_CTS:
+                    return CTRL_CTS_HDRLEN;
+                case CTRL_ACK:
+                    return CTRL_ACK_HDRLEN;
+                case CTRL_CF_END:
+                    return CTRL_END_HDRLEN;
+                case CTRL_END_ACK:
+                    return CTRL_END_ACK_HDRLEN;
+                default:
+                    return 0;
+            }
+        case T_DATA:
+            return (FC_TO_DS(fc) && FC_FROM_DS(fc)) ? 30 : 24;
+        default:
+            return 0;
+    }
+}
+
+void SniffTcp::handle_80211(const u_char* packet, u_int len) 
+{
+    if (len < 2) {
+        return;
+    }
+
+    u_int16_t fc = EXTRACT_LE_16BITS(packet);       //frame control
+    u_int hdrlen = extract_header_length(fc);
+
+    if (len < IEEE802_11_FC_LEN || len < hdrlen) {
+	//cbs->Handle80211Unknown(t, fc, packet, len);
+        //cout << "boo" << endl;
+        return;
+    }
+
+    bool fcs_ok = false;
+    if (Check80211FCS()) {
+	if (len < hdrlen + 4) {
+	    //cerr << "too short to have fcs!" << endl;
+	} else {
+	    // assume fcs is last 4 bytes (?)
+	    u_int32_t fcs_sent = EXTRACT_32BITS(packet+len-4);
+	    u_int32_t fcs = crc32_802(packet, len-4);
+
+	    /*
+	    if (fcs != fcs_sent) {
+		cerr << "bad fcs: ";
+		fprintf (stderr, "%08x != %08x\n", fcs_sent, fcs); 
+	    }
+	    */
+	    
+	    fcs_ok = (fcs == fcs_sent);
+	}
+    }
+
+    // fill in current_frame: type, sn
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            //cout << "mgmt frame" << endl;
+            break;
+        case T_DATA:
+            // TODO :: do the magic!
+            cout << "data frame" << endl;
+            handle_data_frame(packet, len, fc);
+            break;
+        case T_CTRL:
+            //cout << "ctrl frame" << endl;
+            break;
+        default:
+            break;
+    }
+}
+
+void SniffTcp::handle_data_frame(const u_char *ptr, int len, u_int16_t fc)
+{
+    u_int16_t seq_ctl;
+    u_int16_t seq;
+    u_int8_t  frag;
+
+    u_int16_t du = EXTRACT_LE_16BITS(ptr+2);        //duration
+
+    seq_ctl = pletohs(ptr + 22);
+    seq = COOK_SEQUENCE_NUMBER(seq_ctl);
+    frag = COOK_FRAGMENT_NUMBER(seq_ctl);
+
+    bool body = true;
+    int hdrlen = 0;
+
+    if (!FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* ad hoc IBSS */
+        cout << "ad hoc IBSS" << endl;
+	data_hdr_ibss_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	// AMAR:: cbs->Handle80211(t, fc, MAC::null, MAC::null, MAC::null, MAC::null, fcs_ok);
+	// XXX fcs
+	// AMAR:: cbs->Handle80211DataIBSS(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+	body = false;
+    } else if (!FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* frame from AP to STA */
+        cout << "frame from AP to STA" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 16);
+	hdr.da = ether2MAC(ptr + 4);
+	hdr.bssid = ether2MAC(ptr + 10);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataFromAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* frame from STA to AP */
+        cout << "frame from STA to AP" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 10);
+	hdr.da = ether2MAC(ptr + 16);
+	hdr.bssid = ether2MAC(ptr + 4);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataToAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* WDS */
+        cout << "WDS" << endl;
+	data_hdr_wds_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.ra = ether2MAC(ptr+4);
+	hdr.ta = ether2MAC(ptr+10);
+	hdr.da = ether2MAC(ptr+16);
+	hdr.da = ether2MAC(ptr+24);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, fcs_ok);
+	// AMAR:: cbs->Handle80211DataWDS(t, &hdr, ptr+DATA_WDS_HDRLEN, len-DATA_WDS_HDRLEN);
+	hdrlen = DATA_WDS_HDRLEN;
+    }
+
+    if (body) {
+	if (FC_WEP(fc)) {
+	    //handle_wep(t, cbs, ptr+hdrlen, len-hdrlen-4 /* FCS */);
+            cout << "who need wep?" << endl;
+	} else {
+            cout << "lls finally!" << endl;
+	    handle_llc(ptr+hdrlen, len-hdrlen-4 /* FCS */);
+	}
+    }
+}
+
+void SniffTcp::handle_llc(const u_char *ptr, int len)
+{
+    if (len < 7) {
+	// truncated header!
+        return;
+    }
+
+    // Jeff: XXX This assumes ethernet->80211 llc encapsulation and is
+    // NOT correct for all forms of LLC encapsulation. See print-llc.c
+    // in tcpdump for a more complete parsing of this header.
+
+    llc_hdr_t hdr;
+    hdr.dsap = EXTRACT_LE_8BITS(ptr);
+    hdr.ssap = EXTRACT_LE_8BITS(ptr + 1);
+    hdr.control = EXTRACT_LE_8BITS(ptr + 2);
+    hdr.oui = EXTRACT_24BITS(ptr + 3);
+    hdr.type = EXTRACT_16BITS(ptr + 6);
+
+    if (hdr.oui != OUI_ENCAP_ETHER && hdr.oui != OUI_CISCO_90) {
+        cout << "Not encapsulated Ethernet and not Cisco protocols." << endl;
+        return;
+    }
+
+    ptr += 8;
+    len -= 8;
+
+    //cbs->HandleLLC(t, &hdr, ptr, len);
+
+    switch (hdr.type) {
+        case ETHERTYPE_IP:
+            // TODO :: call something similar to
+            cout << "DATA!" << endl;
+            // handle_ip(len, ptr);
+            break;
+        default:
+            break;
+    }
+}
+
+const u_char *
+SniffTcp::rpc_header_in_stream (const u_char *payload, int len) 
+{
+  for (int i = 0; i < len; i++) {
+    if (payload[i] == RPC_HEADER) {
+      if (memcmp((payload + i + 8), mask, mask_size_in_bytes) == 0)
+	return (payload + i);
+    }
+  }
+  return NULL;
+}
+
+ void print_chunk_id (string *s) 
+{
+  dot_desc id;
+  id.set((char *) s->data(), s->length());
+  warn << "Chunk id = " << id << " \n";
+}
+
+dot_desc string_to_dot_desc (string s)
+{
+  dot_desc id;
+  id.set((char *) s.data(), s.length());
+  return id;
+}
+
+pair<string*, int>* SniffTcp::getChunkId(const u_char *payload, int len)
+{
+  // should return NULL if chunkId not found in the payload
+  
+  //return new pair<string*, int>(new string("hola!"), 0);
+  const u_char *rpc_buffer = rpc_header_in_stream (payload, len);
+  if (rpc_buffer == NULL) {
+    return NULL;
+  }
+  string *s = new string();
+  int rpc_offset = rpc_buffer - payload;
+  pair<string *, int> *p;
+
+  /*
+#if 1
+  dot_chunk_res_t chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return false;
+  }
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return NULL;
+  }
+  warn << "getChunkId () " << chunk_res.resok->chunk_id << " in stream \n";
+  s->append (chunk_res.resok->chunk_id.base(), chunk_res.resok->chunk_id.size());
+#endif 
+  */
+
+
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_buffer);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+      return false;
+  }
+  const u_char *tmp = rpc_buffer + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+
+  dot_chunk_res_t chunk_res;
+  chunk_res.chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+  if (chunk_res.chunk_id_len != LEN_OF_CHUNK_ID) {
+      return NULL;
+  }
+
+  chunk_res.chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+  chunk_res.chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+  if (chunk_res.chunk_data_len < MIN_CHUNK_SIZE) {
+      return NULL;
+  }
+  chunk_res.chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+  p = new pair<string *, int>(s, rpc_offset);  
+#ifdef AMAR_DEBUG_1
+  warn << "getChunkId:" <<  "will return pair (" << string_to_dot_desc (*(p->first)) << "," << p->second << ")\n";  
+#endif // AMAR_DEBUG_1
+  return p;
+}
+
+/*
+int SniffTcp::getChunkLength(const u_char *payload, int len) {
+    return get_length_from_byte_stream(payload);
+    //return 16384; // 16K
+}
+*/
diff -Naur src_dot_original/sniffer/SniffTcp.h src/sniffer/SniffTcp.h
--- src_dot_original/sniffer/SniffTcp.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/SniffTcp.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,318 @@
+#ifndef _SNIFF_TCP
+#define _SNIFF_TCP 1
+
+
+#include "async.h"
+#include "amisc.h"
+#include "arpc.h"
+#include "xdrmisc.h"
+
+#include "gtc.h"
+#include "snifferPlugin_tcp_prot.h"
+#include "xferPlugin_gtc_prot.h"
+
+#include "gtc_prot.h"
+#include "chunkerPlugin.h"
+
+#include "flow_id.h"
+#include "contiguous_block.h"
+#include "reconstructed_chunk.h"
+
+#include "extract.h"
+#include "types.h"
+#include "util.h"
+#include "ieee802_11.h"
+#include "llc.h"
+#include "oui.h"
+
+#include <map>
+#include <vector>
+#include <list>
+#include <string>
+#include <pcap.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <net/ethernet.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h> 
+#include <netinet/ether.h> 
+#include <netinet/tcp.h> 
+//#include <time.h>
+
+//using namespace std;
+
+/* tcpdump header (ether.h) defines ETHER_HDRLEN) */
+#ifndef ETHER_HDRLEN
+#define ETHER_HDRLEN 14
+#endif
+
+#ifndef CAPTURE_BUF_SIZE
+#define CAPTURE_BUF_SIZE 32768
+#endif
+
+//#define MIN_CHUNK_SIZE 0x1000 // 4 KB
+#define MIN_CHUNK_SIZE 0x400 // 1 KB
+#define MIN_PAYLOAD_LENGTH (MIN_CHUNK_SIZE + RPC_HEADER_LEN - 4)
+
+//#define AMAR_DEBUG 1
+//#define AMAR_DEBUG_PAYLOAD 1
+//#define AMAR_DEBUG_1 1
+//#define AMAR_DEBUG_TIME 1
+
+/*
+          IP HEADER
+
+           0                   1                   2                   3   
+           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |Version|  IHL  |Type of Service|          Total Length         |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |         Identification        |Flags|      Fragment Offset    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |  Time to Live |    Protocol   |         Header Checksum       |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                       Source Address                          |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Destination Address                        |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Options                    |    Padding    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        
+ * Structure of an ip header, devoid of options.
+ * Stolen from tcpdump source
+ */
+struct sniff_ip {
+	u_int8_t	ip_vhl;		/* header length, version */
+#define IP_V(ip)	(((ip)->ip_vhl & 0xf0) >> 4)
+#define IP_HL(ip)	((ip)->ip_vhl & 0x0f)
+	u_int8_t	ip_tos;		/* type of service */
+	u_int16_t	ip_len;		/* total length */
+	u_int16_t	ip_id;		/* identification */
+	u_int16_t	ip_off;		/* fragment offset field */
+#define	IP_DF 0x4000			/* dont fragment flag */
+#define	IP_MF 0x2000			/* more fragments flag */
+#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
+	u_int8_t	ip_ttl;		/* time to live */
+	u_int8_t	ip_p;		/* protocol */
+	u_int16_t	ip_sum;		/* checksum */
+	struct	in_addr ip_src,ip_dst;	/* source and dest address */
+};
+
+
+
+/* 
+                            TCP Header Format
+
+    0                   1                   2                   3   
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |          Source Port          |       Destination Port        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                        Sequence Number                        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Acknowledgment Number                      |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |  Data |           |U|A|P|R|S|F|                               |
+   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
+   |       |           |G|K|H|T|N|N|                               |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |           Checksum            |         Urgent Pointer        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Options                    |    Padding    |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                             data                              |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+*/
+
+//typedef u_int tcp_seq;
+
+struct sniff_tcp {
+    u_short th_sport;	/* source port */
+    u_short th_dport;	/* destination port */
+    tcp_seq th_seq;	/* sequence number */
+    tcp_seq th_ack;	/* acknowledgement number */
+    u_char th_offx2;	/* data offset, rsvd */
+#define TH_OFF(th)	(((th)->th_offx2 & 0xf0) >> 4)
+    u_char th_flags;
+#define TH_FIN 0x01
+#define TH_SYN 0x02
+#define TH_RST 0x04
+#define TH_PUSH 0x08
+#define TH_ACK 0x10
+#define TH_URG 0x20
+#define TH_ECE 0x40
+#define TH_CWR 0x80
+#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
+    u_short th_win;	/* window */
+    u_short th_sum;	/* checksum */
+    u_short th_urp;	/* urgent pointer */
+};
+
+/* from ethereal packet-prism.c */
+#define pletohs(p)  ((u_int16_t)					\
+		     ((u_int16_t)*((const u_int8_t *)(p)+1)<<8|		\
+		      (u_int16_t)*((const u_int8_t *)(p)+0)<<0))
+#define pntohl(p)   ((u_int32_t)*((const u_int8_t *)(p)+0)<<24|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+1)<<16|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+2)<<8|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+3)<<0)
+#define COOK_FRAGMENT_NUMBER(x) ((x) & 0x000F)
+#define COOK_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)
+/* end ethereal code */
+
+struct dot_chunk_res_t {
+  const u_char *chunk_id_base;
+  unsigned int chunk_id_len;
+  const u_char *chunk_data_base;
+  unsigned int chunk_data_len;
+};
+
+class ChunkInfo {
+	public:
+		string chunk_id; 
+ 		tcp_seq s_seq_num;
+ 		int chunk_length;
+
+		ChunkInfo(string c_id, tcp_seq seq, int length) {
+
+			chunk_id = c_id;
+			s_seq_num = seq; 
+			chunk_length = length; 
+
+		}
+};
+
+
+class SniffTcp {
+ protected:
+    std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >* p_flow_list;
+    char mask[24];
+    unsigned int mask_size_in_bytes;
+    ptr <aclnt> sniffer_c;
+
+    // NEW - START
+    //map< string, std::list<string> > flow_chunk_map;
+    map< string, std::list<ChunkInfo> > flow_chunk_map;
+    map< string, ReconstructedChunk* > chunkId_reconstructedChunk_map;
+    // NEW - END
+
+    struct timeval *g_p_start_time, *g_p_end_time;
+    struct timeval *g_p_with_cid_start_time, *g_p_with_cid_end_time;
+    struct timeval *g_p_without_cid_start_time, *g_p_without_cid_end_time;
+    struct timeval *g_p_deal_with_candidates_start_time, *g_p_deal_with_candidates_end_time;
+    struct timeval *g_p_cid_iteration_start_time, *g_p_cid_iteration_end_time;
+    struct timeval *g_p_cid_iteration_fit_start_time, *g_p_cid_iteration_fit_end_time;
+    struct timeval *g_p_store_start_t, *g_p_store_end_t;
+    long deal_delta_t, cid_iter_t, cid_iter_fit_t, g_store_time;
+
+ public:
+  
+    SniffTcp(const char* s);
+    SniffTcp(SniffTcp& sniffer);
+    virtual ~SniffTcp();
+  
+    int numChunksSniffed;
+    int numPacketsCaptured;
+    int numTcpPacketsCaptured;
+    unsigned long numBytesOfTcpPacketsCaptured;
+    unsigned long numBytesOfChunksSniffed;
+    unsigned long numDuplicateBytes;
+  
+    int get_flow_offset(FlowId* pFid);
+
+    /*
+     * print data in rows of 16 bytes: offset   hex   ascii
+     *
+     * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+     */
+    void print_hex_ascii_line(const u_char *payload, int len, int offset);
+
+    void print_payload(const u_char *payload, int len);
+
+    u_int16_t handle_ethernet(const struct pcap_pkthdr* pkthdr, const u_char* packet);
+
+    void handle_ip(u_int length, const u_char* ip_packet);
+
+    //void grep_contiguous_block_for_chunks(ContiguousBlock *pcb);
+    void grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator i, std::list<ContiguousBlock*>* stream_block);
+    void grep_flows_for_chunks();
+
+    int get_length_from_byte_stream(const char *b);
+    void send_chunk_to_sniffer_plugin (const char *rpc_buffer);
+    void put_chunk_cb (ref <sniffer_tcp_put_chunk_res>, clnt_stat);
+
+    // Stolen and modified from Jeff's code
+    bool Check80211FCS() { return true; }
+    u_int8_t extract_header_length(u_int16_t fc);
+    void handle_80211(const u_char* packet, u_int len);
+    void handle_data_frame(const u_char *ptr, int len, u_int16_t fc);
+    void handle_llc(const u_char *ptr, int len);
+
+
+    void deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                       const u_char *payload, int size_payload, 
+                                       tcp_seq seq_num);
+
+    bool deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                       FlowId *pFid, string* pFidStr);
+
+    bool fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    void insert(FlowId *pFid, string* pFidStr, 
+                const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    pair<string*, int>* getChunkId(const u_char *payload, int len);
+    const u_char * rpc_header_in_stream (const u_char *payload, int len);
+    bool extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res);
+    bool extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res);
+    //int getChunkLength(const u_char *payload, int len);
+};
+
+/*
+ * workhorse function
+ */ 
+static void my_callback_wifi(u_char* arg, 
+                             const struct pcap_pkthdr* pkthdr, 
+                             const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int frameOffset = 0;
+        u_int frameLen = pkthdr->caplen;
+	pSt->handle_80211(packet + frameOffset, frameLen);
+    }
+}
+
+static void my_callback_ethernet(u_char* arg, 
+                                 const struct pcap_pkthdr* pkthdr, 
+                                 const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int16_t type = pSt->handle_ethernet(pkthdr, packet);
+
+        if(type == ETHERTYPE_IP) {
+            /* handle IP packet */
+ 	    // cout << "this is an IP packet" << endl;
+
+            pSt->handle_ip(pkthdr->caplen - ETHER_HDRLEN, (const u_char *)packet + ETHER_HDRLEN);
+        }
+        else if(type == ETHERTYPE_ARP) {
+            // handle arp packet
+        }
+        else if(type == ETHERTYPE_REVARP) {
+            // handle reverse arp packet
+        }
+    }
+}
+
+#endif //_SNIFF_TCP
diff -Naur src_dot_original/sniffer/SniffTcpv2.cc src/sniffer/SniffTcpv2.cc
--- src_dot_original/sniffer/SniffTcpv2.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/SniffTcpv2.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,2187 @@
+
+/**********************************************************************
+* Code stolen and modified 
+* from Martin Casado, Jeff Pang and the tcpdump turorial (sniffex.c ?).
+* Compile with:
+* gcc -Wall pcap_main.c -lpcap (-o something)
+*
+* Usage: sudo ./binary_name numpackets interface
+**********************************************************************/
+#define DOT_OFFSET_FIELD_FROM_RPC_HEADER 32
+#define DOT_OFFSET_FIELD_LEN 8
+#define RPC_HEADER 0x80
+#define CHUNK_ID_LEN_FIELD 4
+#define LEN_OF_CHUNK_ID 20
+#define CHUNK_LEN_FIELD 4
+
+#include "SniffTcp.h"
+#include <string.h>
+
+#include <netinet/in.h>
+
+enum run_mode_t {
+  OFFLINE = 0,
+  ONLINE = 1,
+  OFFLINE_ONLINE = 2,
+  ONLINE_WIFI = 3,
+  OFFLINE_ONLINE_WIFI = 4
+};
+
+struct run_params_t {
+  int num_pkts;
+  char *interface;
+  char *socket;
+  run_mode_t mode;
+  char *ip_to_ignore;
+  int multi_chance;
+};
+
+run_params_t g_run_options;
+bool g_multi_chances = true;
+
+// XXX :: TESTING - BEGIN
+FlowId *g_pFid = NULL;
+string *g_pFidStr = NULL;
+// XXX :: TESTING - END
+
+dot_desc string_to_dot_desc (string s);
+
+
+SniffTcp::SniffTcp(const char* s)
+{
+    p_flow_list = new std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >();
+
+    mask_size_in_bytes = 24;
+    memset(mask, 0, mask_size_in_bytes);
+    mask[3] = 1;
+    mask[23] = 1;
+    //print_payload((const u_char*)mask, mask_size_in_bytes);
+
+    numChunksSniffed = 0;
+    numPacketsCaptured = 0;
+    numBytesOfTcpPacketsCaptured = 0;
+    numBytesOfChunksSniffed = 0;
+    numTcpPacketsCaptured = 0;
+    numDuplicateBytes = 0;
+
+    int fd = unixsocket_connect(s);
+    if (fd < 0)
+        fatal("%s: %m\n", s);
+
+    // warn("Connected via FD: %d\n", fd);
+
+    /* Setup GTC connection */
+    warn << "Connected to sniffer pluging listening at " << s << "\n";
+    ptr<axprt_unix> sniffer_x(axprt_unix::alloc(fd, MAX_PKTSIZE));
+    sniffer_c = aclnt::alloc(sniffer_x, sniffer_tcp_program_1);
+
+
+
+    // FOR TIMING
+
+    // used to time the e2e processing time of a TCP packet with a payload
+    g_p_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    // used to time the e2e processing time of a DOT TCP payload with a Chunk Id
+    g_p_with_cid_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_with_cid_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    // to time the e2e processing time of a DOT TCP payload without a Chunk Id
+    g_p_without_cid_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_without_cid_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    /* this is used to time the code which checks if any of the packets
+       for a given flow, in the global data structure p_flow_list, can complete 
+       a chunk. The code block to do this (deal_with_candidates_for_chunk) is 
+       only called when a packet containing a DOT chunk id is received AND this
+       chunk id has not been seen before.
+    */
+    g_p_deal_with_candidates_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_deal_with_candidates_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+    deal_delta_t = 0;
+
+    /* 
+       When we get a packet with a chunk id, we cycle thru the flow_chunk_map, 
+       to check if we have seen this chunk id before. This times that loop.
+    */
+    g_p_cid_iteration_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_cid_iteration_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+
+    /* 
+       when we get a packet *without* a chunk id, we cycle thru the flow_chunk_map, 
+       and for every chunk id associated with the flow we check to see if the 
+       packet that just came in fits-in. 
+       This times that loop.
+       Also captured in g_p_without_cid_*_time - these ones below just deal with
+       the OLD/Exisiting FLOW case.
+    */
+    g_p_cid_iteration_fit_start_time = (struct timeval *) malloc(sizeof(struct timeval));
+    g_p_cid_iteration_fit_end_time = (struct timeval *) malloc(sizeof(struct timeval));
+
+    cid_iter_t = 0;
+    cid_iter_fit_t = 0;
+}
+
+SniffTcp::SniffTcp(SniffTcp& sniffer)
+{
+    // TODO
+}
+
+SniffTcp::~SniffTcp()
+{
+    //cout << "#####" << endl;
+    while(!p_flow_list->empty()) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = p_flow_list->back();
+        FlowId* pFid = p->first;
+	//pFid->print();
+        delete pFid;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+	//cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ++i) {
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            //print_payload((const u_char*) (*i)->p_s_contiguous_block->c_str(), (*i)->p_s_contiguous_block->size());
+            delete *i;
+        }
+        delete stream_blocks;
+        delete p;
+
+        p_flow_list->pop_back();
+	//cout << "*****" << endl;
+    }
+    delete p_flow_list;
+
+
+    flow_chunk_map.clear();
+    chunkId_reconstructedChunk_map.clear();
+
+    free(g_p_start_time);
+    free(g_p_end_time);
+    free(g_p_with_cid_start_time);
+    free(g_p_with_cid_end_time);
+    free(g_p_without_cid_start_time);
+    free(g_p_without_cid_end_time);
+
+    free(g_p_deal_with_candidates_start_time);
+    free(g_p_deal_with_candidates_end_time);
+    free(g_p_cid_iteration_start_time);
+    free(g_p_cid_iteration_end_time);
+    free(g_p_cid_iteration_fit_start_time);
+    free(g_p_cid_iteration_fit_end_time);
+
+    cout << "#####" << endl;
+}
+
+
+/*
+ * print data in rows of 16 bytes: offset   hex   ascii
+ *
+ * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+ */
+void SniffTcp::print_hex_ascii_line(const u_char *payload,
+                                    int len,
+                                    int offset)
+{
+    int i;
+    int gap;
+    const u_char *ch;
+
+    /* offset */
+    printf("%05d   ", offset);
+
+    /* hex */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        printf("%02x ", *ch);
+        ch++;
+        /* print extra space after 8th byte for visual aid */
+        if (i == 7)
+            printf(" ");
+    }
+    /* print space to handle line less than 8 bytes */
+    if (len < 8)
+        printf(" ");
+
+    /* fill hex gap with spaces if not full line */
+    if (len < 16) {
+        gap = 16 - len;
+        for (i = 0; i < gap; i++) {
+            printf("   ");
+        }
+    }
+    printf("   ");
+
+    /* ascii (if printable) */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        if (isprint(*ch))
+            printf("%c", *ch);
+        else
+            printf(".");
+        ch++;
+    }
+
+    printf("\n");
+
+    return;
+}
+
+/*
+ * print packet payload data (avoid printing binary data)
+ */
+void SniffTcp::print_payload(const u_char *payload,
+                             int len)
+{
+    int len_rem = len;
+    int line_width = 16;			/* number of bytes per line */
+    int line_len;
+    int offset = 0;					/* zero-based offset counter */
+    const u_char *ch = payload;
+
+    if (len <= 0)
+        return;
+
+    /* data fits on one line */
+    if (len <= line_width) {
+        print_hex_ascii_line(ch, len, offset);
+        return;
+    }
+
+    /* data spans multiple lines */
+    for ( ;; ) {
+        /* compute current line length */
+        line_len = line_width % len_rem;
+        /* print line */
+        print_hex_ascii_line(ch, line_len, offset);
+        /* compute total remaining */
+        len_rem = len_rem - line_len;
+        /* shift pointer to remaining bytes to print */
+        ch = ch + line_len;
+        /* add offset */
+        offset = offset + line_width;
+        /* check if we have line width chars or less */
+        if (len_rem <= line_width) {
+            /* print last line and get out */
+            print_hex_ascii_line(ch, len_rem, offset);
+            break;
+        }
+    }
+
+    return;
+}
+
+/* handle ethernet packets, much of this code gleaned from
+ * print-ether.c from tcpdump source
+ */
+u_int16_t SniffTcp::handle_ethernet(const struct pcap_pkthdr* pkthdr,
+                                    const u_char* packet)
+{
+    u_int caplen = pkthdr->caplen;
+#ifdef AMAR_DEBUG
+    u_int length = pkthdr->len;
+#endif //AMAR_DEBUG
+    struct ether_header *eptr;  /* net/ethernet.h */
+    u_short ether_type;
+
+    if (caplen < ETHER_HDRLEN) {
+        cout << "Packet length less than ethernet header length." << endl;
+        return ~0;
+    }
+
+    /* lets start with the ether header... */
+    eptr = (struct ether_header *) packet;
+    ether_type = ntohs(eptr->ether_type);
+
+#ifdef AMAR_DEBUG
+    /* print SOURCE DEST TYPE LENGTH */
+    fprintf(stdout,"ETH: ");
+    fprintf(stdout,"[%s => ", ether_ntoa((struct ether_addr*)eptr->ether_shost));
+    fprintf(stdout,"%s] ", ether_ntoa((struct ether_addr*)eptr->ether_dhost));
+
+    /* check to see if we have an ip packet */
+    if (ether_type == ETHERTYPE_IP) {
+        cout << "(IP)";
+    }
+    else  if (ether_type == ETHERTYPE_ARP) {
+        cout << "(ARP)";
+    }
+    else  if (eptr->ether_type == ETHERTYPE_REVARP) {
+        cout << "(RARP)";
+    }
+    else {
+        cout << "(?)";
+    }
+    cout << length << endl;
+#endif //AMAR_DEBUG
+
+    return ether_type;
+}
+
+
+void SniffTcp::handle_ip(u_int length,
+                         const u_char* ip_packet)
+{
+    const struct sniff_ip* ip;
+    u_int ip_hlen, off, version;
+    u_int len;
+    u_int size_tcp_header;
+    const struct sniff_tcp *tcp;
+    const u_char *payload; /* Packet payload */
+    int size_payload;
+
+    /* jump past the ethernet header */
+    ip = (struct sniff_ip*)(ip_packet);
+
+    /* check to see we have a packet of valid length */
+    if (length < sizeof(struct sniff_ip))
+        {
+            printf("Truncated ip packet (length = %d).\n", length);
+            return;
+        }
+
+    // length of the ip packet along with the ip header
+    len     = ntohs(ip->ip_len);
+    ip_hlen = IP_HL(ip)*4; /* header length */
+    version = IP_V(ip);  /* ip version */
+
+    /* check version */
+    if (version != 4) {
+        fprintf(stdout,"Unknown IP version %d\n", version);
+        return;
+    }
+
+    /* check header length */
+    if (ip_hlen < 20) {
+        fprintf(stdout,"Bad-ip-hlen %d \n", ip_hlen);
+        return;
+    }
+
+    /* see if we have as much packet as we should */
+    if(length < len) {
+        printf("Truncated IP - %d bytes missing\n", len - length);
+        return;
+    }
+
+    /* Check to see if we have the first fragment */
+    off = ntohs(ip->ip_off);
+    if ((off & IP_OFFMASK) == 0 ) /* aka no 1's in first 13 bits */
+        {
+#ifdef AMAR_DEBUG
+            /* print SOURCE DESTINATION hlen version len frag_offset */
+            cout << "\tIP: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+#endif //AMAR_DEBUG
+        } else {
+        //#ifdef AMAR_DEBUG
+            cout << "\tIP fragment has arrived: ";
+            cout << "[" << inet_ntoa(ip->ip_src) << " => ";
+            cout << inet_ntoa(ip->ip_dst) << "] ip_hlen = " << ip_hlen << ", version = " << version << ", len = " << len << ", fragment offset = " << (off & IP_OFFMASK) << endl;
+        //#endif //AMAR_DEBUG
+    }
+
+    // XXX
+    // IMPORTANT ASSUMPTION :: ignore ip reassembly for the time being !!!
+
+    /* determine protocol */
+    switch(ip->ip_p) {
+        case IPPROTO_TCP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: TCP" << endl;
+#endif //AMAR_DEBUG
+            break;
+
+        case IPPROTO_UDP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: UDP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_ICMP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: ICMP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        case IPPROTO_IP:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: IP" << endl;
+#endif //AMAR_DEBUG
+            return;
+
+        default:
+#ifdef AMAR_DEBUG
+            cout << "\tProtocol: unknown" << endl;
+#endif //AMAR_DEBUG
+            return;
+    }
+
+
+    // handle_tcp
+    tcp = (struct sniff_tcp*)(ip_packet + ip_hlen);
+    size_tcp_header = TH_OFF(tcp)*4;
+    if (size_tcp_header < 20) {
+        fprintf(stdout, "\t*! Invalid TCP header length: %u bytes\n", size_tcp_header);
+    }
+    else {
+        payload = (u_char *)(ip_packet + ip_hlen + size_tcp_header);
+
+        /* compute tcp payload (segment) size */
+        size_payload = ntohs(ip->ip_len) - (ip_hlen + size_tcp_header);
+
+        /*
+         * Print payload data; it might be binary, so don't just
+         * treat it as a string.
+         */
+        if (size_payload > 0) {
+
+            //#ifdef AMAR_DEBUG_1
+            gettimeofday(g_p_start_time, NULL);
+            //#endif //AMAR_DEBUG
+
+            deal_delta_t = 0;
+            cid_iter_t = 0;
+            cid_iter_fit_t = 0;
+
+            numTcpPacketsCaptured++;
+            numBytesOfTcpPacketsCaptured += size_payload;
+
+            char *src_ip = strdup(inet_ntoa(ip->ip_src));
+            char *dst_ip = strdup(inet_ntoa(ip->ip_dst));
+
+#ifdef AMAR_DEBUG
+            //#if 1
+            cout << "----------" << endl;
+            cout << "\tTCP Src " << src_ip << ":" << ntohs(tcp->th_sport)
+                 << "; TCP Dst " << dst_ip << ":" << ntohs(tcp->th_dport);
+            cout << "\tPayload (" << size_payload << " bytes):" << endl;
+            print_payload(payload, size_payload);
+#endif //AMAR_DEBUG
+
+            tcp_seq seq_num = ntohl(tcp->th_seq);
+
+
+            /*
+            // XXX :: TESTING - BEGIN
+            //tcp_seq temp_seq0 = 3659991430;
+            tcp_seq temp_seq0 = 3659989982; // first flow
+            
+            if (seq_num == temp_seq0) {
+                cout << "dropping packet" << endl;
+
+                g_pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+                g_pFidStr = g_pFid->toString();
+
+                return;
+            }
+            // XXX :: TESTING - END
+            */
+
+            FlowId *pFid = new FlowId(src_ip, dst_ip, ntohs(tcp->th_sport), ntohs(tcp->th_dport));
+            string* pFidStr = pFid->toString();
+
+
+            free (src_ip);
+            free (dst_ip);
+
+	    
+	    
+
+            if (g_multi_chances == false) {
+                // insert payload into flow_list
+                insert(pFid, pFidStr, payload, size_payload, seq_num);
+            }
+            else {
+                // NEW - START
+#ifdef AMAR_DEBUG_1
+                cout << "@@@@@ ";
+                pFid->print();
+                cout << flow_chunk_map.size() << endl;
+#endif //AMAR_DEBUG_1
+
+
+              //  map< string, std::list<string> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+			  map< string, std::list<ChunkInfo> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+                         
+
+			    if (fc_map_i == flow_chunk_map.end()) {
+                    // never seen this flow before (at least never seen a chunk of this flow)
+#ifdef AMAR_DEBUG_1
+                    cout << "never seen this flow before (at least never seen a chunk of this flow)" << endl;
+#endif //AMAR_DEBUG_1
+
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    // TODO :: for testing only - remove later and replace with line above
+                    p_cid_offset_pair = NULL;
+                    cout << "yo = " << seq_num << endl;
+
+                    tcp_seq temp_seq1 = 3659989982; // first flow
+                    tcp_seq temp_seq2 = 3667694287; // second flow
+
+#if 0
+                    if ( (seq_num == temp_seq1) || (seq_num == temp_seq2)) {
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+#endif //0
+                    if (seq_num == temp_seq2) {
+                        cout << "playing around with seq_num = " << seq_num << endl;
+                        seq_num = temp_seq1;
+                        
+                        // ignore delete for testing purposes
+                        pFid = g_pFid;
+                        pFidStr = g_pFidStr;
+                        cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                        p_cid_offset_pair = new pair<string*, int>(new string("hola!"), 0);
+                    }
+
+                    // XXX :: TESTING - END
+                    */
+
+
+                    // the packet has a chunk id - either at the starting or somewhere in the middle
+                    if (p_cid_offset_pair != NULL) {
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_with_cid_start_time, NULL);
+                        //#endif //AMAR_DEBUG_1
+
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // insert payload into flow_list, size = offset
+                            insert(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        // yes! as this was a new flow, we have to add this flow to the flow_chunk_map
+
+						//FAHAD-TODO:rather than just the cid, add seq no and length as well
+
+						////start of new code///
+						int c_len = get_length_from_byte_stream((const char*) payload);
+						ChunkInfo *c_info = new ChunkInfo(*p_chunk_id, seq_num, c_len);
+		
+						std::list<ChunkInfo> cid_list;
+						cid_list.push_back(*c_info);
+						                   
+						flow_chunk_map[*pFidStr] = cid_list;
+						///////end of new code////
+
+						//std::list<string> cids;   //PREV
+                        //cids.push_back(*p_chunk_id);
+               			//flow_chunk_map[*pFidStr] = cids;
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            gettimeofday(g_p_deal_with_candidates_start_time, NULL);
+
+                            bool b_chunk_done2 = deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                            gettimeofday(g_p_deal_with_candidates_end_time, NULL);
+                            deal_delta_t = (g_p_deal_with_candidates_end_time->tv_sec - g_p_deal_with_candidates_start_time->tv_sec)*1000000 
+                            + g_p_deal_with_candidates_end_time->tv_usec - g_p_deal_with_candidates_start_time->tv_usec;
+
+
+                            /* cleanup */
+                            if (b_chunk_done || b_chunk_done2) {
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+
+                                /* cleanup */
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_with_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_with_cid_end_time->tv_sec - g_p_with_cid_start_time->tv_sec)*1000000 
+                            + g_p_with_cid_end_time->tv_usec - g_p_with_cid_start_time->tv_usec;
+                        cout << "[New Flow + pkt has chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+                        //#endif //AMAR_DEBUG_1
+
+                    } else {
+                        // this packet does not have a chunk id and we have never seen a chunk on this flow,
+                        // go ahead and store it in the flow as a contiguous block
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_without_cid_start_time, NULL);
+                        //#endif //AMAR_DEBUG_1
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. inserting into flow_list" << endl;
+#endif //AMAR_DEBUG_1
+                        insert(pFid, pFidStr, payload, size_payload, seq_num);
+
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_without_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_without_cid_end_time->tv_sec - g_p_without_cid_start_time->tv_sec)*1000000 
+                            + g_p_without_cid_end_time->tv_usec - g_p_without_cid_start_time->tv_usec;
+                        cout << "[New Flow + pkt does not have chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+                        //#endif //AMAR_DEBUG_1
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                }
+                else {
+
+                    // ah! we have seen a chunk on this flow before
+//#ifdef AMAR_DEBUG_1
+                    cout << "we have seen some chunk on this flow before." << endl;
+//#endif //AMAR_DEBUG_1
+
+                    // so is the packet that just came in a part of a chunk that we have seen or is it a new one?
+                    // if it is a new one - 
+                    //    it either has the chunk id (if it is the first packet), 
+                    //    or it is an intermediate packet of a new chunk that we have not yet seen
+
+                    // does the packet have a chunk id?
+                    pair<string*, int>* p_cid_offset_pair = getChunkId(payload, size_payload);
+
+                    /*
+                    // XXX :: TESTING - START
+                    tcp_seq temp_seq3 = 3659997222;
+                    if ( seq_num == temp_seq3 ) {
+                    cout << "found chunk header packet in packet with seq_num = " << seq_num << endl;
+                    p_cid_offset_pair = new pair<string*, int>(new string("aloha!"), 1004);
+                    }
+                    // XXX :: TESTING - END
+                    */
+
+
+                    if (p_cid_offset_pair != NULL) {
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_with_cid_start_time, NULL);
+                        //#endif //AMAR_DEBUG_1
+
+                        string* p_chunk_id = p_cid_offset_pair->first;
+                        int chunk_offset = p_cid_offset_pair->second;
+
+#ifdef AMAR_DEBUG_1
+                        cout << "holy cow! The packet has chunk id." << endl;
+                        warn << "chunk id = " << string_to_dot_desc (*p_chunk_id)  << "; chunk_offset = " 
+			     << chunk_offset << "\n";
+#endif //AMAR_DEBUG_1
+
+                        // chunk id somewhere in the middle of the packet
+                        if (chunk_offset > 0) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "inserting contents in packet just before the chunk id into flow_list ..." << endl;
+#endif //AMAR_DEBUG_1
+
+                            // deal with the first part of the packet wich has no chunk id
+                            deal_with_pkt_without_chunkid(pFid, pFidStr, payload, chunk_offset, seq_num);
+
+                            // payload+offset to payload+size_payload is part of the new chunk
+                            payload = payload + chunk_offset;
+                            size_payload = size_payload - chunk_offset;
+                            // TODO :: do we care about wrap around here? - not for now
+                            seq_num = seq_num + chunk_offset;
+                        }
+
+
+#ifdef AMAR_DEBUG_1
+                        cout << "adding flow to flow_chunk_map" << endl;
+#endif //AMAR_DEBUG_1
+                        // PERF TODO :: ARG!!!! ouch! expensive ?!
+                        gettimeofday(g_p_cid_iteration_start_time, NULL);
+
+                        std::list<ChunkInfo>::iterator ci; 
+                        
+						//TODO-FAHAD:changes here --- have to now check the id as well as sequence no
+						for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+                            if (((*ci).chunk_id) == *p_chunk_id) break;
+                        }
+                        
+						//TODO-FAHAD:have to make changes here --- add the seq no, and size as well 
+						if (ci == fc_map_i->second.end()) {
+
+							int c_len = get_length_from_byte_stream((const char*) payload);
+							ChunkInfo *c_info = new ChunkInfo(*p_chunk_id, seq_num, c_len);
+		
+							  fc_map_i->second.push_back(*c_info);
+
+//                            fc_map_i->second.push_back(*p_chunk_id);   PREV
+                        }
+
+                        gettimeofday(g_p_cid_iteration_end_time, NULL);
+                        cid_iter_t = (g_p_cid_iteration_end_time->tv_sec - g_p_cid_iteration_start_time->tv_sec)*1000000 
+                            + g_p_cid_iteration_end_time->tv_usec - g_p_cid_iteration_start_time->tv_usec;
+                        
+
+                        // check if the chunk id is already present in the chunkId_reconstructedChunk_map
+                        map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find(*p_chunk_id);
+
+                        if (mapi == chunkId_reconstructedChunk_map.end()) {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id not seen before" << endl;
+                            cout << "adding chunk id to chunkId_reconstructedChunk_map" << endl;
+#endif //AMAR_DEBUG_1
+
+                            // chunk id not seen before
+                            int chunk_len = get_length_from_byte_stream((const char*) payload);
+                            ReconstructedChunk *p_rc = new ReconstructedChunk(p_chunk_id, chunk_len);
+                            p_rc->flow_seq_map[(*pFidStr)] = seq_num;
+                            chunkId_reconstructedChunk_map[*p_chunk_id] = p_rc;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = p_rc->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+                            }
+
+                            /* we might have received packets for this chunk earlier
+                               go and fetch them - but we deal only with the current flow
+                               This implies that any flow which misses the first packet which has the chunk id
+                               is going to be ignored for that chunk
+                            */
+                            gettimeofday(g_p_deal_with_candidates_start_time, NULL);
+
+                            bool b_chunk_done2 = deal_with_candidates_for_chunk(p_rc, pFid, pFidStr);
+
+                            gettimeofday(g_p_deal_with_candidates_end_time, NULL);
+                            deal_delta_t = (g_p_deal_with_candidates_end_time->tv_sec - g_p_deal_with_candidates_start_time->tv_sec)*1000000 
+                            + g_p_deal_with_candidates_end_time->tv_usec - g_p_deal_with_candidates_start_time->tv_usec;
+
+                            /* cleanup */
+                            if (b_chunk_done || b_chunk_done2) {
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+
+
+                        } else {
+
+#ifdef AMAR_DEBUG_1
+                            cout << "chunk id seen before" << endl;
+                            cout << "adding flow_id -> starting seq# entry in the chunk's flow_seq_map" << endl;
+#endif //AMAR_DEBUG_1
+                            // chunk id seen before
+                            mapi->second->flow_seq_map[(*pFidStr)] = seq_num;
+
+#ifdef AMAR_DEBUG_1
+                            cout << "copying the unique contents of the packet into the chunk structure" << endl;
+#endif //AMAR_DEBUG_1
+                            // copy the unique contents
+                            bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                            if (b_chunk_done) {
+                                const char* p_data = mapi->second->get_data();
+                                if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                    cout << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                    cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                    warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                                    send_chunk_to_sniffer_plugin (p_data);
+                                }
+
+                                /* cleanup */
+                                // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                                // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                                // removing from flow_chunk_map is a little more complex in the current setting
+                            }
+                        }
+
+                        if (p_chunk_id != NULL) {
+                            delete p_chunk_id;
+                        }
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_with_cid_end_time, NULL);
+                        long inner_delta_t = (g_p_with_cid_end_time->tv_sec - g_p_with_cid_start_time->tv_sec)*1000000 
+                            + g_p_with_cid_end_time->tv_usec - g_p_with_cid_start_time->tv_usec;
+                        cout << "[Old Flow + pkt has chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+                        //#endif //AMAR_DEBUG_1
+                    } else {
+                        // this packet does not have a chunk id 
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_without_cid_start_time, NULL);
+                        gettimeofday(g_p_cid_iteration_fit_start_time, NULL);
+                        //#endif //AMAR_DEBUG_1
+
+#ifdef AMAR_DEBUG_1
+                        cout << "boo. packet does not have chunk id. deal_with_pkt_without_chunkid()" << endl;
+#endif //AMAR_DEBUG_1
+                        deal_with_pkt_without_chunkid(pFid, pFidStr, payload, size_payload, seq_num);
+
+                        //#ifdef AMAR_DEBUG_1
+                        gettimeofday(g_p_without_cid_end_time, NULL);
+                        gettimeofday(g_p_cid_iteration_fit_end_time, NULL);
+
+                        long inner_delta_t = (g_p_without_cid_end_time->tv_sec - g_p_without_cid_start_time->tv_sec)*1000000 
+                            + g_p_without_cid_end_time->tv_usec - g_p_without_cid_start_time->tv_usec;
+
+                        cid_iter_fit_t = (g_p_cid_iteration_fit_end_time->tv_sec - g_p_cid_iteration_fit_start_time->tv_sec)*1000000 
+                            + g_p_cid_iteration_fit_end_time->tv_usec - g_p_cid_iteration_fit_start_time->tv_usec;
+
+                        cout << "[Old Flow + pkt does not have chunkId] TCP packet processing time (usec) = " << inner_delta_t << endl;
+                        //#endif //AMAR_DEBUG_1
+                    }
+
+                    if (p_cid_offset_pair != NULL) {
+                        delete p_cid_offset_pair;
+                    }
+                    /*
+                      std::list<string>::iterator si;
+                      for (si = chunkIds.begin(); si != chunkIds.end(); ++si) {
+                      cout << "##### ";
+                      pFid->print();
+                      cout << "==> " << *si << endl;
+                      }
+                    */
+                }
+                // NEW - END
+            }
+
+            delete pFidStr;
+
+            //#ifdef AMAR_DEBUG_1
+            gettimeofday(g_p_end_time, NULL);
+            long delta_t = (g_p_end_time->tv_sec - g_p_start_time->tv_sec)*1000000 
+                + g_p_end_time->tv_usec - g_p_start_time->tv_usec;
+            cout << "TCP packet processing time (usec): Total = " << delta_t
+                 << "; deal_global = " << deal_delta_t
+                 << "; cid_iter = " << cid_iter_t
+                 << "; cid_iter_fit = " << cid_iter_fit_t
+                 << endl;
+            //#endif //AMAR_DEBUG_1
+        }
+    }
+
+    //cout << "-------------------------" << endl;
+    return;
+}
+void SniffTcp::deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                             const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+	    
+	
+	map< string, std::list<ChunkInfo> >::iterator fc_map_i = flow_chunk_map.find(*pFidStr);
+    //cout << "start of function deal_with_pkt without chunkid" << endl;
+	//TODO-FAHAD: make changes here --- make sure that we check seq no, and range along with the cid at the top level
+	if (fc_map_i != flow_chunk_map.end()) {
+        std::list<ChunkInfo>::iterator ci; 
+        for( ci = fc_map_i->second.begin(); ci != fc_map_i->second.end(); ci++ ) {
+            
+	
+			tcp_seq starting_seq_number = (*ci).s_seq_num;
+			int len = (*ci).chunk_length;
+			
+
+#ifdef AMAR_DEBUG_1
+                warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "checking " << string_to_dot_desc (((*ci).chunk_id)) 
+                     << "; starting_seq_number = " << starting_seq_number << "; len = " << len 
+                     << "; seq_num of incoming packet = " << seq_num << "\n";
+#endif // AMAR_DEBUG_1
+                // do something only if the packet lies within the chunk
+                if ( (seq_num > starting_seq_number) && (seq_num < (starting_seq_number + len) ) ) {
+#ifdef AMAR_DEBUG_1
+                    warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet fits/overlaps in the chunk " 
+			 << string_to_dot_desc (((*ci).chunk_id)) << "\n";
+#endif // AMAR_DEBUG_1
+					map<string, ReconstructedChunk*>::iterator mapi = chunkId_reconstructedChunk_map.find (((*ci).chunk_id));
+
+                    bool b_chunk_done = fill_gaps_in_chunk(mapi->second, pFid, pFidStr, payload, size_payload, seq_num);
+                    if (b_chunk_done) {
+                        const char* p_data = mapi->second->get_data();
+                        if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                            cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                            cout << "number of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                            warn << "chunk id = " << string_to_dot_desc (*(mapi->second->p_chunk_id))  << "; # of uniquely contributing flows = " << mapi->second->uniquely_contributing_flows.size() << "\n";
+                            send_chunk_to_sniffer_plugin (p_data);
+
+                            /* cleanup */
+                            // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                            // chunkId_reconstructedChunk_map.erase(mapi);
+                            // removing from flow_chunk_map is a little more complex in the current setting
+                        }
+                    }
+                    return;
+                } else {
+#ifdef AMAR_DEBUG_1
+                    warn << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet does not fit/overlap the chunk "
+			 << string_to_dot_desc (*ci) << "\n";
+#endif // AMAR_DEBUG_1
+
+                    /* cleanup */
+                    // PERF TODO :: check if RC has aged enough and cleanup
+                    // PERF TODO :: remove stuff from the chunkId_reconstructedChunk_map, and flow_chunk_map
+                    // chunkId_reconstructedChunk_map.erase(*p_chunk_id);
+                    // removing from flow_chunk_map is a little more complex in the current setting
+                }
+            
+            
+        }
+
+        // if this packet did not fit into any of the exisiting chunks
+#ifdef AMAR_DEBUG_1
+        cout << "SniffTcp::deal_with_pkt_without_chunkid => " << "packet did not fit/overlap any chunk. " 
+             << "Inserting into the global tcp flow state (flow_list)" << endl;
+#endif //AMAR_DEBUG_1
+        insert(pFid, pFidStr, payload, size_payload, seq_num);
+    }
+}
+
+
+
+
+bool SniffTcp::deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                             FlowId *pFid, string* pFidStr) 
+{
+    bool b_done = false;
+
+#ifdef AMAR_DEBUG_1
+    cout << "In SniffTcp::deal_with_candidates_for_chunk" << endl;
+#endif //AMAR_DEBUG_1
+    tcp_seq starting_seq_number = p_rc->flow_seq_map[(*pFidStr)];
+    int len = p_rc->length;
+
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0)
+        {
+            std::list<ContiguousBlock*>::iterator li;
+            for (li = p_lcb->begin(); li != p_lcb->end(); ) 
+            {
+                if ( ( *li !=  0 )  &&
+                     ( ((*li)->starting_seq_number > starting_seq_number) && 
+                       ((*li)->starting_seq_number < (starting_seq_number + len) ) )
+                     )
+                    {
+                        /* there is no chance of overlapping - because if it does 
+                           overlap then there would have been a chunk boundary
+                           and we would have already dealt with that case
+                        */
+                        bool b_chunk_done = fill_gaps_in_chunk(p_rc, pFid, pFidStr, 
+                                                 (const u_char*) (*li)->p_s_contiguous_block->c_str(), 
+                                                 (*li)->p_s_contiguous_block->size(), 
+                                                 (*li)->starting_seq_number);
+
+                        if (b_chunk_done) {
+                            const char* p_data = p_rc->get_data();
+                            if (p_data != NULL) {
+#ifdef AMAR_DEBUG_1
+                                cout << "SniffTcp::deal_with_candidates_for_chunk => " << "complete chunk constructed - sending to sniffer plugin" << endl;
+                                cout << "number of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+
+                                warn << "chunk id = " << string_to_dot_desc (*(p_rc->p_chunk_id))  << "; # of uniquely contributing flows = " << p_rc->uniquely_contributing_flows.size() << "\n";
+#endif //AMAR_DEBUG_1
+                                send_chunk_to_sniffer_plugin (p_data);
+                            }
+                            b_done = true;
+                        }
+
+                        // remove *li
+                        p_lcb->erase(li++);
+
+                        // TODO :: should we break out if b_done is true?
+                }
+                else {
+                    ++li;
+                }
+            }
+        }
+    }
+    return b_done;
+}
+
+bool SniffTcp::fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num)
+{
+
+    bool b_chunk_done = false;
+
+    map<string, tcp_seq>::iterator fsi = p_rc->flow_seq_map.find(*pFidStr);
+    if (fsi != p_rc->flow_seq_map.end()) {
+        tcp_seq starting_seq_num = fsi->second;
+        int chunk_len = p_rc->length;
+
+        int diff = ( (seq_num + size_payload) - (starting_seq_num + chunk_len) );
+
+        if (diff < 0) {
+            diff = 0;
+        }
+
+        if (diff  > 0 ) {
+            insert(pFid, pFidStr, payload + size_payload - diff, diff, seq_num + size_payload - diff);
+        }
+        
+        b_chunk_done = p_rc->fill_gaps_in_chunk(pFid, pFidStr, payload, size_payload - diff, seq_num, &numDuplicateBytes);
+    }
+
+    return b_chunk_done;
+}
+
+void SniffTcp::insert(FlowId *pFid, string* pFidStr, 
+                      const u_char *payload, int size_payload, tcp_seq seq_num) 
+{
+
+    // check if the fracking flow exists
+    int flow_offset = get_flow_offset(pFid);
+    if (flow_offset >= 0) {
+        // If it does, check if the current packet is a dup and if so discard.
+        // Else, check if contiguous
+        //    if so fuse
+        //    else append.
+#ifdef AMAR_DEBUG
+        cout << "Existing flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+        std::list<ContiguousBlock*>* p_lcb = ((*p_flow_list)[flow_offset]->second);
+        if (p_lcb != 0) {
+            std::list<ContiguousBlock*>::iterator li;
+            bool bDone = false;
+
+            // TODO :: maybe better to start from the end of the list and move back
+            for (li = p_lcb->begin(); li != p_lcb->end(); ++li) {
+                if ( *li !=  0 ) {
+
+                    /*
+                      if ( ((seq_num + size_payload) == (*li)->next_expected_seq_number) && (seq_num == (*li)->starting_seq_number) ) {
+                      // duplicate - hence ignore
+                      bDone = true;
+                      break;
+                      }
+
+                      // TODO ::
+                      // there are also cases where
+                      // a) start boundary is the same and the end boundary is different
+                      // b) end bondary is the same and the start boundary is different
+                      // ignoring these cases for the time being
+                      */
+
+                    if ( seq_num < (*li)->next_expected_seq_number ) {
+                        if ( (seq_num + size_payload) == (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "pre-contiguous! prepending ..." << endl;
+#endif //AMAR_DEBUG
+                            (*li)->prepend((const char*)payload, size_payload, seq_num);
+                        }
+                        else if ( (seq_num + size_payload) < (*li)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                            cout << "not pre-contiguous. inserting new cb ..." << endl;
+#endif //AMAR_DEBUG
+                            ContiguousBlock* p_cb = new ContiguousBlock();
+                            p_cb->append((const char*)payload, size_payload, seq_num);
+                            p_lcb->insert(li, p_cb);
+                        }
+                        bDone = true;
+                        break;
+                    }
+                    else if (seq_num == (*li)->next_expected_seq_number) {
+                        // new contiguous packet
+#ifdef AMAR_DEBUG
+                        cout << "contiguous. appending ..." << endl;
+#endif //AMAR_DEBUG
+                        (*li)->append((const char*)payload, size_payload, seq_num + size_payload);
+
+                        std::list<ContiguousBlock*>::iterator li2(li);
+                        li2++;
+                        if (li2 != p_lcb->end()) {
+                            if ( (*li)->next_expected_seq_number == (*li2)->starting_seq_number ) {
+#ifdef AMAR_DEBUG
+                                cout << "merging ..." << endl;
+#endif //AMAR_DEBUG
+                                // time to merge the two
+                                (*li)->append( ((*li2)->p_s_contiguous_block), (*li2)->next_expected_seq_number );
+                                p_lcb->erase(li2);
+                            }
+                        }
+                        bDone = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!bDone) {
+#ifdef AMAR_DEBUG
+                cout << "packet from the future, inserting at the end of the list." << endl;
+#endif //AMAR_DEBUG
+                ContiguousBlock* p_cb = new ContiguousBlock();
+                p_cb->append((const char*)payload, size_payload, seq_num);
+                p_lcb->push_back(p_cb);
+            }
+        }
+#ifdef AMAR_DEBUG
+        cout << "# of cbs = " << p_lcb->size() << endl;
+#endif //AMAR_DEBUG
+
+        //delete pFid;
+    }
+    else {
+#ifdef AMAR_DEBUG
+        cout << "New flow! seq # = " << seq_num << ". Next expected seq # = " << (seq_num + size_payload)  << endl;
+#endif //AMAR_DEBUG
+
+        ContiguousBlock* p_cb = new ContiguousBlock();
+        p_cb->append((const char*)payload, size_payload, seq_num);
+
+        std::list<ContiguousBlock*>* p_lcb = new std::list<ContiguousBlock*>();
+        p_lcb->push_back(p_cb);
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p_pair = new pair< FlowId*, std::list<ContiguousBlock*>* >(pFid, p_lcb);
+        p_flow_list->push_back(p_pair);
+    }
+}
+
+int SniffTcp::get_flow_offset(FlowId* pFid)
+{
+    int offset = -1;
+    if (pFid != 0) {
+        for( unsigned int i = 0; i < (*p_flow_list).size(); i++ ) {
+            if ( *((*p_flow_list)[i]->first) ==  *pFid ) {
+                offset = i;
+                break;
+            }
+        }
+    }
+    return offset;
+}
+
+void SniffTcp::grep_flows_for_chunks()
+{
+    //cout << "In grep_flows_for_chunks" << endl;
+    //cout << "#####" << endl;
+    //cout << "#of flows = " << p_flow_list->size() << endl;
+    for (unsigned int numFlows = 0; numFlows < p_flow_list->size(); numFlows++) {
+        //cout << "*****" << endl;
+        pair< FlowId*, std::list<ContiguousBlock*>* >* p = (*p_flow_list)[numFlows];
+        FlowId* pFid = p->first;
+
+        std::list<ContiguousBlock*>* stream_blocks = p->second;
+        //cout << "# of ContiguousBlocks = " << stream_blocks->size() << endl;
+        std::list<ContiguousBlock*>::iterator i;
+        for (i = stream_blocks->begin(); i != stream_blocks->end(); ) { // remember to increment i inside!
+            //cout << "size of str = " << (*i)->p_s_contiguous_block->size() << endl;
+            
+            while((*i)->bModified && ((*i)->starting_seq_number < (*i)->next_expected_seq_number) ) {
+                cout << "grepping flow => ";
+                pFid->print();
+                grep_contiguous_block_for_chunks(*i,i,stream_blocks); //enchance this call by passing list and iterator
+            }
+              
+            if ((*i)->starting_seq_number == (*i)->next_expected_seq_number) {
+                // we are done with this block!
+                stream_blocks->erase(i++);
+            }
+            else {
+                ++i;
+            }
+        }
+        //cout << "*****" << endl;
+    }
+    //cout << "#####" << endl;
+}
+
+int SniffTcp::get_length_from_byte_stream(const char *b)
+{
+    int i = 0;
+    //printf("converter# = %d, %x, %x %x %x\n", i, b[0], b[1],b[2],b[3]);
+    i |= b[0] & 0x7F;
+    //printf("# = %d \n", i);
+    i = (i << 8);
+    //printf("# = %d \n", i);
+    i |= b[1] & 0xFF;
+    i = (i << 8);
+    i |= b[2] & 0xFF;
+    i = (i << 8);
+    i |= b[3] & 0xFF;
+
+    //cout<<"return val of converter is"<<i<<endl;
+    return i;
+}
+
+char *seen_chunks[4] = {0, 0, 0, 0};
+
+void
+check_chunk_against_prev (char *buf, int len)
+{
+    static int num_seen = 0;
+    int i;
+
+    for (i = 0; i < num_seen; i++) {
+        if (seen_chunks[i]) {
+            if (memcmp (seen_chunks[i], buf, len) == 0) {
+                warn("chunk of len %d matched %d th chunk \n",len,i);
+                // warn << "will now print chunk id of prev seen chunk \n";
+                //     print_chunk_id (seen_chunks[i], len);
+                // warn << "will now print chunk id of  new chunk \n";
+                // print_chunk_id (buf, len);
+                return;
+            }
+        }
+    }
+    if (num_seen < 4) {
+        seen_chunks[num_seen] = New char[len];		
+        memcpy (seen_chunks[num_seen], buf, len);	
+        warn ("Entering chunk as %d th entry \n",num_seen);
+        num_seen++;
+    }
+}
+
+// Given a pointer to an rpc header in a byte stream, if the byte stream
+// is a DOT chunk response return true and populate (passed by ref) arg chunk_res.
+// If it is not a a chunk response return false.
+// A Dot chunk response is currently expected to have the following features
+// 1. RPC payload >= MIN_PAYLOAD_LENGTH
+// 2. Successful bytes2xdr() on dot chunk response portion of byte stream
+// 3. Chunk size >= MIN_CHUNK_SIZE
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res)
+{
+#define RPC_HEADER_LEN 28
+  assert (chunk_res != NULL);
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+    return false;
+  }
+
+  const u_char *tmp = rpc_header + RPC_HEADER_LEN;
+  rpc_bytes <> value;
+  value.set((char *)tmp, payload_length - RPC_HEADER_LEN);
+#ifdef AMAR_DEBUG_PAYLOAD
+  print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+  if (!bytes2xdr(*chunk_res, value)) {
+      warn << "problem in bytes2xdr\n";
+    return false;
+  }
+  if (chunk_res->resok->data.size () < MIN_CHUNK_SIZE) {
+    return false;
+  }
+
+  return true;
+}
+
+
+bool SniffTcp::extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res) 
+{
+    assert (chunk_res != NULL);
+
+    int payload_length = get_length_from_byte_stream ((const char *)rpc_header);
+    if (payload_length < MIN_PAYLOAD_LENGTH) {
+        return false;
+    }
+    const u_char *tmp = rpc_header + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+    chunk_res->chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+    if (chunk_res->chunk_id_len != LEN_OF_CHUNK_ID) {
+        return false;
+    }
+
+    chunk_res->chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+    chunk_res->chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+    if (chunk_res->chunk_data_len < MIN_CHUNK_SIZE) {
+        return false;
+    }
+    chunk_res->chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+#ifdef AMAR_DEBUG_PAYLOAD
+    print_payload((u_char *) rpc_header, payload_length);
+#endif //AMAR_DEBUG_PAYLOAD
+
+    return true;
+}
+
+void SniffTcp::send_chunk_to_sniffer_plugin (const char *rpc_buffer)
+{
+#ifdef AMAR_DEBUG_1
+    cout << "SniffTcp::send_chunk_to_sniffer_plugin => " << "sending to sniffer plugin ..." << endl;
+#endif //AMAR_DEBUG_1
+#if 1
+    dot_chunk_res_t chunk_res;
+    if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+      return;
+    }
+    sniffer_tcp_put_chunk_arg arg;
+    ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+    arg.end = true;
+    arg.data.set ((char *)chunk_res.chunk_data_base, chunk_res.chunk_data_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response ((const u_char*)rpc_buffer, &chunk_res)) {
+    return;
+  }
+  sniffer_tcp_put_chunk_arg arg;
+  ref<sniffer_tcp_put_chunk_res> res = New refcounted<sniffer_tcp_put_chunk_res>;
+  arg.end = true;
+  arg.data.set ((char *)chunk_res.resok->data.base(), chunk_res.resok->data.size());
+#endif 
+  numChunksSniffed++;
+  numBytesOfChunksSniffed += (arg.data.size());
+  sniffer_c->call (SNIFFER_TCP_PROC_PUT_CHUNK, &arg, res,
+		   wrap (this, &SniffTcp::put_chunk_cb, res));
+  if (g_run_options.mode == OFFLINE || g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    usleep (1000);
+  }
+}
+
+void SniffTcp::put_chunk_cb (ref<sniffer_tcp_put_chunk_res> res, clnt_stat err) 
+{
+    if (err) {
+        warn << "Could not send chunk to sniffer plugin \n";
+    }
+    if (!res->ok) {
+        warn << " put chunk to sniffer plugin returned " << *res->errmsg << "\n";
+    }
+    warn << "put chunk to sniffer plugin successful \n" ;
+}
+
+void SniffTcp::grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator it, std::list<ContiguousBlock*>* stream_block)
+{
+    char rpc_header = 0x80;
+    //unsigned int data_size; 
+    string chunk;
+    string tempString;
+
+    //cout << "in grep function to check block starting with seq no = "<< pcb->starting_seq_number << " and size= " << pcb->p_s_contiguous_block->size() << endl;
+    const char *cb_data = pcb->p_s_contiguous_block->c_str();
+    for (unsigned int i = 0; i < pcb->p_s_contiguous_block->size(); i++) {
+        if ( *(cb_data + i) == rpc_header) {
+            //cout << "!!! Found something that looks like the RPC HEADER at " << i << endl;
+
+            if ( (i + 3) < pcb->p_s_contiguous_block->size()) {
+                int payload_length = get_length_from_byte_stream((cb_data + i));
+                
+                //unsigned int payload_length1=*(cb_data+i);
+		
+                unsigned int j = i + 8;
+
+                if ( (j + mask_size_in_bytes) < pcb->p_s_contiguous_block->size() ) {
+
+                    int cmp_result = memcmp((cb_data + j), mask, mask_size_in_bytes);
+                    if (cmp_result == 0) {
+                        //cout << "!!! Found something that looks like a DOT RESPONSE at " << i << endl;
+
+                        unsigned int start = i;
+                        i += (payload_length + 4);
+
+                        //cout << "payload length of RPC =" << payload_length << endl;
+
+
+                        if(i <= pcb->p_s_contiguous_block->size()) {  //enough data in the block
+            		
+                            if (start == 0) {
+                                // chunk at the begining of the cb
+
+                                // Amar :: debug start
+                                //cout << "chunk at the start" << endl;
+                                //cout << "size of contiguous block before trimming = " << pcb->p_s_contiguous_block->size() << endl;
+                                // print_payload((const u_char*) (cb_data + start), i);
+                                // Amar :: debug end
+
+				send_chunk_to_sniffer_plugin (cb_data + start);
+				pcb->starting_seq_number += i;
+                                pcb->p_s_contiguous_block->erase(start, i); // FOR TESTING :: use i-1 for middle chunk test
+
+                                // Amar :: debug start
+                                //cout << "size of contiguous block after trimming = "<< pcb->p_s_contiguous_block->size() << endl;
+                                // Amar :: debug start
+                                //it--;
+
+                                return;
+                            }
+                            else if ( i == (pcb->p_s_contiguous_block->size()+1) ) //when chunk starts from the middle and goes till the end
+                                {
+                                    send_chunk_to_sniffer_plugin (cb_data + start);
+                                    //cout << "chunk is at the end. resizing contiguous block." << endl;
+                                    pcb->next_expected_seq_number = start;    
+                                    //cout << "old size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->p_s_contiguous_block->resize(pcb->p_s_contiguous_block->size() - payload_length - 4);
+                                    //cout << "new size of contiguous block = " << pcb->p_s_contiguous_block->size() << endl;
+                                    pcb->bModified = false;
+                                    return;
+                                }
+                            else {  //chunk is in the middle of the block like A-chunk-B
+
+                                send_chunk_to_sniffer_plugin (cb_data + start);
+                                //cout << "chunk in the middle" << endl;
+                                ContiguousBlock* p_cb = new ContiguousBlock(); //creating new block to store A
+                                char * tempPointer = (char *)pcb->p_s_contiguous_block;
+                                p_cb->append(tempPointer, start, pcb->starting_seq_number); //filling the new block with A
+                                p_cb->bModified=false;                                    //marking that it has been checked
+                                stream_block->insert(it, p_cb);  //inserting the new block in the new list
+
+                                pcb->starting_seq_number += i;         //changing the initial sequence of the original block
+                                pcb->p_s_contiguous_block->erase(0, i); //erasing the part upto the start of B
+            			       
+                                it--;
+                                return;
+                            }
+                        }
+                        else {
+                            //cout << "waiting for more data to come!" << endl;
+                            pcb->bModified = false;
+                        }
+                      
+                        i--; // i will be incremented in the loop, hence compensating
+                    }
+                }
+            }
+        }
+    }
+    pcb->bModified = false; //indicating that this round has been checked
+}
+
+void 
+run_pcap_live ()
+{
+    //char *dev = "lo";
+  char *dev = g_run_options.interface;
+    char *net = g_run_options.ip_to_ignore; /* dot notation of the network address */
+    char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+    pcap_t* h_pcap;
+    struct bpf_program fp;      /* hold compiled program     */
+    bpf_u_int32 maskp;          /* subnet mask               */
+    bpf_u_int32 netp;           /* ip                        */
+    struct in_addr tmp_addr;
+
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    int ret = pcap_lookupnet(dev, &netp, &maskp, errbuf);
+    if(ret == -1)
+    {
+        printf("%s\n",errbuf);
+        exit(1);
+    }
+
+    /* get the network address in a human readable form */
+    tmp_addr.s_addr = netp;
+    //net = strdup(inet_ntoa(tmp_addr));
+
+    //if(net == NULL)
+    //{
+    //    perror("inet_ntoa");
+    //    exit(1);
+    //}
+    //printf("NET: %s\n", net);
+
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    char *default_filter = "tcp and not port 22 and not port 6010"; 
+    char *host_filter = " and not host "; 
+    int filter_len = strlen(default_filter) + strlen(host_filter) + strlen(net) + 1;
+    char* final_filter = (char *)malloc(sizeof(char *) * filter_len);
+    memset(final_filter, 0, filter_len);
+    sprintf(final_filter, "%s%s%s", default_filter, host_filter, net);
+    cout << "Final Filter: " << final_filter << endl;
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, final_filter, 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+        //pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_ethernet, (u_char *)pSt);
+        pSt->numPacketsCaptured += pcap_dispatch(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    
+        //time_t start1, end1;
+        //time (&start1);
+      
+        pSt->grep_flows_for_chunks();
+
+        cout << "-----" << endl;
+        cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+        cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+        cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+        cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+	cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+        cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+        cout << "~~~~~" << endl;
+        //time (&end1);
+        //double dif1 = difftime (end1, start1);
+        //cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+    free(net);
+}
+
+void 
+run_pcap_live_wifi ()
+{
+  //char *dev = "lo";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    h_pcap = pcap_open_live(dev, CAPTURE_BUF_SIZE, 1, 10000, errbuf);
+  
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+  
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+    while(1) {
+      pcap_dispatch(h_pcap, g_run_options.num_pkts, my_callback_wifi, (u_char *)pSt);
+      
+      time_t start1, end1;
+      time (&start1);
+      
+      pSt->grep_flows_for_chunks();
+      
+      time (&end1);
+      double dif1 = difftime (end1, start1);
+      cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+      
+    }
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+    delete pSt;
+}
+
+void
+run_pcap_offline ()
+{
+    //char *dev = "eth0";
+  char *dev = g_run_options.interface;
+  char errbuf[PCAP_ERRBUF_SIZE]; // 256B long
+  pcap_t* h_pcap;
+  struct bpf_program fp;      /* hold compiled program     */
+  bpf_u_int32 maskp;          /* subnet mask               */
+  bpf_u_int32 netp;           /* ip                        */
+  
+    cout << "dev is " << dev << endl;  
+    /* ask pcap for the network address and mask of the device */
+    pcap_lookupnet(dev, &netp, &maskp, errbuf);
+  
+    /* Open device for reading.
+       If the len of the packet captured < BUFSIZ (8K?), return only BUFSIZ worth of info
+       NOTE: promiscuous mode
+    */
+    //h_pcap = pcap_open_offline("./dot_test_2.dump", errbuf);
+    //h_pcap = pcap_open_offline("./dotdump", errbuf);
+    //h_pcap = pcap_open_offline("./wifidump", errbuf);
+    h_pcap = pcap_open_offline("./dump2", errbuf);
+
+    if(h_pcap == NULL)
+        {
+            cout << "pcap_open_live(): " << errbuf << endl;
+            exit(1);
+        }
+
+    /*
+    int datalink = pcap_datalink(h_pcap);
+    if (datalink != DLT_IEEE802_11) {
+        cout << "warning: unrecognized datalink type: " << pcap_datalink_val_to_name(datalink) << endl;
+        exit(1);
+    }
+    */
+
+    /* Lets try and compile the program... non-optimized */
+    if(pcap_compile(h_pcap, &fp, "tcp and not port 22 and not port 6010", 0, netp) == -1) {
+        cerr << "Error calling pcap_compile" << endl;
+        exit(1);
+    }
+  
+    /* set the compiled program as the filter */
+    if(pcap_setfilter(h_pcap, &fp) == -1) {
+        cerr << "Error setting filter" << endl;
+        exit(1);
+    }
+  
+    /* ... and loop */
+    SniffTcp* pSt = new SniffTcp(g_run_options.socket);
+  
+    pcap_loop(h_pcap, -1, my_callback_ethernet, (u_char *)pSt);
+    //pcap_loop(h_pcap, -1, my_callback_wifi, (u_char *)pSt);
+
+    time_t start1, end1;
+    time (&start1);
+
+    cout << "!!!!! Done with pcap_loop - in grep_flows_for_chunks !!!!!" << endl;
+    pSt->grep_flows_for_chunks();
+      
+    time (&end1);
+    double dif1 = difftime (end1, start1);
+    cout << "time in grep_flows_for_chunk() call=" << dif1 << endl;
+
+    /* cleanup */
+    pcap_freecode(&fp);
+    pcap_close(h_pcap);
+  
+        cout << "-----" << endl;
+        cout << "numPacketsCaptured = " << pSt->numPacketsCaptured << endl;
+        cout << "numBytesOfTcpPacketsCaptured = " << pSt->numBytesOfTcpPacketsCaptured << endl;
+        cout << "numChunksSniffed = " << pSt->numChunksSniffed << endl;
+        cout << "numBytesOfChunksSniffed = " << pSt->numBytesOfChunksSniffed << endl;
+	cout << "numTcpPacketsCaptured = " << pSt->numTcpPacketsCaptured << endl;
+        cout << "numDuplicateBytes = " << pSt->numDuplicateBytes << endl;
+        cout << "~~~~~" << endl;
+    delete pSt;
+}
+
+void print_usage () 
+{
+  cout << "Usage: sudo ./binary_name" << endl
+       << "              numpackets"  << endl
+       << "              interface"   << endl
+       << "              unix_socket_fqn" << endl 
+       << "              mode" << endl
+       << "              self_interface_ip_to_ignore" << endl
+       << "              multi_chances [0 | 1    default = 1]" << endl;
+  //cout << "mode => 0 = offline | 1 = online | 2 = offline+online | 3 = online_wifi | 4 = offline+online_wifi" << endl;
+  cout << "mode => 0 = offline | 1 = online | 2 = offline+online" << endl;
+  cout << "e.g.: sudo ./sniffTcp 1000 lo /tmp/gtcd_sniff.sock 1 128.2.223.103 1" << endl;
+}
+
+bool parse_command_line_args (int argc, char **argv)
+{
+  if (argc < 6) {
+    return false;
+  }
+  g_run_options.num_pkts = atoi(argv[1]);
+  g_run_options.interface = argv[2];
+  g_run_options.socket = argv[3];
+  switch (atoi(argv[4])) {
+  case 0:
+    g_run_options.mode = OFFLINE;
+    break;
+  case 1:
+    g_run_options.mode = ONLINE;
+    break;
+  case 2:
+    g_run_options.mode = OFFLINE_ONLINE;
+    break;
+  case 3:
+    g_run_options.mode = ONLINE_WIFI;
+    break;
+  case 4:
+    g_run_options.mode = OFFLINE_ONLINE_WIFI;
+    break;
+  default:
+    return false;
+  }
+  g_run_options.ip_to_ignore = argv[5];
+  if (argc == 7) {
+    g_run_options.multi_chance = atoi (argv[6]);
+  }
+  return true;
+}
+
+int main(int argc, char **argv)
+{
+    //printf("Sizeof unsinged int = %d\n", sizeof(u_int));
+  
+    /* grab a device to peek into ... */
+    /*
+      dev = pcap_lookupdev(errbuf);
+      if(dev == NULL)
+      {
+      printf("%s\n", errbuf);
+      exit(1);
+      }
+    */
+  
+  if (!parse_command_line_args (argc, argv)) {
+    print_usage ();
+    return 0;
+  }
+  if (g_run_options.multi_chance == 0) {
+    g_multi_chances = false;
+  }
+  if (g_run_options.mode == OFFLINE_ONLINE_WIFI) {
+    // run_pcap_offline();
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == ONLINE_WIFI) {
+    // run_pcap_live_wifi(); 
+  }
+  else if (g_run_options.mode == OFFLINE_ONLINE) {
+    run_pcap_offline ();
+    run_pcap_live (); 
+  }
+  else if (g_run_options.mode == ONLINE) {
+    run_pcap_live (); 
+  }
+  else {
+    run_pcap_offline ();
+  }
+  
+  cout << endl << "Finished" << endl;
+  return 0;
+}
+
+
+extern guint32 crc32_802(const guint8 *buf, guint len);
+
+/* Translate Ethernet address, as seen in struct ether_header, to type MAC. */
+static inline MAC ether2MAC(const uint8_t * ether)
+{
+    return MAC(ether);
+}
+
+/* Extract header length. */
+u_int8_t SniffTcp::extract_header_length(u_int16_t fc)
+{
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            return MGMT_HDRLEN;
+        case T_CTRL:
+            switch (FC_SUBTYPE(fc)) {
+                case CTRL_PS_POLL:
+                    return CTRL_PS_POLL_HDRLEN;
+                case CTRL_RTS:
+                    return CTRL_RTS_HDRLEN;
+                case CTRL_CTS:
+                    return CTRL_CTS_HDRLEN;
+                case CTRL_ACK:
+                    return CTRL_ACK_HDRLEN;
+                case CTRL_CF_END:
+                    return CTRL_END_HDRLEN;
+                case CTRL_END_ACK:
+                    return CTRL_END_ACK_HDRLEN;
+                default:
+                    return 0;
+            }
+        case T_DATA:
+            return (FC_TO_DS(fc) && FC_FROM_DS(fc)) ? 30 : 24;
+        default:
+            return 0;
+    }
+}
+
+void SniffTcp::handle_80211(const u_char* packet, u_int len) 
+{
+    if (len < 2) {
+        return;
+    }
+
+    u_int16_t fc = EXTRACT_LE_16BITS(packet);       //frame control
+    u_int hdrlen = extract_header_length(fc);
+
+    if (len < IEEE802_11_FC_LEN || len < hdrlen) {
+	//cbs->Handle80211Unknown(t, fc, packet, len);
+        //cout << "boo" << endl;
+        return;
+    }
+
+    bool fcs_ok = false;
+    if (Check80211FCS()) {
+	if (len < hdrlen + 4) {
+	    //cerr << "too short to have fcs!" << endl;
+	} else {
+	    // assume fcs is last 4 bytes (?)
+	    u_int32_t fcs_sent = EXTRACT_32BITS(packet+len-4);
+	    u_int32_t fcs = crc32_802(packet, len-4);
+
+	    /*
+	    if (fcs != fcs_sent) {
+		cerr << "bad fcs: ";
+		fprintf (stderr, "%08x != %08x\n", fcs_sent, fcs); 
+	    }
+	    */
+	    
+	    fcs_ok = (fcs == fcs_sent);
+	}
+    }
+
+    // fill in current_frame: type, sn
+    switch (FC_TYPE(fc)) {
+        case T_MGMT:
+            //cout << "mgmt frame" << endl;
+            break;
+        case T_DATA:
+            // TODO :: do the magic!
+            cout << "data frame" << endl;
+            handle_data_frame(packet, len, fc);
+            break;
+        case T_CTRL:
+            //cout << "ctrl frame" << endl;
+            break;
+        default:
+            break;
+    }
+}
+
+void SniffTcp::handle_data_frame(const u_char *ptr, int len, u_int16_t fc)
+{
+    u_int16_t seq_ctl;
+    u_int16_t seq;
+    u_int8_t  frag;
+
+    u_int16_t du = EXTRACT_LE_16BITS(ptr+2);        //duration
+
+    seq_ctl = pletohs(ptr + 22);
+    seq = COOK_SEQUENCE_NUMBER(seq_ctl);
+    frag = COOK_FRAGMENT_NUMBER(seq_ctl);
+
+    bool body = true;
+    int hdrlen = 0;
+
+    if (!FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* ad hoc IBSS */
+        cout << "ad hoc IBSS" << endl;
+	data_hdr_ibss_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	// AMAR:: cbs->Handle80211(t, fc, MAC::null, MAC::null, MAC::null, MAC::null, fcs_ok);
+	// XXX fcs
+	// AMAR:: cbs->Handle80211DataIBSS(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+	body = false;
+    } else if (!FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* frame from AP to STA */
+        cout << "frame from AP to STA" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 16);
+	hdr.da = ether2MAC(ptr + 4);
+	hdr.bssid = ether2MAC(ptr + 10);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataFromAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && !FC_FROM_DS(fc)) {
+	/* frame from STA to AP */
+        cout << "frame from STA to AP" << endl;
+	data_hdr_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.sa = ether2MAC(ptr + 10);
+	hdr.da = ether2MAC(ptr + 16);
+	hdr.bssid = ether2MAC(ptr + 4);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, MAC::null, MAC::null, fcs_ok);
+	// AMAR:: cbs->Handle80211DataToAP(t, &hdr, ptr+DATA_HDRLEN, len-DATA_HDRLEN);
+	hdrlen = DATA_HDRLEN;
+    } else if (FC_TO_DS(fc) && FC_FROM_DS(fc)) {
+	/* WDS */
+        cout << "WDS" << endl;
+	data_hdr_wds_t hdr;
+	hdr.fc = fc;
+	hdr.duration = du;
+	hdr.seq = seq;
+	hdr.frag = frag;
+	hdr.ra = ether2MAC(ptr+4);
+	hdr.ta = ether2MAC(ptr+10);
+	hdr.da = ether2MAC(ptr+16);
+	hdr.da = ether2MAC(ptr+24);
+	// AMAR:: cbs->Handle80211(t, fc, hdr.sa, hdr.da, hdr.ra, hdr.ta, fcs_ok);
+	// AMAR:: cbs->Handle80211DataWDS(t, &hdr, ptr+DATA_WDS_HDRLEN, len-DATA_WDS_HDRLEN);
+	hdrlen = DATA_WDS_HDRLEN;
+    }
+
+    if (body) {
+	if (FC_WEP(fc)) {
+	    //handle_wep(t, cbs, ptr+hdrlen, len-hdrlen-4 /* FCS */);
+            cout << "who need wep?" << endl;
+	} else {
+            cout << "lls finally!" << endl;
+	    handle_llc(ptr+hdrlen, len-hdrlen-4 /* FCS */);
+	}
+    }
+}
+
+void SniffTcp::handle_llc(const u_char *ptr, int len)
+{
+    if (len < 7) {
+	// truncated header!
+        return;
+    }
+
+    // Jeff: XXX This assumes ethernet->80211 llc encapsulation and is
+    // NOT correct for all forms of LLC encapsulation. See print-llc.c
+    // in tcpdump for a more complete parsing of this header.
+
+    llc_hdr_t hdr;
+    hdr.dsap = EXTRACT_LE_8BITS(ptr);
+    hdr.ssap = EXTRACT_LE_8BITS(ptr + 1);
+    hdr.control = EXTRACT_LE_8BITS(ptr + 2);
+    hdr.oui = EXTRACT_24BITS(ptr + 3);
+    hdr.type = EXTRACT_16BITS(ptr + 6);
+
+    if (hdr.oui != OUI_ENCAP_ETHER && hdr.oui != OUI_CISCO_90) {
+        cout << "Not encapsulated Ethernet and not Cisco protocols." << endl;
+        return;
+    }
+
+    ptr += 8;
+    len -= 8;
+
+    //cbs->HandleLLC(t, &hdr, ptr, len);
+
+    switch (hdr.type) {
+        case ETHERTYPE_IP:
+            // TODO :: call something similar to
+            cout << "DATA!" << endl;
+            // handle_ip(len, ptr);
+            break;
+        default:
+            break;
+    }
+}
+
+const u_char *
+SniffTcp::rpc_header_in_stream (const u_char *payload, int len) 
+{
+  for (int i = 0; i < len; i++) {
+    if (payload[i] == RPC_HEADER) {
+      if (memcmp((payload + i + 8), mask, mask_size_in_bytes) == 0)
+	return (payload + i);
+    }
+  }
+  return NULL;
+}
+
+ void print_chunk_id (string *s) 
+{
+  dot_desc id;
+  id.set((char *) s->data(), s->length());
+  warn << "Chunk id = " << id << " \n";
+}
+
+dot_desc string_to_dot_desc (string s)
+{
+  dot_desc id;
+  id.set((char *) s.data(), s.length());
+  return id;
+}
+
+pair<string*, int>* SniffTcp::getChunkId(const u_char *payload, int len)
+{
+  // should return NULL if chunkId not found in the payload
+  
+  //return new pair<string*, int>(new string("hola!"), 0);
+  const u_char *rpc_buffer = rpc_header_in_stream (payload, len);
+  if (rpc_buffer == NULL) {
+    return NULL;
+  }
+  string *s = new string();
+  int rpc_offset = rpc_buffer - payload;
+  pair<string *, int> *p;
+
+  /*
+#if 1
+  dot_chunk_res_t chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return false;
+  }
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+#else 
+  xfergtc_get_chunk_res chunk_res;
+  if (!extract_chunk_response (rpc_buffer, &chunk_res)) {
+    return NULL;
+  }
+  warn << "getChunkId () " << chunk_res.resok->chunk_id << " in stream \n";
+  s->append (chunk_res.resok->chunk_id.base(), chunk_res.resok->chunk_id.size());
+#endif 
+  */
+
+
+
+  int payload_length = get_length_from_byte_stream ((const char *)rpc_buffer);
+  if (payload_length < MIN_PAYLOAD_LENGTH) {
+      return false;
+  }
+  const u_char *tmp = rpc_buffer + DOT_OFFSET_FIELD_FROM_RPC_HEADER;
+
+  dot_chunk_res_t chunk_res;
+  chunk_res.chunk_id_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN));  
+  if (chunk_res.chunk_id_len != LEN_OF_CHUNK_ID) {
+      return NULL;
+  }
+
+  chunk_res.chunk_id_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD; // skip over chunk_id_len (4 bytes)
+  chunk_res.chunk_data_len = ntohl(*(unsigned int *)(tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID)); //(tmp + 32)
+  if (chunk_res.chunk_data_len < MIN_CHUNK_SIZE) {
+      return NULL;
+  }
+  chunk_res.chunk_data_base = tmp + DOT_OFFSET_FIELD_LEN + CHUNK_ID_LEN_FIELD + LEN_OF_CHUNK_ID + CHUNK_LEN_FIELD; //(tmp + 36)
+
+  s->append ((char *)chunk_res.chunk_id_base, chunk_res.chunk_id_len);
+  p = new pair<string *, int>(s, rpc_offset);  
+#ifdef AMAR_DEBUG_1
+  warn << "getChunkId:" <<  "will return pair (" << string_to_dot_desc (*(p->first)) << "," << p->second << ")\n";  
+#endif // AMAR_DEBUG_1
+  return p;
+}
+
+/*
+int SniffTcp::getChunkLength(const u_char *payload, int len) {
+    return get_length_from_byte_stream(payload);
+    //return 16384; // 16K
+}
+*/
diff -Naur src_dot_original/sniffer/SniffTcpv2.h src/sniffer/SniffTcpv2.h
--- src_dot_original/sniffer/SniffTcpv2.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/SniffTcpv2.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,320 @@
+#ifndef _SNIFF_TCP
+#define _SNIFF_TCP 1
+
+
+#include "async.h"
+#include "amisc.h"
+#include "arpc.h"
+#include "xdrmisc.h"
+
+#include "gtc.h"
+#include "snifferPlugin_tcp_prot.h"
+#include "xferPlugin_gtc_prot.h"
+
+#include "gtc_prot.h"
+#include "chunkerPlugin.h"
+
+#include "flow_id.h"
+#include "contiguous_block.h"
+#include "reconstructed_chunk.h"
+
+#include "extract.h"
+#include "types.h"
+#include "util.h"
+#include "ieee802_11.h"
+#include "llc.h"
+#include "oui.h"
+
+#include <map>
+#include <vector>
+#include <list>
+#include <string>
+#include <pcap.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <net/ethernet.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h> 
+#include <netinet/ether.h> 
+#include <netinet/tcp.h> 
+//#include <time.h>
+
+//using namespace std;
+
+/* tcpdump header (ether.h) defines ETHER_HDRLEN) */
+#ifndef ETHER_HDRLEN
+#define ETHER_HDRLEN 14
+#endif
+
+#ifndef CAPTURE_BUF_SIZE
+#define CAPTURE_BUF_SIZE 32768
+#endif
+
+//#define MIN_CHUNK_SIZE 0x1000 // 4 KB
+#define MIN_CHUNK_SIZE 0x400 // 1 KB
+#define MIN_PAYLOAD_LENGTH (MIN_CHUNK_SIZE + RPC_HEADER_LEN - 4)
+
+//#define AMAR_DEBUG 1
+//#define AMAR_DEBUG_PAYLOAD 1
+
+/*
+          IP HEADER
+
+           0                   1                   2                   3   
+           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |Version|  IHL  |Type of Service|          Total Length         |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |         Identification        |Flags|      Fragment Offset    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |  Time to Live |    Protocol   |         Header Checksum       |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                       Source Address                          |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Destination Address                        |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                    Options                    |    Padding    |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        
+ * Structure of an ip header, devoid of options.
+ * Stolen from tcpdump source
+ */
+struct sniff_ip {
+	u_int8_t	ip_vhl;		/* header length, version */
+#define IP_V(ip)	(((ip)->ip_vhl & 0xf0) >> 4)
+#define IP_HL(ip)	((ip)->ip_vhl & 0x0f)
+	u_int8_t	ip_tos;		/* type of service */
+	u_int16_t	ip_len;		/* total length */
+	u_int16_t	ip_id;		/* identification */
+	u_int16_t	ip_off;		/* fragment offset field */
+#define	IP_DF 0x4000			/* dont fragment flag */
+#define	IP_MF 0x2000			/* more fragments flag */
+#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */
+	u_int8_t	ip_ttl;		/* time to live */
+	u_int8_t	ip_p;		/* protocol */
+	u_int16_t	ip_sum;		/* checksum */
+	struct	in_addr ip_src,ip_dst;	/* source and dest address */
+};
+
+
+
+/* 
+                            TCP Header Format
+
+    0                   1                   2                   3   
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |          Source Port          |       Destination Port        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                        Sequence Number                        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Acknowledgment Number                      |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |  Data |           |U|A|P|R|S|F|                               |
+   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
+   |       |           |G|K|H|T|N|N|                               |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |           Checksum            |         Urgent Pointer        |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                    Options                    |    Padding    |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                             data                              |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+*/
+
+//typedef u_int tcp_seq;
+
+struct sniff_tcp {
+    u_short th_sport;	/* source port */
+    u_short th_dport;	/* destination port */
+    tcp_seq th_seq;	/* sequence number */
+    tcp_seq th_ack;	/* acknowledgement number */
+    u_char th_offx2;	/* data offset, rsvd */
+#define TH_OFF(th)	(((th)->th_offx2 & 0xf0) >> 4)
+    u_char th_flags;
+#define TH_FIN 0x01
+#define TH_SYN 0x02
+#define TH_RST 0x04
+#define TH_PUSH 0x08
+#define TH_ACK 0x10
+#define TH_URG 0x20
+#define TH_ECE 0x40
+#define TH_CWR 0x80
+#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
+    u_short th_win;	/* window */
+    u_short th_sum;	/* checksum */
+    u_short th_urp;	/* urgent pointer */
+};
+
+/* from ethereal packet-prism.c */
+#define pletohs(p)  ((u_int16_t)					\
+		     ((u_int16_t)*((const u_int8_t *)(p)+1)<<8|		\
+		      (u_int16_t)*((const u_int8_t *)(p)+0)<<0))
+#define pntohl(p)   ((u_int32_t)*((const u_int8_t *)(p)+0)<<24|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+1)<<16|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+2)<<8|	\
+		     (u_int32_t)*((const u_int8_t *)(p)+3)<<0)
+#define COOK_FRAGMENT_NUMBER(x) ((x) & 0x000F)
+#define COOK_SEQUENCE_NUMBER(x) (((x) & 0xFFF0) >> 4)
+/* end ethereal code */
+
+struct dot_chunk_res_t {
+  const u_char *chunk_id_base;
+  unsigned int chunk_id_len;
+  const u_char *chunk_data_base;
+  unsigned int chunk_data_len;
+};
+class ChunkInfo {
+	public:
+ 		
+		string chunk_id; 
+ 		tcp_seq s_seq_num;
+ 		int chunk_length;
+
+		ChunkInfo(string c_id, tcp_seq seq, int length) {
+
+			chunk_id = c_id;
+			s_seq_num = seq; 
+			chunk_length = length; 
+
+		}
+
+};
+
+
+class SniffTcp {
+ protected:
+    std::vector< pair< FlowId*, std::list<ContiguousBlock*>* >* >* p_flow_list;
+    char mask[24];
+    unsigned int mask_size_in_bytes;
+    ptr <aclnt> sniffer_c;
+
+    // NEW - START
+    map< string, std::list<ChunkInfo> > flow_chunk_map;
+
+    map< string, ReconstructedChunk* > chunkId_reconstructedChunk_map;
+    // NEW - END
+
+    struct timeval *g_p_start_time, *g_p_end_time;
+    struct timeval *g_p_with_cid_start_time, *g_p_with_cid_end_time;
+    struct timeval *g_p_without_cid_start_time, *g_p_without_cid_end_time;
+    struct timeval *g_p_deal_with_candidates_start_time, *g_p_deal_with_candidates_end_time;
+    struct timeval *g_p_cid_iteration_start_time, *g_p_cid_iteration_end_time;
+    struct timeval *g_p_cid_iteration_fit_start_time, *g_p_cid_iteration_fit_end_time;
+    long deal_delta_t, cid_iter_t, cid_iter_fit_t;
+
+ public:
+  
+    SniffTcp(const char* s);
+    SniffTcp(SniffTcp& sniffer);
+    virtual ~SniffTcp();
+  
+    int numChunksSniffed;
+    int numPacketsCaptured;
+    int numTcpPacketsCaptured;
+    unsigned long numBytesOfTcpPacketsCaptured;
+    unsigned long numBytesOfChunksSniffed;
+    unsigned long numDuplicateBytes;
+  
+    int get_flow_offset(FlowId* pFid);
+
+    /*
+     * print data in rows of 16 bytes: offset   hex   ascii
+     *
+     * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+     */
+    void print_hex_ascii_line(const u_char *payload, int len, int offset);
+
+    void print_payload(const u_char *payload, int len);
+
+    u_int16_t handle_ethernet(const struct pcap_pkthdr* pkthdr, const u_char* packet);
+
+    void handle_ip(u_int length, const u_char* ip_packet);
+
+    //void grep_contiguous_block_for_chunks(ContiguousBlock *pcb);
+    void grep_contiguous_block_for_chunks(ContiguousBlock *pcb, std::list<ContiguousBlock*>::iterator i, std::list<ContiguousBlock*>* stream_block);
+    void grep_flows_for_chunks();
+
+    int get_length_from_byte_stream(const char *b);
+    void send_chunk_to_sniffer_plugin (const char *rpc_buffer);
+    void put_chunk_cb (ref <sniffer_tcp_put_chunk_res>, clnt_stat);
+
+    // Stolen and modified from Jeff's code
+    bool Check80211FCS() { return true; }
+    u_int8_t extract_header_length(u_int16_t fc);
+    void handle_80211(const u_char* packet, u_int len);
+    void handle_data_frame(const u_char *ptr, int len, u_int16_t fc);
+    void handle_llc(const u_char *ptr, int len);
+
+
+    void deal_with_pkt_without_chunkid(FlowId *pFid, string* pFidStr,
+                                       const u_char *payload, int size_payload, 
+                                       tcp_seq seq_num);
+
+	void deal_with_pkt_without_chunkid2(FlowId *pFid, string* pFidStr,
+                                       const u_char *payload, int size_payload, 
+                                       tcp_seq seq_num);
+
+    bool deal_with_candidates_for_chunk(ReconstructedChunk *p_rc,
+                                       FlowId *pFid, string* pFidStr);
+
+    bool fill_gaps_in_chunk(ReconstructedChunk *p_rc, FlowId *pFid, string* pFidStr, 
+                            const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    void insert(FlowId *pFid, string* pFidStr, 
+                const u_char *payload, int size_payload, tcp_seq seq_num);
+
+
+    pair<string*, int>* getChunkId(const u_char *payload, int len);
+    const u_char * rpc_header_in_stream (const u_char *payload, int len);
+    bool extract_chunk_response (const u_char *rpc_header, xfergtc_get_chunk_res *chunk_res);
+    bool extract_chunk_response (const u_char *rpc_header, dot_chunk_res_t *chunk_res);
+    //int getChunkLength(const u_char *payload, int len);
+};
+
+/*
+ * workhorse function
+ */ 
+static void my_callback_wifi(u_char* arg, 
+                             const struct pcap_pkthdr* pkthdr, 
+                             const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int frameOffset = 0;
+        u_int frameLen = pkthdr->caplen;
+	pSt->handle_80211(packet + frameOffset, frameLen);
+    }
+}
+
+static void my_callback_ethernet(u_char* arg, 
+                                 const struct pcap_pkthdr* pkthdr, 
+                                 const u_char* packet)
+{
+    SniffTcp* pSt = (SniffTcp*) arg;
+    if (pSt != 0) {
+        u_int16_t type = pSt->handle_ethernet(pkthdr, packet);
+
+        if(type == ETHERTYPE_IP) {
+            /* handle IP packet */
+ 	    // cout << "this is an IP packet" << endl;
+
+            pSt->handle_ip(pkthdr->caplen - ETHER_HDRLEN, (const u_char *)packet + ETHER_HDRLEN);
+        }
+        else if(type == ETHERTYPE_ARP) {
+            // handle arp packet
+        }
+        else if(type == ETHERTYPE_REVARP) {
+            // handle reverse arp packet
+        }
+    }
+}
+
+#endif //_SNIFF_TCP
diff -Naur src_dot_original/sniffer/tcp.temp src/sniffer/tcp.temp
--- src_dot_original/sniffer/tcp.temp	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/tcp.temp	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,44 @@
+                    |                  ?
+// GET DESCRIPTORS - REQUEST
+00000   80 00 00 4c 24 e5 94 45  00 00 00 00 00 00 00 02    ...L$..E........
+00016   00 06 1a 80 00 00 00 01  00 00 00 06 00 00 00 00    ................
+00032   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 14    ................
+00048   d2 29 21 2d 8b cb 62 23  bc e4 31 cc 98 14 06 2a    .)!-..b#..1....*
+00064   f9 7b c1 62 00 00 00 00  00 00 00 00 00 00 00 00    .{.b............
+ 
+                    |                  ?
+// GET DESCRIPTORS - RESPONSE
+00000   80 00 00 70 24 e5 94 45  00 00 00 01 00 00 00 00    ...p$..E........
+00016   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 01    ................
+00032   00 00 00 00 00 00 00 00  00 00 00 02 00 00 00 02    ................
+00048   00 00 00 14 b2 05 e2 17  35 87 cd 79 96 0b 44 33    ........5..y..D3
+00064   23 34 65 9d 9f 45 7b 0e  00 00 40 00 00 00 00 00    #4e..E{...@.....
+00080   00 00 00 14 f4 13 77 ef  da 45 ee 79 55 a6 3b 37    ......w..E.yU.;7
+00096   d2 b5 75 65 a9 38 ab d2  00 00 16 fb 00 00 00 00    ..ue.8..........
+00112   00 00 00 01 80 00 40 30  2c 23 51 da 00 00 00 01    ......@0,#Q.....
+
+// GET CHUNK REQUEST - 2 CHUNKS REQUESTED
+00080   80 00 00 50 2c 23 51 da  00 00 00 00 00 00 00 02    ...P,#Q.........
+00096   00 06 1a 80 00 00 00 01  00 00 00 05 00 00 00 00    ................
+00112   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 14    ................
+00128   b2 05 e2 17 35 87 cd 79  96 0b 44 33 23 34 65 9d    ....5..y..D3#4e.
+00144   9f 45 7b 0e 00 00 40 00  00 00 00 00 00 00 00 00    .E{...@.........
+00160   00 00 00 00 80 00 00 50  2b 48 7c c2 00 00 00 00    .......P+H|.....
+00176   00 00 00 02 00 06 1a 80  00 00 00 01 00 00 00 05    ................
+00192   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
+00208   00 00 00 14 f4 13 77 ef  da 45 ee 79 55 a6 3b 37    ......w..E.yU.;7
+00224   d2 b5 75 65 a9 38 ab d2  00 00 16 fb 00 00 00 00    ..ue.8..........
+00240   00 00 00 00 00 00 00 00                             ........
+
+
+// GET CHUNK RESPONSE - 1st chunk
+00112   00 00 00 01 80 00 40 30  2c 23 51 da 00 00 00 01    ......@0,#Q.....
+00128   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
+00144   00 00 00 01 00 00 00 00  00 00 00 00 00 00 40 00    ..............@.
+00160   23 20 4d 61 6b 65 66 69  6c 65 2e 69 6e 20 67 65    # Makefile.in ge
+
+// second chunk
+16544   00 00 00 01 00 00 00 00  80 00 17 2c 2b 48 7c c2    ...........,+H|.
+16560   00 00 00 01 00 00 00 00  00 00 00 00 00 00 00 00    ................
+16576   00 00 00 00 00 00 00 01  00 00 00 00 00 00 00 00    ................
+16592   00 00 16 fb 64 69 73 74  64 69 72 29 0a 0a 64 69    ....distdir)..di
diff -Naur src_dot_original/sniffer/tcp.text src/sniffer/tcp.text
--- src_dot_original/sniffer/tcp.text	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/tcp.text	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,1697 @@
+*****
+169.254.8.27:15000 => 169.254.8.27:38918
+# of ContiguousBlocks = 1
+size of str = 22488
+00000   80 00 00 70 24 e5 94 45  00 00 00 01 00 00 00 00    ...p$..E........
+00016   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 01    ................
+00032   00 00 00 00 00 00 00 00  00 00 00 02 00 00 00 02    ................
+00048   00 00 00 14 b2 05 e2 17  35 87 cd 79 96 0b 44 33    ........5..y..D3
+00064   23 34 65 9d 9f 45 7b 0e  00 00 40 00 00 00 00 00    #4e..E{...@.....
+00080   00 00 00 14 f4 13 77 ef  da 45 ee 79 55 a6 3b 37    ......w..E.yU.;7
+00096   d2 b5 75 65 a9 38 ab d2  00 00 16 fb 00 00 00 00    ..ue.8..........
+00112   00 00 00 01 80 00 40 30  2c 23 51 da 00 00 00 01    ......@0,#Q.....
+00128   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
+00144   00 00 00 01 00 00 00 00  00 00 00 00 00 00 40 00    ..............@.
+00160   23 20 4d 61 6b 65 66 69  6c 65 2e 69 6e 20 67 65    # Makefile.in ge
+00176   6e 65 72 61 74 65 64 20  62 79 20 61 75 74 6f 6d    nerated by autom
+00192   61 6b 65 20 31 2e 39 2e  36 20 66 72 6f 6d 20 4d    ake 1.9.6 from M
+00208   61 6b 65 66 69 6c 65 2e  61 6d 2e 0a 23 20 4d 61    akefile.am..# Ma
+00224   6b 65 66 69 6c 65 2e 20  20 47 65 6e 65 72 61 74    kefile.  Generat
+00240   65 64 20 66 72 6f 6d 20  4d 61 6b 65 66 69 6c 65    ed from Makefile
+00256   2e 69 6e 20 62 79 20 63  6f 6e 66 69 67 75 72 65    .in by configure
+00272   2e 0a 0a 23 20 43 6f 70  79 72 69 67 68 74 20 28    ...# Copyright (
+00288   43 29 20 31 39 39 34 2c  20 31 39 39 35 2c 20 31    C) 1994, 1995, 1
+00304   39 39 36 2c 20 31 39 39  37 2c 20 31 39 39 38 2c    996, 1997, 1998,
+00320   20 31 39 39 39 2c 20 32  30 30 30 2c 20 32 30 30     1999, 2000, 200
+00336   31 2c 20 32 30 30 32 2c  0a 23 20 32 30 30 33 2c    1, 2002,.# 2003,
+00352   20 32 30 30 34 2c 20 32  30 30 35 20 20 46 72 65     2004, 2005  Fre
+00368   65 20 53 6f 66 74 77 61  72 65 20 46 6f 75 6e 64    e Software Found
+00384   61 74 69 6f 6e 2c 20 49  6e 63 2e 0a 23 20 54 68    ation, Inc..# Th
+00400   69 73 20 4d 61 6b 65 66  69 6c 65 2e 69 6e 20 69    is Makefile.in i
+00416   73 20 66 72 65 65 20 73  6f 66 74 77 61 72 65 3b    s free software;
+00432   20 74 68 65 20 46 72 65  65 20 53 6f 66 74 77 61     the Free Softwa
+00448   72 65 20 46 6f 75 6e 64  61 74 69 6f 6e 0a 23 20    re Foundation.# 
+00464   67 69 76 65 73 20 75 6e  6c 69 6d 69 74 65 64 20    gives unlimited 
+00480   70 65 72 6d 69 73 73 69  6f 6e 20 74 6f 20 63 6f    permission to co
+00496   70 79 20 61 6e 64 2f 6f  72 20 64 69 73 74 72 69    py and/or distri
+00512   62 75 74 65 20 69 74 2c  0a 23 20 77 69 74 68 20    bute it,.# with 
+00528   6f 72 20 77 69 74 68 6f  75 74 20 6d 6f 64 69 66    or without modif
+00544   69 63 61 74 69 6f 6e 73  2c 20 61 73 20 6c 6f 6e    ications, as lon
+00560   67 20 61 73 20 74 68 69  73 20 6e 6f 74 69 63 65    g as this notice
+00576   20 69 73 20 70 72 65 73  65 72 76 65 64 2e 0a 0a     is preserved...
+00592   23 20 54 68 69 73 20 70  72 6f 67 72 61 6d 20 69    # This program i
+00608   73 20 64 69 73 74 72 69  62 75 74 65 64 20 69 6e    s distributed in
+00624   20 74 68 65 20 68 6f 70  65 20 74 68 61 74 20 69     the hope that i
+00640   74 20 77 69 6c 6c 20 62  65 20 75 73 65 66 75 6c    t will be useful
+00656   2c 0a 23 20 62 75 74 20  57 49 54 48 4f 55 54 20    ,.# but WITHOUT 
+00672   41 4e 59 20 57 41 52 52  41 4e 54 59 2c 20 74 6f    ANY WARRANTY, to
+00688   20 74 68 65 20 65 78 74  65 6e 74 20 70 65 72 6d     the extent perm
+00704   69 74 74 65 64 20 62 79  20 6c 61 77 3b 20 77 69    itted by law; wi
+00720   74 68 6f 75 74 0a 23 20  65 76 65 6e 20 74 68 65    thout.# even the
+00736   20 69 6d 70 6c 69 65 64  20 77 61 72 72 61 6e 74     implied warrant
+00752   79 20 6f 66 20 4d 45 52  43 48 41 4e 54 41 42 49    y of MERCHANTABI
+00768   4c 49 54 59 20 6f 72 20  46 49 54 4e 45 53 53 20    LITY or FITNESS 
+00784   46 4f 52 20 41 0a 23 20  50 41 52 54 49 43 55 4c    FOR A.# PARTICUL
+00800   41 52 20 50 55 52 50 4f  53 45 2e 0a 0a 0a 73 72    AR PURPOSE....sr
+00816   63 64 69 72 20 3d 20 2e  0a 74 6f 70 5f 73 72 63    cdir = ..top_src
+00832   64 69 72 20 3d 20 2e 0a  0a 70 6b 67 64 61 74 61    dir = ...pkgdata
+00848   64 69 72 20 3d 20 24 28  64 61 74 61 64 69 72 29    dir = $(datadir)
+00864   2f 64 6f 74 0a 70 6b 67  6c 69 62 64 69 72 20 3d    /dot.pkglibdir =
+00880   20 24 28 6c 69 62 64 69  72 29 2f 64 6f 74 0a 70     $(libdir)/dot.p
+00896   6b 67 69 6e 63 6c 75 64  65 64 69 72 20 3d 20 24    kgincludedir = $
+00912   28 69 6e 63 6c 75 64 65  64 69 72 29 2f 64 6f 74    (includedir)/dot
+00928   0a 74 6f 70 5f 62 75 69  6c 64 64 69 72 20 3d 20    .top_builddir = 
+00944   2e 0a 61 6d 5f 5f 63 64  20 3d 20 43 44 50 41 54    ..am__cd = CDPAT
+00960   48 3d 22 24 24 7b 5a 53  48 5f 56 45 52 53 49 4f    H="$${ZSH_VERSIO
+00976   4e 2b 2e 7d 24 28 50 41  54 48 5f 53 45 50 41 52    N+.}$(PATH_SEPAR
+00992   41 54 4f 52 29 22 20 26  26 20 63 64 0a 49 4e 53    ATOR)" && cd.INS
+01008   54 41 4c 4c 20 3d 20 2f  75 73 72 2f 62 69 6e 2f    TALL = /usr/bin/
+01024   69 6e 73 74 61 6c 6c 20  2d 63 0a 69 6e 73 74 61    install -c.insta
+01040   6c 6c 5f 73 68 5f 44 41  54 41 20 3d 20 24 28 69    ll_sh_DATA = $(i
+01056   6e 73 74 61 6c 6c 5f 73  68 29 20 2d 63 20 2d 6d    nstall_sh) -c -m
+01072   20 36 34 34 0a 69 6e 73  74 61 6c 6c 5f 73 68 5f     644.install_sh_
+01088   50 52 4f 47 52 41 4d 20  3d 20 24 28 69 6e 73 74    PROGRAM = $(inst
+01104   61 6c 6c 5f 73 68 29 20  2d 63 0a 69 6e 73 74 61    all_sh) -c.insta
+01120   6c 6c 5f 73 68 5f 53 43  52 49 50 54 20 3d 20 24    ll_sh_SCRIPT = $
+01136   28 69 6e 73 74 61 6c 6c  5f 73 68 29 20 2d 63 0a    (install_sh) -c.
+01152   49 4e 53 54 41 4c 4c 5f  48 45 41 44 45 52 20 3d    INSTALL_HEADER =
+01168   20 24 28 49 4e 53 54 41  4c 4c 5f 44 41 54 41 29     $(INSTALL_DATA)
+01184   0a 74 72 61 6e 73 66 6f  72 6d 20 3d 20 24 28 70    .transform = $(p
+01200   72 6f 67 72 61 6d 5f 74  72 61 6e 73 66 6f 72 6d    rogram_transform
+01216   5f 6e 61 6d 65 29 0a 4e  4f 52 4d 41 4c 5f 49 4e    _name).NORMAL_IN
+01232   53 54 41 4c 4c 20 3d 20  3a 0a 50 52 45 5f 49 4e    STALL = :.PRE_IN
+01248   53 54 41 4c 4c 20 3d 20  3a 0a 50 4f 53 54 5f 49    STALL = :.POST_I
+01264   4e 53 54 41 4c 4c 20 3d  20 3a 0a 4e 4f 52 4d 41    NSTALL = :.NORMA
+01280   4c 5f 55 4e 49 4e 53 54  41 4c 4c 20 3d 20 3a 0a    L_UNINSTALL = :.
+01296   50 52 45 5f 55 4e 49 4e  53 54 41 4c 4c 20 3d 20    PRE_UNINSTALL = 
+01312   3a 0a 50 4f 53 54 5f 55  4e 49 4e 53 54 41 4c 4c    :.POST_UNINSTALL
+01328   20 3d 20 3a 0a 62 75 69  6c 64 5f 74 72 69 70 6c     = :.build_tripl
+01344   65 74 20 3d 20 69 36 38  36 2d 70 63 2d 6c 69 6e    et = i686-pc-lin
+01360   75 78 2d 67 6e 75 0a 68  6f 73 74 5f 74 72 69 70    ux-gnu.host_trip
+01376   6c 65 74 20 3d 20 69 36  38 36 2d 70 63 2d 6c 69    let = i686-pc-li
+01392   6e 75 78 2d 67 6e 75 0a  44 49 53 54 5f 43 4f 4d    nux-gnu.DIST_COM
+01408   4d 4f 4e 20 3d 20 52 45  41 44 4d 45 20 24 28 61    MON = README $(a
+01424   6d 5f 5f 63 6f 6e 66 69  67 75 72 65 5f 64 65 70    m__configure_dep
+01440   73 29 20 24 28 73 72 63  64 69 72 29 2f 4d 61 6b    s) $(srcdir)/Mak
+01456   65 66 69 6c 65 2e 61 6d  20 5c 0a 09 24 28 73 72    efile.am \..$(sr
+01472   63 64 69 72 29 2f 4d 61  6b 65 66 69 6c 65 2e 69    cdir)/Makefile.i
+01488   6e 20 24 28 73 72 63 64  69 72 29 2f 63 6f 6e 66    n $(srcdir)/conf
+01504   69 67 2e 68 2e 69 6e 20  5c 0a 09 24 28 74 6f 70    ig.h.in \..$(top
+01520   5f 73 72 63 64 69 72 29  2f 63 6f 6e 66 69 67 75    _srcdir)/configu
+01536   72 65 20 41 55 54 48 4f  52 53 20 43 4f 50 59 49    re AUTHORS COPYI
+01552   4e 47 20 43 68 61 6e 67  65 4c 6f 67 20 49 4e 53    NG ChangeLog INS
+01568   54 41 4c 4c 20 4e 45 57  53 20 5c 0a 09 63 6f 6d    TALL NEWS \..com
+01584   70 69 6c 65 20 63 6f 6e  66 69 67 2e 67 75 65 73    pile config.gues
+01600   73 20 63 6f 6e 66 69 67  2e 73 75 62 20 64 65 70    s config.sub dep
+01616   63 6f 6d 70 20 69 6e 73  74 61 6c 6c 2d 73 68 20    comp install-sh 
+01632   6c 74 6d 61 69 6e 2e 73  68 20 5c 0a 09 6d 69 73    ltmain.sh \..mis
+01648   73 69 6e 67 0a 73 75 62  64 69 72 20 3d 20 2e 0a    sing.subdir = ..
+01664   41 43 4c 4f 43 41 4c 5f  4d 34 20 3d 20 24 28 74    ACLOCAL_M4 = $(t
+01680   6f 70 5f 73 72 63 64 69  72 29 2f 61 63 6c 6f 63    op_srcdir)/acloc
+01696   61 6c 2e 6d 34 0a 61 6d  5f 5f 61 63 6c 6f 63 61    al.m4.am__acloca
+01712   6c 5f 6d 34 5f 64 65 70  73 20 3d 20 24 28 74 6f    l_m4_deps = $(to
+01728   70 5f 73 72 63 64 69 72  29 2f 61 63 69 6e 63 6c    p_srcdir)/acincl
+01744   75 64 65 2e 6d 34 20 5c  0a 09 24 28 74 6f 70 5f    ude.m4 \..$(top_
+01760   73 72 63 64 69 72 29 2f  63 6f 6e 66 69 67 75 72    srcdir)/configur
+01776   65 2e 61 63 0a 61 6d 5f  5f 63 6f 6e 66 69 67 75    e.ac.am__configu
+01792   72 65 5f 64 65 70 73 20  3d 20 24 28 61 6d 5f 5f    re_deps = $(am__
+01808   61 63 6c 6f 63 61 6c 5f  6d 34 5f 64 65 70 73 29    aclocal_m4_deps)
+01824   20 24 28 43 4f 4e 46 49  47 55 52 45 5f 44 45 50     $(CONFIGURE_DEP
+01840   45 4e 44 45 4e 43 49 45  53 29 20 5c 0a 09 24 28    ENDENCIES) \..$(
+01856   41 43 4c 4f 43 41 4c 5f  4d 34 29 0a 61 6d 5f 5f    ACLOCAL_M4).am__
+01872   43 4f 4e 46 49 47 5f 44  49 53 54 43 4c 45 41 4e    CONFIG_DISTCLEAN
+01888   5f 46 49 4c 45 53 20 3d  20 63 6f 6e 66 69 67 2e    _FILES = config.
+01904   73 74 61 74 75 73 20 63  6f 6e 66 69 67 2e 63 61    status config.ca
+01920   63 68 65 20 63 6f 6e 66  69 67 2e 6c 6f 67 20 5c    che config.log \
+01936   0a 20 63 6f 6e 66 69 67  75 72 65 2e 6c 69 6e 65    . configure.line
+01952   6e 6f 20 63 6f 6e 66 69  67 75 72 65 2e 73 74 61    no configure.sta
+01968   74 75 73 2e 6c 69 6e 65  6e 6f 0a 6d 6b 69 6e 73    tus.lineno.mkins
+01984   74 61 6c 6c 64 69 72 73  20 3d 20 24 28 69 6e 73    talldirs = $(ins
+02000   74 61 6c 6c 5f 73 68 29  20 2d 64 0a 43 4f 4e 46    tall_sh) -d.CONF
+02016   49 47 5f 48 45 41 44 45  52 20 3d 20 63 6f 6e 66    IG_HEADER = conf
+02032   69 67 2e 68 0a 43 4f 4e  46 49 47 5f 43 4c 45 41    ig.h.CONFIG_CLEA
+02048   4e 5f 46 49 4c 45 53 20  3d 0a 53 4f 55 52 43 45    N_FILES =.SOURCE
+02064   53 20 3d 0a 44 49 53 54  5f 53 4f 55 52 43 45 53    S =.DIST_SOURCES
+02080   20 3d 0a 52 45 43 55 52  53 49 56 45 5f 54 41 52     =.RECURSIVE_TAR
+02096   47 45 54 53 20 3d 20 61  6c 6c 2d 72 65 63 75 72    GETS = all-recur
+02112   73 69 76 65 20 63 68 65  63 6b 2d 72 65 63 75 72    sive check-recur
+02128   73 69 76 65 20 64 76 69  2d 72 65 63 75 72 73 69    sive dvi-recursi
+02144   76 65 20 5c 0a 09 68 74  6d 6c 2d 72 65 63 75 72    ve \..html-recur
+02160   73 69 76 65 20 69 6e 66  6f 2d 72 65 63 75 72 73    sive info-recurs
+02176   69 76 65 20 69 6e 73 74  61 6c 6c 2d 64 61 74 61    ive install-data
+02192   2d 72 65 63 75 72 73 69  76 65 20 5c 0a 09 69 6e    -recursive \..in
+02208   73 74 61 6c 6c 2d 65 78  65 63 2d 72 65 63 75 72    stall-exec-recur
+02224   73 69 76 65 20 69 6e 73  74 61 6c 6c 2d 69 6e 66    sive install-inf
+02240   6f 2d 72 65 63 75 72 73  69 76 65 20 5c 0a 09 69    o-recursive \..i
+02256   6e 73 74 61 6c 6c 2d 72  65 63 75 72 73 69 76 65    nstall-recursive
+02272   20 69 6e 73 74 61 6c 6c  63 68 65 63 6b 2d 72 65     installcheck-re
+02288   63 75 72 73 69 76 65 20  69 6e 73 74 61 6c 6c 64    cursive installd
+02304   69 72 73 2d 72 65 63 75  72 73 69 76 65 20 5c 0a    irs-recursive \.
+02320   09 70 64 66 2d 72 65 63  75 72 73 69 76 65 20 70    .pdf-recursive p
+02336   73 2d 72 65 63 75 72 73  69 76 65 20 75 6e 69 6e    s-recursive unin
+02352   73 74 61 6c 6c 2d 69 6e  66 6f 2d 72 65 63 75 72    stall-info-recur
+02368   73 69 76 65 20 5c 0a 09  75 6e 69 6e 73 74 61 6c    sive \..uninstal
+02384   6c 2d 72 65 63 75 72 73  69 76 65 0a 45 54 41 47    l-recursive.ETAG
+02400   53 20 3d 20 65 74 61 67  73 0a 43 54 41 47 53 20    S = etags.CTAGS 
+02416   3d 20 63 74 61 67 73 0a  44 49 53 54 46 49 4c 45    = ctags.DISTFILE
+02432   53 20 3d 20 24 28 44 49  53 54 5f 43 4f 4d 4d 4f    S = $(DIST_COMMO
+02448   4e 29 20 24 28 44 49 53  54 5f 53 4f 55 52 43 45    N) $(DIST_SOURCE
+02464   53 29 20 24 28 54 45 58  49 4e 46 4f 53 29 20 24    S) $(TEXINFOS) $
+02480   28 45 58 54 52 41 5f 44  49 53 54 29 0a 64 69 73    (EXTRA_DIST).dis
+02496   74 64 69 72 20 3d 20 24  28 50 41 43 4b 41 47 45    tdir = $(PACKAGE
+02512   29 2d 24 28 56 45 52 53  49 4f 4e 29 0a 74 6f 70    )-$(VERSION).top
+02528   5f 64 69 73 74 64 69 72  20 3d 20 24 28 64 69 73    _distdir = $(dis
+02544   74 64 69 72 29 0a 61 6d  5f 5f 72 65 6d 6f 76 65    tdir).am__remove
+02560   5f 64 69 73 74 64 69 72  20 3d 20 5c 0a 20 20 7b    _distdir = \.  {
+02576   20 74 65 73 74 20 21 20  2d 64 20 24 28 64 69 73     test ! -d $(dis
+02592   74 64 69 72 29 20 5c 0a  20 20 20 20 7c 7c 20 7b    tdir) \.    || {
+02608   20 66 69 6e 64 20 24 28  64 69 73 74 64 69 72 29     find $(distdir)
+02624   20 2d 74 79 70 65 20 64  20 21 20 2d 70 65 72 6d     -type d ! -perm
+02640   20 2d 32 30 30 20 2d 65  78 65 63 20 63 68 6d 6f     -200 -exec chmo
+02656   64 20 75 2b 77 20 7b 7d  20 27 3b 27 20 5c 0a 20    d u+w {} ';' \. 
+02672   20 20 20 20 20 20 20 20  26 26 20 72 6d 20 2d 66            && rm -f
+02688   72 20 24 28 64 69 73 74  64 69 72 29 3b 20 7d 3b    r $(distdir); };
+02704   20 7d 0a 44 49 53 54 5f  41 52 43 48 49 56 45 53     }.DIST_ARCHIVES
+02720   20 3d 20 24 28 64 69 73  74 64 69 72 29 2e 74 61     = $(distdir).ta
+02736   72 2e 67 7a 0a 47 5a 49  50 5f 45 4e 56 20 3d 20    r.gz.GZIP_ENV = 
+02752   2d 2d 62 65 73 74 0a 64  69 73 74 75 6e 69 6e 73    --best.distunins
+02768   74 61 6c 6c 63 68 65 63  6b 5f 6c 69 73 74 66 69    tallcheck_listfi
+02784   6c 65 73 20 3d 20 66 69  6e 64 20 2e 20 2d 74 79    les = find . -ty
+02800   70 65 20 66 20 2d 70 72  69 6e 74 0a 64 69 73 74    pe f -print.dist
+02816   63 6c 65 61 6e 63 68 65  63 6b 5f 6c 69 73 74 66    cleancheck_listf
+02832   69 6c 65 73 20 3d 20 66  69 6e 64 20 2e 20 2d 74    iles = find . -t
+02848   79 70 65 20 66 20 2d 70  72 69 6e 74 0a 41 43 4c    ype f -print.ACL
+02864   4f 43 41 4c 20 3d 20 24  7b 53 48 45 4c 4c 7d 20    OCAL = ${SHELL} 
+02880   2f 68 6f 6d 65 2f 61 70  68 61 6e 69 73 68 2f 6c    /home/aphanish/l
+02896   69 66 65 2f 72 65 73 65  61 72 63 68 2f 63 68 65    ife/research/che
+02912   63 6b 65 64 5f 6f 75 74  2f 6f 76 65 72 68 65 61    cked_out/overhea
+02928   72 2f 64 6f 74 5f 73 6e  61 70 5f 32 30 30 37 30    r/dot_snap_20070
+02944   32 30 36 2f 6d 69 73 73  69 6e 67 20 2d 2d 72 75    206/missing --ru
+02960   6e 20 61 63 6c 6f 63 61  6c 2d 31 2e 39 0a 41 4d    n aclocal-1.9.AM
+02976   44 45 50 5f 46 41 4c 53  45 20 3d 20 23 0a 41 4d    DEP_FALSE = #.AM
+02992   44 45 50 5f 54 52 55 45  20 3d 20 0a 41 4d 54 41    DEP_TRUE = .AMTA
+03008   52 20 3d 20 24 7b 53 48  45 4c 4c 7d 20 2f 68 6f    R = ${SHELL} /ho
+03024   6d 65 2f 61 70 68 61 6e  69 73 68 2f 6c 69 66 65    me/aphanish/life
+03040   2f 72 65 73 65 61 72 63  68 2f 63 68 65 63 6b 65    /research/checke
+03056   64 5f 6f 75 74 2f 6f 76  65 72 68 65 61 72 2f 64    d_out/overhear/d
+03072   6f 74 5f 73 6e 61 70 5f  32 30 30 37 30 32 30 36    ot_snap_20070206
+03088   2f 6d 69 73 73 69 6e 67  20 2d 2d 72 75 6e 20 74    /missing --run t
+03104   61 72 0a 41 52 20 3d 20  61 72 0a 41 55 54 4f 43    ar.AR = ar.AUTOC
+03120   4f 4e 46 20 3d 20 24 7b  53 48 45 4c 4c 7d 20 2f    ONF = ${SHELL} /
+03136   68 6f 6d 65 2f 61 70 68  61 6e 69 73 68 2f 6c 69    home/aphanish/li
+03152   66 65 2f 72 65 73 65 61  72 63 68 2f 63 68 65 63    fe/research/chec
+03168   6b 65 64 5f 6f 75 74 2f  6f 76 65 72 68 65 61 72    ked_out/overhear
+03184   2f 64 6f 74 5f 73 6e 61  70 5f 32 30 30 37 30 32    /dot_snap_200702
+03200   30 36 2f 6d 69 73 73 69  6e 67 20 2d 2d 72 75 6e    06/missing --run
+03216   20 61 75 74 6f 63 6f 6e  66 0a 41 55 54 4f 48 45     autoconf.AUTOHE
+03232   41 44 45 52 20 3d 20 24  7b 53 48 45 4c 4c 7d 20    ADER = ${SHELL} 
+03248   2f 68 6f 6d 65 2f 61 70  68 61 6e 69 73 68 2f 6c    /home/aphanish/l
+03264   69 66 65 2f 72 65 73 65  61 72 63 68 2f 63 68 65    ife/research/che
+03280   63 6b 65 64 5f 6f 75 74  2f 6f 76 65 72 68 65 61    cked_out/overhea
+03296   72 2f 64 6f 74 5f 73 6e  61 70 5f 32 30 30 37 30    r/dot_snap_20070
+03312   32 30 36 2f 6d 69 73 73  69 6e 67 20 2d 2d 72 75    206/missing --ru
+03328   6e 20 61 75 74 6f 68 65  61 64 65 72 0a 41 55 54    n autoheader.AUT
+03344   4f 4d 41 4b 45 20 3d 20  24 7b 53 48 45 4c 4c 7d    OMAKE = ${SHELL}
+03360   20 2f 68 6f 6d 65 2f 61  70 68 61 6e 69 73 68 2f     /home/aphanish/
+03376   6c 69 66 65 2f 72 65 73  65 61 72 63 68 2f 63 68    life/research/ch
+03392   65 63 6b 65 64 5f 6f 75  74 2f 6f 76 65 72 68 65    ecked_out/overhe
+03408   61 72 2f 64 6f 74 5f 73  6e 61 70 5f 32 30 30 37    ar/dot_snap_2007
+03424   30 32 30 36 2f 6d 69 73  73 69 6e 67 20 2d 2d 72    0206/missing --r
+03440   75 6e 20 61 75 74 6f 6d  61 6b 65 2d 31 2e 39 0a    un automake-1.9.
+03456   41 57 4b 20 3d 20 6d 61  77 6b 0a 43 43 20 3d 20    AWK = mawk.CC = 
+03472   67 63 63 0a 43 43 44 45  50 4d 4f 44 45 20 3d 20    gcc.CCDEPMODE = 
+03488   64 65 70 6d 6f 64 65 3d  67 63 63 33 0a 43 46 4c    depmode=gcc3.CFL
+03504   41 47 53 20 3d 20 24 28  44 45 42 55 47 29 20 24    AGS = $(DEBUG) $
+03520   28 57 46 4c 41 47 53 29  20 24 28 45 43 46 4c 41    (WFLAGS) $(ECFLA
+03536   47 53 29 0a 43 50 50 20  3d 20 67 63 63 20 2d 45    GS).CPP = gcc -E
+03552   0a 43 50 50 46 4c 41 47  53 20 3d 20 20 2d 49 2f    .CPPFLAGS =  -I/
+03568   68 6f 6d 65 2f 61 70 68  61 6e 69 73 68 2f 6c 69    home/aphanish/li
+03584   66 65 2f 72 65 73 65 61  72 63 68 2f 63 68 65 63    fe/research/chec
+03600   6b 65 64 5f 6f 75 74 2f  6f 76 65 72 68 65 61 72    ked_out/overhear
+03616   2f 64 6f 74 5f 73 6e 61  70 5f 32 30 30 37 30 32    /dot_snap_200702
+03632   30 36 2f 73 66 73 6c 69  74 65 20 2d 49 2f 68 6f    06/sfslite -I/ho
+03648   6d 65 2f 61 70 68 61 6e  69 73 68 2f 6c 69 66 65    me/aphanish/life
+03664   2f 72 65 73 65 61 72 63  68 2f 63 68 65 63 6b 65    /research/checke
+03680   64 5f 6f 75 74 2f 6f 76  65 72 68 65 61 72 2f 64    d_out/overhear/d
+03696   6f 74 5f 73 6e 61 70 5f  32 30 30 37 30 32 30 36    ot_snap_20070206
+03712   2f 73 66 73 6c 69 74 65  2f 2e 2f 61 73 79 6e 63    /sfslite/./async
+03728   20 2d 49 2f 68 6f 6d 65  2f 61 70 68 61 6e 69 73     -I/home/aphanis
+03744   68 2f 6c 69 66 65 2f 72  65 73 65 61 72 63 68 2f    h/life/research/
+03760   63 68 65 63 6b 65 64 5f  6f 75 74 2f 6f 76 65 72    checked_out/over
+03776   68 65 61 72 2f 64 6f 74  5f 73 6e 61 70 5f 32 30    hear/dot_snap_20
+03792   30 37 30 32 30 36 2f 73  66 73 6c 69 74 65 2f 2e    070206/sfslite/.
+03808   2f 61 72 70 63 20 2d 49  2f 68 6f 6d 65 2f 61 70    /arpc -I/home/ap
+03824   68 61 6e 69 73 68 2f 6c  69 66 65 2f 72 65 73 65    hanish/life/rese
+03840   61 72 63 68 2f 63 68 65  63 6b 65 64 5f 6f 75 74    arch/checked_out
+03856   2f 6f 76 65 72 68 65 61  72 2f 64 6f 74 5f 73 6e    /overhear/dot_sn
+03872   61 70 5f 32 30 30 37 30  32 30 36 2f 73 66 73 6c    ap_20070206/sfsl
+03888   69 74 65 2f 2e 2f 63 72  79 70 74 20 2d 49 2f 68    ite/./crypt -I/h
+03904   6f 6d 65 2f 61 70 68 61  6e 69 73 68 2f 6c 69 66    ome/aphanish/lif
+03920   65 2f 72 65 73 65 61 72  63 68 2f 63 68 65 63 6b    e/research/check
+03936   65 64 5f 6f 75 74 2f 6f  76 65 72 68 65 61 72 2f    ed_out/overhear/
+03952   64 6f 74 5f 73 6e 61 70  5f 32 30 30 37 30 32 30    dot_snap_2007020
+03968   36 2f 73 66 73 6c 69 74  65 2f 2e 2f 73 66 73 6d    6/sfslite/./sfsm
+03984   69 73 63 20 2d 49 2f 68  6f 6d 65 2f 61 70 68 61    isc -I/home/apha
+04000   6e 69 73 68 2f 6c 69 66  65 2f 72 65 73 65 61 72    nish/life/resear
+04016   63 68 2f 63 68 65 63 6b  65 64 5f 6f 75 74 2f 6f    ch/checked_out/o
+04032   76 65 72 68 65 61 72 2f  64 6f 74 5f 73 6e 61 70    verhear/dot_snap
+04048   5f 32 30 30 37 30 32 30  36 2f 73 66 73 6c 69 74    _20070206/sfslit
+04064   65 2f 73 76 63 20 20 20  2d 49 24 28 74 6f 70 5f    e/svc   -I$(top_
+04080   73 72 63 64 69 72 29 20  2d 49 24 28 74 6f 70 5f    srcdir) -I$(top_
+04096   73 72 63 64 69 72 29 2f  75 74 69 6c 20 2d 49 24    srcdir)/util -I$
+04112   28 74 6f 70 5f 73 72 63  64 69 72 29 2f 67 74 63    (top_srcdir)/gtc
+04128   64 20 2d 49 24 28 74 6f  70 5f 62 75 69 6c 64 64    d -I$(top_buildd
+04144   69 72 29 2f 67 74 63 64  2f 70 72 6f 74 0a 43 58    ir)/gtcd/prot.CX
+04160   58 20 3d 20 67 2b 2b 0a  43 58 58 43 50 50 20 3d    X = g++.CXXCPP =
+04176   20 67 2b 2b 20 2d 45 0a  43 58 58 44 45 42 55 47     g++ -E.CXXDEBUG
+04192   20 3d 20 2d 67 20 2d 4f  32 0a 43 58 58 44 45 50     = -g -O2.CXXDEP
+04208   4d 4f 44 45 20 3d 20 64  65 70 6d 6f 64 65 3d 67    MODE = depmode=g
+04224   63 63 33 0a 43 58 58 46  4c 41 47 53 20 3d 20 24    cc3.CXXFLAGS = $
+04240   28 43 58 58 44 45 42 55  47 29 20 24 28 43 58 58    (CXXDEBUG) $(CXX
+04256   57 46 4c 41 47 53 29 20  24 28 45 43 58 58 46 4c    WFLAGS) $(ECXXFL
+04272   41 47 53 29 0a 43 58 58  4e 4f 45 52 52 20 3d 20    AGS).CXXNOERR = 
+04288   2d 57 6e 6f 2d 65 72 72  6f 72 0a 43 58 58 57 46    -Wno-error.CXXWF
+04304   4c 41 47 53 20 3d 20 2d  57 61 6c 6c 20 2d 57 65    LAGS = -Wall -We
+04320   72 72 6f 72 0a 43 59 47  50 41 54 48 5f 57 20 3d    rror.CYGPATH_W =
+04336   20 65 63 68 6f 0a 44 45  42 55 47 20 3d 20 2d 67     echo.DEBUG = -g
+04352   20 2d 4f 32 0a 44 45 46  53 20 3d 20 2d 44 48 41     -O2.DEFS = -DHA
+04368   56 45 5f 43 4f 4e 46 49  47 5f 48 0a 44 45 50 44    VE_CONFIG_H.DEPD
+04384   49 52 20 3d 20 2e 64 65  70 73 0a 44 4d 41 4c 4c    IR = .deps.DMALL
+04400   4f 43 5f 46 41 4c 53 45  20 3d 20 0a 44 4d 41 4c    OC_FALSE = .DMAL
+04416   4c 4f 43 5f 54 52 55 45  20 3d 20 23 0a 45 43 46    LOC_TRUE = #.ECF
+04432   4c 41 47 53 20 3d 20 0a  45 43 48 4f 20 3d 20 65    LAGS = .ECHO = e
+04448   63 68 6f 0a 45 43 48 4f  5f 43 20 3d 20 0a 45 43    cho.ECHO_C = .EC
+04464   48 4f 5f 4e 20 3d 20 2d  6e 0a 45 43 48 4f 5f 54    HO_N = -n.ECHO_T
+04480   20 3d 20 0a 45 43 58 58  46 4c 41 47 53 20 3d 20     = .ECXXFLAGS = 
+04496   0a 45 47 52 45 50 20 3d  20 2f 62 69 6e 2f 67 72    .EGREP = /bin/gr
+04512   65 70 20 2d 45 0a 45 58  45 45 58 54 20 3d 20 0a    ep -E.EXEEXT = .
+04528   46 37 37 20 3d 20 0a 46  46 4c 41 47 53 20 3d 20    F77 = .FFLAGS = 
+04544   0a 47 4d 50 5f 44 49 52  20 3d 20 0a 47 52 45 50    .GMP_DIR = .GREP
+04560   20 3d 20 2f 62 69 6e 2f  67 72 65 70 0a 49 4e 53     = /bin/grep.INS
+04576   54 41 4c 4c 5f 44 41 54  41 20 3d 20 24 7b 49 4e    TALL_DATA = ${IN
+04592   53 54 41 4c 4c 7d 20 2d  6d 20 36 34 34 0a 49 4e    STALL} -m 644.IN
+04608   53 54 41 4c 4c 5f 50 52  4f 47 52 41 4d 20 3d 20    STALL_PROGRAM = 
+04624   24 7b 49 4e 53 54 41 4c  4c 7d 0a 49 4e 53 54 41    ${INSTALL}.INSTA
+04640   4c 4c 5f 53 43 52 49 50  54 20 3d 20 24 7b 49 4e    LL_SCRIPT = ${IN
+04656   53 54 41 4c 4c 7d 0a 49  4e 53 54 41 4c 4c 5f 53    STALL}.INSTALL_S
+04672   54 52 49 50 5f 50 52 4f  47 52 41 4d 20 3d 20 24    TRIP_PROGRAM = $
+04688   7b 53 48 45 4c 4c 7d 20  24 28 69 6e 73 74 61 6c    {SHELL} $(instal
+04704   6c 5f 73 68 29 20 2d 63  20 2d 73 0a 4c 44 41 44    l_sh) -c -s.LDAD
+04720   44 20 3d 20 24 28 4c 49  42 53 46 53 4d 49 53 43    D = $(LIBSFSMISC
+04736   29 20 24 28 4c 49 42 53  46 53 43 52 59 50 54 29    ) $(LIBSFSCRYPT)
+04752   20 24 28 4c 49 42 41 52  50 43 29 20 24 28 4c 49     $(LIBARPC) $(LI
+04768   42 41 53 59 4e 43 29 20  24 28 4c 49 42 47 4d 50    BASYNC) $(LIBGMP
+04784   29 20 24 28 4c 49 42 50  59 29 20 2d 6c 73 73 6c    ) $(LIBPY) -lssl
+04800   20 2d 6c 63 72 79 70 74  6f 20 20 20 24 28 4c 49     -lcrypto   $(LI
+04816   42 44 4f 54 55 54 49 4c  29 0a 4c 44 45 50 53 20    BDOTUTIL).LDEPS 
+04832   3d 20 24 28 4c 49 42 53  46 53 4d 49 53 43 29 20    = $(LIBSFSMISC) 
+04848   24 28 4c 49 42 53 46 53  43 52 59 50 54 29 20 24    $(LIBSFSCRYPT) $
+04864   28 4c 49 42 41 52 50 43  29 20 24 28 4c 49 42 41    (LIBARPC) $(LIBA
+04880   53 59 4e 43 29 20 24 28  4c 49 42 44 4f 54 55 54    SYNC) $(LIBDOTUT
+04896   49 4c 29 0a 4c 44 46 4c  41 47 53 20 3d 20 0a 4c    IL).LDFLAGS = .L
+04912   49 42 41 52 50 43 20 3d  20 2f 68 6f 6d 65 2f 61    IBARPC = /home/a
+04928   70 68 61 6e 69 73 68 2f  6c 69 66 65 2f 72 65 73    phanish/life/res
+04944   65 61 72 63 68 2f 63 68  65 63 6b 65 64 5f 6f 75    earch/checked_ou
+04960   74 2f 6f 76 65 72 68 65  61 72 2f 64 6f 74 5f 73    t/overhear/dot_s
+04976   6e 61 70 5f 32 30 30 37  30 32 30 36 2f 73 66 73    nap_20070206/sfs
+04992   6c 69 74 65 2f 61 72 70  63 2f 6c 69 62 61 72 70    lite/arpc/libarp
+05008   63 2e 6c 61 0a 4c 49 42  41 53 59 4e 43 20 3d 20    c.la.LIBASYNC = 
+05024   2f 68 6f 6d 65 2f 61 70  68 61 6e 69 73 68 2f 6c    /home/aphanish/l
+05040   69 66 65 2f 72 65 73 65  61 72 63 68 2f 63 68 65    ife/research/che
+05056   63 6b 65 64 5f 6f 75 74  2f 6f 76 65 72 68 65 61    cked_out/overhea
+05072   72 2f 64 6f 74 5f 73 6e  61 70 5f 32 30 30 37 30    r/dot_snap_20070
+05088   32 30 36 2f 73 66 73 6c  69 74 65 2f 61 73 79 6e    206/sfslite/asyn
+05104   63 2f 6c 69 62 61 73 79  6e 63 2e 6c 61 0a 4c 49    c/libasync.la.LI
+05120   42 44 4f 54 55 54 49 4c  20 3d 20 24 28 74 6f 70    BDOTUTIL = $(top
+05136   5f 62 75 69 6c 64 64 69  72 29 2f 75 74 69 6c 2f    _builddir)/util/
+05152   6c 69 62 64 6f 74 75 74  69 6c 2e 6c 61 0a 4c 49    libdotutil.la.LI
+05168   42 47 4d 50 20 3d 20 2f  75 73 72 2f 6c 69 62 2f    BGMP = /usr/lib/
+05184   6c 69 62 67 6d 70 2e 6c  61 0a 4c 49 42 47 54 43    libgmp.la.LIBGTC
+05200   20 3d 20 24 28 74 6f 70  5f 62 75 69 6c 64 64 69     = $(top_builddi
+05216   72 29 2f 67 74 63 64 2f  6c 69 62 67 74 63 2e 6c    r)/gtcd/libgtc.l
+05232   61 0a 4c 49 42 4f 42 4a  53 20 3d 20 0a 4c 49 42    a.LIBOBJS = .LIB
+05248   53 20 3d 20 0a 4c 49 42  53 46 53 20 3d 20 2f 68    S = .LIBSFS = /h
+05264   6f 6d 65 2f 61 70 68 61  6e 69 73 68 2f 6c 69 66    ome/aphanish/lif
+05280   65 2f 72 65 73 65 61 72  63 68 2f 63 68 65 63 6b    e/research/check
+05296   65 64 5f 6f 75 74 2f 6f  76 65 72 68 65 61 72 2f    ed_out/overhear/
+05312   64 6f 74 5f 73 6e 61 70  5f 32 30 30 37 30 32 30    dot_snap_2007020
+05328   36 2f 73 66 73 6c 69 74  65 2f 6c 69 62 73 66 73    6/sfslite/libsfs
+05344   2f 6c 69 62 73 66 73 2e  6c 61 0a 4c 49 42 53 46    /libsfs.la.LIBSF
+05360   53 43 52 59 50 54 20 3d  20 2f 68 6f 6d 65 2f 61    SCRYPT = /home/a
+05376   70 68 61 6e 69 73 68 2f  6c 69 66 65 2f 72 65 73    phanish/life/res
+05392   65 61 72 63 68 2f 63 68  65 63 6b 65 64 5f 6f 75    earch/checked_ou
+05408   74 2f 6f 76 65 72 68 65  61 72 2f 64 6f 74 5f 73    t/overhear/dot_s
+05424   6e 61 70 5f 32 30 30 37  30 32 30 36 2f 73 66 73    nap_20070206/sfs
+05440   6c 69 74 65 2f 63 72 79  70 74 2f 6c 69 62 73 66    lite/crypt/libsf
+05456   73 63 72 79 70 74 2e 6c  61 0a 4c 49 42 53 46 53    scrypt.la.LIBSFS
+05472   4d 49 53 43 20 3d 20 2f  68 6f 6d 65 2f 61 70 68    MISC = /home/aph
+05488   61 6e 69 73 68 2f 6c 69  66 65 2f 72 65 73 65 61    anish/life/resea
+05504   72 63 68 2f 63 68 65 63  6b 65 64 5f 6f 75 74 2f    rch/checked_out/
+05520   6f 76 65 72 68 65 61 72  2f 64 6f 74 5f 73 6e 61    overhear/dot_sna
+05536   70 5f 32 30 30 37 30 32  30 36 2f 73 66 73 6c 69    p_20070206/sfsli
+05552   74 65 2f 73 66 73 6d 69  73 63 2f 6c 69 62 73 66    te/sfsmisc/libsf
+05568   73 6d 69 73 63 2e 6c 61  0a 4c 49 42 53 56 43 20    smisc.la.LIBSVC 
+05584   3d 20 2f 68 6f 6d 65 2f  61 70 68 61 6e 69 73 68    = /home/aphanish
+05600   2f 6c 69 66 65 2f 72 65  73 65 61 72 63 68 2f 63    /life/research/c
+05616   68 65 63 6b 65 64 5f 6f  75 74 2f 6f 76 65 72 68    hecked_out/overh
+05632   65 61 72 2f 64 6f 74 5f  73 6e 61 70 5f 32 30 30    ear/dot_snap_200
+05648   37 30 32 30 36 2f 73 66  73 6c 69 74 65 2f 73 76    70206/sfslite/sv
+05664   63 2f 6c 69 62 73 76 63  2e 6c 61 0a 4c 49 42 54    c/libsvc.la.LIBT
+05680   4f 4f 4c 20 3d 20 24 28  53 48 45 4c 4c 29 20 24    OOL = $(SHELL) $
+05696   28 74 6f 70 5f 62 75 69  6c 64 64 69 72 29 2f 6c    (top_builddir)/l
+05712   69 62 74 6f 6f 6c 0a 4c  4e 5f 53 20 3d 20 6c 6e    ibtool.LN_S = ln
+05728   20 2d 73 0a 4c 54 4c 49  42 4f 42 4a 53 20 3d 20     -s.LTLIBOBJS = 
+05744   0a 4d 41 4b 45 49 4e 46  4f 20 3d 20 24 7b 53 48    .MAKEINFO = ${SH
+05760   45 4c 4c 7d 20 2f 68 6f  6d 65 2f 61 70 68 61 6e    ELL} /home/aphan
+05776   69 73 68 2f 6c 69 66 65  2f 72 65 73 65 61 72 63    ish/life/researc
+05792   68 2f 63 68 65 63 6b 65  64 5f 6f 75 74 2f 6f 76    h/checked_out/ov
+05808   65 72 68 65 61 72 2f 64  6f 74 5f 73 6e 61 70 5f    erhear/dot_snap_
+05824   32 30 30 37 30 32 30 36  2f 6d 69 73 73 69 6e 67    20070206/missing
+05840   20 2d 2d 72 75 6e 20 6d  61 6b 65 69 6e 66 6f 0a     --run makeinfo.
+05856   4d 41 4c 4c 4f 43 4b 20  3d 20 2f 68 6f 6d 65 2f    MALLOCK = /home/
+05872   61 70 68 61 6e 69 73 68  2f 6c 69 66 65 2f 72 65    aphanish/life/re
+05888   73 65 61 72 63 68 2f 63  68 65 63 6b 65 64 5f 6f    search/checked_o
+05904   75 74 2f 6f 76 65 72 68  65 61 72 2f 64 6f 74 5f    ut/overhear/dot_
+05920   73 6e 61 70 5f 32 30 30  37 30 32 30 36 2f 73 66    snap_20070206/sf
+05936   73 6c 69 74 65 2f 73 66  73 6d 69 73 63 2f 6d 61    slite/sfsmisc/ma
+05952   6c 6c 6f 63 6b 2e 6f 0a  4d 49 4c 54 45 52 5f 43    llock.o.MILTER_C
+05968   50 50 46 4c 41 47 53 20  3d 20 0a 4d 49 4c 54 45    PPFLAGS = .MILTE
+05984   52 5f 4c 44 46 4c 41 47  53 20 3d 20 0a 4d 49 4c    R_LDFLAGS = .MIL
+06000   54 45 52 5f 4c 49 42 53  20 3d 20 0a 4e 4f 50 41    TER_LIBS = .NOPA
+06016   47 49 4e 47 20 3d 20 0a  4e 57 20 3d 20 2d 77 0a    GING = .NW = -w.
+06032   4f 42 4a 45 58 54 20 3d  20 6f 0a 4f 50 45 4e 53    OBJEXT = o.OPENS
+06048   53 4c 5f 43 46 4c 41 47  53 20 3d 20 20 0a 4f 50    SL_CFLAGS =  .OP
+06064   45 4e 53 53 4c 5f 4c 49  42 53 20 3d 20 2d 6c 73    ENSSL_LIBS = -ls
+06080   73 6c 20 2d 6c 63 72 79  70 74 6f 20 20 0a 50 41    sl -lcrypto  .PA
+06096   43 4b 41 47 45 20 3d 20  64 6f 74 0a 50 41 43 4b    CKAGE = dot.PACK
+06112   41 47 45 5f 42 55 47 52  45 50 4f 52 54 20 3d 20    AGE_BUGREPORT = 
+06128   0a 50 41 43 4b 41 47 45  5f 4e 41 4d 45 20 3d 20    .PACKAGE_NAME = 
+06144   64 6f 74 0a 50 41 43 4b  41 47 45 5f 53 54 52 49    dot.PACKAGE_STRI
+06160   4e 47 20 3d 20 64 6f 74  20 30 2e 32 0a 50 41 43    NG = dot 0.2.PAC
+06176   4b 41 47 45 5f 54 41 52  4e 41 4d 45 20 3d 20 64    KAGE_TARNAME = d
+06192   6f 74 0a 50 41 43 4b 41  47 45 5f 56 45 52 53 49    ot.PACKAGE_VERSI
+06208   4f 4e 20 3d 20 30 2e 32  0a 50 41 54 48 5f 53 45    ON = 0.2.PATH_SE
+06224   50 41 52 41 54 4f 52 20  3d 20 3a 0a 50 4b 47 5f    PARATOR = :.PKG_
+06240   43 4f 4e 46 49 47 20 3d  20 2f 75 73 72 2f 62 69    CONFIG = /usr/bi
+06256   6e 2f 70 6b 67 2d 63 6f  6e 66 69 67 0a 52 41 4e    n/pkg-config.RAN
+06272   4c 49 42 20 3d 20 72 61  6e 6c 69 62 0a 52 50 43    LIB = ranlib.RPC
+06288   43 20 3d 20 2f 68 6f 6d  65 2f 61 70 68 61 6e 69    C = /home/aphani
+06304   73 68 2f 6c 69 66 65 2f  72 65 73 65 61 72 63 68    sh/life/research
+06320   2f 63 68 65 63 6b 65 64  5f 6f 75 74 2f 6f 76 65    /checked_out/ove
+06336   72 68 65 61 72 2f 64 6f  74 5f 73 6e 61 70 5f 32    rhear/dot_snap_2
+06352   30 30 37 30 32 30 36 2f  73 66 73 6c 69 74 65 2f    0070206/sfslite/
+06368   72 70 63 63 2f 72 70 63  63 0a 53 45 4e 44 4d 41    rpcc/rpcc.SENDMA
+06384   49 4c 5f 42 41 53 45 5f  44 49 52 20 3d 20 0a 53    IL_BASE_DIR = .S
+06400   45 4e 44 4d 41 49 4c 5f  4f 42 4a 5f 44 49 52 20    ENDMAIL_OBJ_DIR 
+06416   3d 20 0a 53 45 54 5f 4d  41 4b 45 20 3d 20 0a 53    = .SET_MAKE = .S
+06432   48 45 4c 4c 20 3d 20 2f  62 69 6e 2f 62 61 73 68    HELL = /bin/bash
+06448   0a 53 54 41 54 49 43 5f  46 41 4c 53 45 20 3d 20    .STATIC_FALSE = 
+06464   23 0a 53 54 41 54 49 43  5f 54 52 55 45 20 3d 20    #.STATIC_TRUE = 
+06480   0a 53 54 52 49 50 20 3d  20 73 74 72 69 70 0a 54    .STRIP = strip.T
+06496   41 4d 45 20 3d 20 2f 68  6f 6d 65 2f 61 70 68 61    AME = /home/apha
+06512   6e 69 73 68 2f 6c 69 66  65 2f 72 65 73 65 61 72    nish/life/resear
+06528   63 68 2f 63 68 65 63 6b  65 64 5f 6f 75 74 2f 6f    ch/checked_out/o
+06544   76 65 72 68 65 61 72 2f  64 6f 74 5f 73 6e 61 70    verhear/dot_snap
+06560   5f 32 30 30 37 30 32 30  36 2f 73 66 73 6c 69 74    _20070206/sfslit
+06576   65 2f 74 61 6d 65 2f 74  61 6d 65 0a 55 53 45 5f    e/tame/tame.USE_
+06592   4d 49 4c 54 45 52 5f 46  41 4c 53 45 20 3d 20 0a    MILTER_FALSE = .
+06608   55 53 45 5f 4d 49 4c 54  45 52 5f 54 52 55 45 20    USE_MILTER_TRUE 
+06624   3d 20 23 0a 56 45 52 53  49 4f 4e 20 3d 20 30 2e    = #.VERSION = 0.
+06640   32 0a 57 46 4c 41 47 53  20 3d 20 2d 57 61 6c 6c    2.WFLAGS = -Wall
+06656   20 2d 57 65 72 72 6f 72  0a 5f 50 41 54 48 5f 43     -Werror._PATH_C
+06672   50 50 20 3d 20 2f 75 73  72 2f 62 69 6e 2f 63 70    PP = /usr/bin/cp
+06688   70 0a 61 63 5f 63 74 5f  43 43 20 3d 20 67 63 63    p.ac_ct_CC = gcc
+06704   0a 61 63 5f 63 74 5f 43  58 58 20 3d 20 67 2b 2b    .ac_ct_CXX = g++
+06720   0a 61 63 5f 63 74 5f 46  37 37 20 3d 20 0a 61 6d    .ac_ct_F77 = .am
+06736   5f 5f 66 61 73 74 64 65  70 43 43 5f 46 41 4c 53    __fastdepCC_FALS
+06752   45 20 3d 20 23 0a 61 6d  5f 5f 66 61 73 74 64 65    E = #.am__fastde
+06768   70 43 43 5f 54 52 55 45  20 3d 20 0a 61 6d 5f 5f    pCC_TRUE = .am__
+06784   66 61 73 74 64 65 70 43  58 58 5f 46 41 4c 53 45    fastdepCXX_FALSE
+06800   20 3d 20 23 0a 61 6d 5f  5f 66 61 73 74 64 65 70     = #.am__fastdep
+06816   43 58 58 5f 54 52 55 45  20 3d 20 0a 61 6d 5f 5f    CXX_TRUE = .am__
+06832   69 6e 63 6c 75 64 65 20  3d 20 69 6e 63 6c 75 64    include = includ
+06848   65 0a 61 6d 5f 5f 6c 65  61 64 69 6e 67 5f 64 6f    e.am__leading_do
+06864   74 20 3d 20 2e 0a 61 6d  5f 5f 71 75 6f 74 65 20    t = ..am__quote 
+06880   3d 20 0a 61 6d 5f 5f 74  61 72 20 3d 20 24 7b 41    = .am__tar = ${A
+06896   4d 54 41 52 7d 20 63 68  6f 66 20 2d 20 22 24 24    MTAR} chof - "$$
+06912   74 61 72 64 69 72 22 0a  61 6d 5f 5f 75 6e 74 61    tardir".am__unta
+06928   72 20 3d 20 24 7b 41 4d  54 41 52 7d 20 78 66 20    r = ${AMTAR} xf 
+06944   2d 0a 62 69 6e 64 69 72  20 3d 20 24 7b 65 78 65    -.bindir = ${exe
+06960   63 5f 70 72 65 66 69 78  7d 2f 62 69 6e 0a 62 75    c_prefix}/bin.bu
+06976   69 6c 64 20 3d 20 69 36  38 36 2d 70 63 2d 6c 69    ild = i686-pc-li
+06992   6e 75 78 2d 67 6e 75 0a  62 75 69 6c 64 5f 61 6c    nux-gnu.build_al
+07008   69 61 73 20 3d 20 0a 62  75 69 6c 64 5f 63 70 75    ias = .build_cpu
+07024   20 3d 20 69 36 38 36 0a  62 75 69 6c 64 5f 6f 73     = i686.build_os
+07040   20 3d 20 6c 69 6e 75 78  2d 67 6e 75 0a 62 75 69     = linux-gnu.bui
+07056   6c 64 5f 76 65 6e 64 6f  72 20 3d 20 70 63 0a 64    ld_vendor = pc.d
+07072   61 74 61 64 69 72 20 3d  20 24 7b 64 61 74 61 72    atadir = ${datar
+07088   6f 6f 74 64 69 72 7d 0a  64 61 74 61 72 6f 6f 74    ootdir}.dataroot
+07104   64 69 72 20 3d 20 24 7b  70 72 65 66 69 78 7d 2f    dir = ${prefix}/
+07120   73 68 61 72 65 0a 64 6f  63 64 69 72 20 3d 20 24    share.docdir = $
+07136   7b 64 61 74 61 72 6f 6f  74 64 69 72 7d 2f 64 6f    {datarootdir}/do
+07152   63 2f 24 7b 50 41 43 4b  41 47 45 5f 54 41 52 4e    c/${PACKAGE_TARN
+07168   41 4d 45 7d 0a 64 76 69  64 69 72 20 3d 20 24 7b    AME}.dvidir = ${
+07184   64 6f 63 64 69 72 7d 0a  65 78 65 63 5f 70 72 65    docdir}.exec_pre
+07200   66 69 78 20 3d 20 24 7b  70 72 65 66 69 78 7d 0a    fix = ${prefix}.
+07216   68 6f 73 74 20 3d 20 69  36 38 36 2d 70 63 2d 6c    host = i686-pc-l
+07232   69 6e 75 78 2d 67 6e 75  0a 68 6f 73 74 5f 61 6c    inux-gnu.host_al
+07248   69 61 73 20 3d 20 0a 68  6f 73 74 5f 63 70 75 20    ias = .host_cpu 
+07264   3d 20 69 36 38 36 0a 68  6f 73 74 5f 6f 73 20 3d    = i686.host_os =
+07280   20 6c 69 6e 75 78 2d 67  6e 75 0a 68 6f 73 74 5f     linux-gnu.host_
+07296   76 65 6e 64 6f 72 20 3d  20 70 63 0a 68 74 6d 6c    vendor = pc.html
+07312   64 69 72 20 3d 20 24 7b  64 6f 63 64 69 72 7d 0a    dir = ${docdir}.
+07328   69 6e 63 6c 75 64 65 64  69 72 20 3d 20 24 7b 70    includedir = ${p
+07344   72 65 66 69 78 7d 2f 69  6e 63 6c 75 64 65 0a 69    refix}/include.i
+07360   6e 66 6f 64 69 72 20 3d  20 24 7b 64 61 74 61 72    nfodir = ${datar
+07376   6f 6f 74 64 69 72 7d 2f  69 6e 66 6f 0a 69 6e 73    ootdir}/info.ins
+07392   74 61 6c 6c 5f 73 68 20  3d 20 2f 68 6f 6d 65 2f    tall_sh = /home/
+07408   61 70 68 61 6e 69 73 68  2f 6c 69 66 65 2f 72 65    aphanish/life/re
+07424   73 65 61 72 63 68 2f 63  68 65 63 6b 65 64 5f 6f    search/checked_o
+07440   75 74 2f 6f 76 65 72 68  65 61 72 2f 64 6f 74 5f    ut/overhear/dot_
+07456   73 6e 61 70 5f 32 30 30  37 30 32 30 36 2f 69 6e    snap_20070206/in
+07472   73 74 61 6c 6c 2d 73 68  0a 6c 69 62 64 69 72 20    stall-sh.libdir 
+07488   3d 20 24 7b 65 78 65 63  5f 70 72 65 66 69 78 7d    = ${exec_prefix}
+07504   2f 6c 69 62 0a 6c 69 62  65 78 65 63 64 69 72 20    /lib.libexecdir 
+07520   3d 20 24 7b 65 78 65 63  5f 70 72 65 66 69 78 7d    = ${exec_prefix}
+07536   2f 6c 69 62 65 78 65 63  0a 6c 6f 63 61 6c 65 64    /libexec.localed
+07552   69 72 20 3d 20 24 7b 64  61 74 61 72 6f 6f 74 64    ir = ${datarootd
+07568   69 72 7d 2f 6c 6f 63 61  6c 65 0a 6c 6f 63 61 6c    ir}/locale.local
+07584   73 74 61 74 65 64 69 72  20 3d 20 24 7b 70 72 65    statedir = ${pre
+07600   66 69 78 7d 2f 76 61 72  0a 6d 61 6e 64 69 72 20    fix}/var.mandir 
+07616   3d 20 24 7b 64 61 74 61  72 6f 6f 74 64 69 72 7d    = ${datarootdir}
+07632   2f 6d 61 6e 0a 6d 6b 64  69 72 5f 70 20 3d 20 6d    /man.mkdir_p = m
+07648   6b 64 69 72 20 2d 70 20  2d 2d 0a 6f 6c 64 69 6e    kdir -p --.oldin
+07664   63 6c 75 64 65 64 69 72  20 3d 20 2f 75 73 72 2f    cludedir = /usr/
+07680   69 6e 63 6c 75 64 65 0a  70 64 66 64 69 72 20 3d    include.pdfdir =
+07696   20 24 7b 64 6f 63 64 69  72 7d 0a 70 72 65 66 69     ${docdir}.prefi
+07712   78 20 3d 20 2f 68 6f 6d  65 2f 61 70 68 61 6e 69    x = /home/aphani
+07728   73 68 2f 6c 69 66 65 2f  72 65 73 65 61 72 63 68    sh/life/research
+07744   2f 63 68 65 63 6b 65 64  5f 6f 75 74 2f 6f 76 65    /checked_out/ove
+07760   72 68 65 61 72 2f 64 6f  74 5f 73 6e 61 70 5f 32    rhear/dot_snap_2
+07776   30 30 37 30 32 30 36 2f  69 6e 73 74 61 6c 6c 65    0070206/installe
+07792   64 0a 70 72 6f 67 72 61  6d 5f 74 72 61 6e 73 66    d.program_transf
+07808   6f 72 6d 5f 6e 61 6d 65  20 3d 20 73 2c 78 2c 78    orm_name = s,x,x
+07824   2c 0a 70 73 64 69 72 20  3d 20 24 7b 64 6f 63 64    ,.psdir = ${docd
+07840   69 72 7d 0a 73 62 69 6e  64 69 72 20 3d 20 24 7b    ir}.sbindir = ${
+07856   65 78 65 63 5f 70 72 65  66 69 78 7d 2f 73 62 69    exec_prefix}/sbi
+07872   6e 0a 73 66 73 69 6e 63  6c 75 64 65 64 69 72 20    n.sfsincludedir 
+07888   3d 20 24 28 6c 69 62 64  69 72 29 2f 69 6e 63 6c    = $(libdir)/incl
+07904   75 64 65 0a 73 66 73 6c  69 62 64 69 72 20 3d 20    ude.sfslibdir = 
+07920   24 28 6c 69 62 64 69 72  29 2f 73 66 73 0a 73 68    $(libdir)/sfs.sh
+07936   61 72 65 64 73 74 61 74  65 64 69 72 20 3d 20 24    aredstatedir = $
+07952   7b 70 72 65 66 69 78 7d  2f 63 6f 6d 0a 73 75 62    {prefix}/com.sub
+07968   64 69 72 73 20 3d 20 20  0a 73 79 73 63 6f 6e 66    dirs =  .sysconf
+07984   64 69 72 20 3d 20 24 7b  70 72 65 66 69 78 7d 2f    dir = ${prefix}/
+08000   65 74 63 0a 74 61 72 67  65 74 5f 61 6c 69 61 73    etc.target_alias
+08016   20 3d 20 0a 46 49 4c 54  45 52 20 3d 20 0a 23 46     = .FILTER = .#F
+08032   49 4c 54 45 52 20 3d 20  6d 61 69 6c 66 69 6c 74    ILTER = mailfilt
+08048   65 72 0a 44 49 53 54 5f  53 55 42 44 49 52 53 20    er.DIST_SUBDIRS 
+08064   3d 20 75 74 69 6c 20 67  74 63 64 20 67 63 70 20    = util gtcd gcp 
+08080   63 64 68 74 0a 53 55 42  44 49 52 53 20 3d 20 24    cdht.SUBDIRS = $
+08096   28 44 49 53 54 5f 53 55  42 44 49 52 53 29 20 24    (DIST_SUBDIRS) $
+08112   28 46 49 4c 54 45 52 29  0a 43 4c 45 41 4e 46 49    (FILTER).CLEANFI
+08128   4c 45 53 20 3d 20 63 6f  72 65 20 2a 2e 63 6f 72    LES = core *.cor
+08144   65 20 2a 7e 0a 44 49 53  54 43 4c 45 41 4e 46 49    e *~.DISTCLEANFI
+08160   4c 45 53 20 3d 20 61 75  74 6f 6d 34 74 65 2a 2e    LES = autom4te*.
+08176   63 61 63 68 65 20 63 6f  6e 66 69 67 2e 73 74 61    cache config.sta
+08192   74 75 73 20 63 6f 6e 66  69 67 2e 6c 6f 67 0a 4d    tus config.log.M
+08208   41 49 4e 54 41 49 4e 45  52 43 4c 45 41 4e 46 49    AINTAINERCLEANFI
+08224   4c 45 53 20 3d 20 61 63  6c 6f 63 61 6c 2e 6d 34    LES = aclocal.m4
+08240   20 69 6e 73 74 61 6c 6c  2d 73 68 20 6d 6b 69 6e     install-sh mkin
+08256   73 74 61 6c 6c 64 69 72  73 20 5c 0a 09 6d 69 73    stalldirs \..mis
+08272   73 69 6e 67 20 63 6f 6e  66 69 67 75 72 65 20 63    sing configure c
+08288   6f 6e 66 69 67 2e 67 75  65 73 73 20 63 6f 6e 66    onfig.guess conf
+08304   69 67 2e 73 75 62 20 63  6f 6e 66 69 67 2e 68 2e    ig.sub config.h.
+08320   69 6e 20 5c 0a 09 6c 74  63 6f 6e 66 69 67 20 6c    in \..ltconfig l
+08336   74 6d 61 69 6e 2e 73 68  20 43 4f 50 59 49 4e 47    tmain.sh COPYING
+08352   20 49 4e 53 54 41 4c 4c  20 4d 61 6b 65 66 69 6c     INSTALL Makefil
+08368   65 2e 69 6e 20 73 74 61  6d 70 2d 68 2e 69 6e 0a    e.in stamp-h.in.
+08384   0a 61 6c 6c 3a 20 63 6f  6e 66 69 67 2e 68 0a 09    .all: config.h..
+08400   24 28 4d 41 4b 45 29 20  24 28 41 4d 5f 4d 41 4b    $(MAKE) $(AM_MAK
+08416   45 46 4c 41 47 53 29 20  61 6c 6c 2d 72 65 63 75    EFLAGS) all-recu
+08432   72 73 69 76 65 0a 0a 2e  53 55 46 46 49 58 45 53    rsive...SUFFIXES
+08448   3a 0a 61 6d 2d 2d 72 65  66 72 65 73 68 3a 0a 09    :.am--refresh:..
+08464   40 3a 0a 24 28 73 72 63  64 69 72 29 2f 4d 61 6b    @:.$(srcdir)/Mak
+08480   65 66 69 6c 65 2e 69 6e  3a 20 20 24 28 73 72 63    efile.in:  $(src
+08496   64 69 72 29 2f 4d 61 6b  65 66 69 6c 65 2e 61 6d    dir)/Makefile.am
+08512   20 20 24 28 61 6d 5f 5f  63 6f 6e 66 69 67 75 72      $(am__configur
+08528   65 5f 64 65 70 73 29 0a  09 40 66 6f 72 20 64 65    e_deps)..@for de
+08544   70 20 69 6e 20 24 3f 3b  20 64 6f 20 5c 0a 09 20    p in $?; do \.. 
+08560   20 63 61 73 65 20 27 24  28 61 6d 5f 5f 63 6f 6e     case '$(am__con
+08576   66 69 67 75 72 65 5f 64  65 70 73 29 27 20 69 6e    figure_deps)' in
+08592   20 5c 0a 09 20 20 20 20  2a 24 24 64 65 70 2a 29     \..    *$$dep*)
+08608   20 5c 0a 09 20 20 20 20  20 20 65 63 68 6f 20 27     \..      echo '
+08624   20 63 64 20 24 28 73 72  63 64 69 72 29 20 26 26     cd $(srcdir) &&
+08640   20 24 28 41 55 54 4f 4d  41 4b 45 29 20 2d 2d 67     $(AUTOMAKE) --g
+08656   6e 75 20 27 3b 20 5c 0a  09 20 20 20 20 20 20 63    nu '; \..      c
+08672   64 20 24 28 73 72 63 64  69 72 29 20 26 26 20 24    d $(srcdir) && $
+08688   28 41 55 54 4f 4d 41 4b  45 29 20 2d 2d 67 6e 75    (AUTOMAKE) --gnu
+08704   20 20 5c 0a 09 09 26 26  20 65 78 69 74 20 30 3b      \...&& exit 0;
+08720   20 5c 0a 09 20 20 20 20  20 20 65 78 69 74 20 31     \..      exit 1
+08736   3b 3b 20 5c 0a 09 20 20  65 73 61 63 3b 20 5c 0a    ;; \..  esac; \.
+08752   09 64 6f 6e 65 3b 20 5c  0a 09 65 63 68 6f 20 27    .done; \..echo '
+08768   20 63 64 20 24 28 74 6f  70 5f 73 72 63 64 69 72     cd $(top_srcdir
+08784   29 20 26 26 20 24 28 41  55 54 4f 4d 41 4b 45 29    ) && $(AUTOMAKE)
+08800   20 2d 2d 67 6e 75 20 20  4d 61 6b 65 66 69 6c 65     --gnu  Makefile
+08816   27 3b 20 5c 0a 09 63 64  20 24 28 74 6f 70 5f 73    '; \..cd $(top_s
+08832   72 63 64 69 72 29 20 26  26 20 5c 0a 09 20 20 24    rcdir) && \..  $
+08848   28 41 55 54 4f 4d 41 4b  45 29 20 2d 2d 67 6e 75    (AUTOMAKE) --gnu
+08864   20 20 4d 61 6b 65 66 69  6c 65 0a 2e 50 52 45 43      Makefile..PREC
+08880   49 4f 55 53 3a 20 4d 61  6b 65 66 69 6c 65 0a 4d    IOUS: Makefile.M
+08896   61 6b 65 66 69 6c 65 3a  20 24 28 73 72 63 64 69    akefile: $(srcdi
+08912   72 29 2f 4d 61 6b 65 66  69 6c 65 2e 69 6e 20 24    r)/Makefile.in $
+08928   28 74 6f 70 5f 62 75 69  6c 64 64 69 72 29 2f 63    (top_builddir)/c
+08944   6f 6e 66 69 67 2e 73 74  61 74 75 73 0a 09 40 63    onfig.status..@c
+08960   61 73 65 20 27 24 3f 27  20 69 6e 20 5c 0a 09 20    ase '$?' in \.. 
+08976   20 2a 63 6f 6e 66 69 67  2e 73 74 61 74 75 73 2a     *config.status*
+08992   29 20 5c 0a 09 20 20 20  20 65 63 68 6f 20 27 20    ) \..    echo ' 
+09008   24 28 53 48 45 4c 4c 29  20 2e 2f 63 6f 6e 66 69    $(SHELL) ./confi
+09024   67 2e 73 74 61 74 75 73  27 3b 20 5c 0a 09 20 20    g.status'; \..  
+09040   20 20 24 28 53 48 45 4c  4c 29 20 2e 2f 63 6f 6e      $(SHELL) ./con
+09056   66 69 67 2e 73 74 61 74  75 73 3b 3b 20 5c 0a 09    fig.status;; \..
+09072   20 20 2a 29 20 5c 0a 09  20 20 20 20 65 63 68 6f      *) \..    echo
+09088   20 27 20 63 64 20 24 28  74 6f 70 5f 62 75 69 6c     ' cd $(top_buil
+09104   64 64 69 72 29 20 26 26  20 24 28 53 48 45 4c 4c    ddir) && $(SHELL
+09120   29 20 2e 2f 63 6f 6e 66  69 67 2e 73 74 61 74 75    ) ./config.statu
+09136   73 20 24 40 20 24 28 61  6d 5f 5f 64 65 70 66 69    s $@ $(am__depfi
+09152   6c 65 73 5f 6d 61 79 62  65 29 27 3b 20 5c 0a 09    les_maybe)'; \..
+09168   20 20 20 20 63 64 20 24  28 74 6f 70 5f 62 75 69        cd $(top_bui
+09184   6c 64 64 69 72 29 20 26  26 20 24 28 53 48 45 4c    lddir) && $(SHEL
+09200   4c 29 20 2e 2f 63 6f 6e  66 69 67 2e 73 74 61 74    L) ./config.stat
+09216   75 73 20 24 40 20 24 28  61 6d 5f 5f 64 65 70 66    us $@ $(am__depf
+09232   69 6c 65 73 5f 6d 61 79  62 65 29 3b 3b 20 5c 0a    iles_maybe);; \.
+09248   09 65 73 61 63 3b 0a 0a  24 28 74 6f 70 5f 62 75    .esac;..$(top_bu
+09264   69 6c 64 64 69 72 29 2f  63 6f 6e 66 69 67 2e 73    ilddir)/config.s
+09280   74 61 74 75 73 3a 20 24  28 74 6f 70 5f 73 72 63    tatus: $(top_src
+09296   64 69 72 29 2f 63 6f 6e  66 69 67 75 72 65 20 24    dir)/configure $
+09312   28 43 4f 4e 46 49 47 5f  53 54 41 54 55 53 5f 44    (CONFIG_STATUS_D
+09328   45 50 45 4e 44 45 4e 43  49 45 53 29 0a 09 24 28    EPENDENCIES)..$(
+09344   53 48 45 4c 4c 29 20 2e  2f 63 6f 6e 66 69 67 2e    SHELL) ./config.
+09360   73 74 61 74 75 73 20 2d  2d 72 65 63 68 65 63 6b    status --recheck
+09376   0a 0a 24 28 74 6f 70 5f  73 72 63 64 69 72 29 2f    ..$(top_srcdir)/
+09392   63 6f 6e 66 69 67 75 72  65 3a 20 20 24 28 61 6d    configure:  $(am
+09408   5f 5f 63 6f 6e 66 69 67  75 72 65 5f 64 65 70 73    __configure_deps
+09424   29 0a 09 63 64 20 24 28  73 72 63 64 69 72 29 20    )..cd $(srcdir) 
+09440   26 26 20 24 28 41 55 54  4f 43 4f 4e 46 29 0a 24    && $(AUTOCONF).$
+09456   28 41 43 4c 4f 43 41 4c  5f 4d 34 29 3a 20 20 24    (ACLOCAL_M4):  $
+09472   28 61 6d 5f 5f 61 63 6c  6f 63 61 6c 5f 6d 34 5f    (am__aclocal_m4_
+09488   64 65 70 73 29 0a 09 63  64 20 24 28 73 72 63 64    deps)..cd $(srcd
+09504   69 72 29 20 26 26 20 24  28 41 43 4c 4f 43 41 4c    ir) && $(ACLOCAL
+09520   29 20 24 28 41 43 4c 4f  43 41 4c 5f 41 4d 46 4c    ) $(ACLOCAL_AMFL
+09536   41 47 53 29 0a 0a 63 6f  6e 66 69 67 2e 68 3a 20    AGS)..config.h: 
+09552   73 74 61 6d 70 2d 68 31  0a 09 40 69 66 20 74 65    stamp-h1..@if te
+09568   73 74 20 21 20 2d 66 20  24 40 3b 20 74 68 65 6e    st ! -f $@; then
+09584   20 5c 0a 09 20 20 72 6d  20 2d 66 20 73 74 61 6d     \..  rm -f stam
+09600   70 2d 68 31 3b 20 5c 0a  09 20 20 24 28 4d 41 4b    p-h1; \..  $(MAK
+09616   45 29 20 73 74 61 6d 70  2d 68 31 3b 20 5c 0a 09    E) stamp-h1; \..
+09632   65 6c 73 65 20 3a 3b 20  66 69 0a 0a 73 74 61 6d    else :; fi..stam
+09648   70 2d 68 31 3a 20 24 28  73 72 63 64 69 72 29 2f    p-h1: $(srcdir)/
+09664   63 6f 6e 66 69 67 2e 68  2e 69 6e 20 24 28 74 6f    config.h.in $(to
+09680   70 5f 62 75 69 6c 64 64  69 72 29 2f 63 6f 6e 66    p_builddir)/conf
+09696   69 67 2e 73 74 61 74 75  73 0a 09 40 72 6d 20 2d    ig.status..@rm -
+09712   66 20 73 74 61 6d 70 2d  68 31 0a 09 63 64 20 24    f stamp-h1..cd $
+09728   28 74 6f 70 5f 62 75 69  6c 64 64 69 72 29 20 26    (top_builddir) &
+09744   26 20 24 28 53 48 45 4c  4c 29 20 2e 2f 63 6f 6e    & $(SHELL) ./con
+09760   66 69 67 2e 73 74 61 74  75 73 20 63 6f 6e 66 69    fig.status confi
+09776   67 2e 68 0a 24 28 73 72  63 64 69 72 29 2f 63 6f    g.h.$(srcdir)/co
+09792   6e 66 69 67 2e 68 2e 69  6e 3a 20 20 24 28 61 6d    nfig.h.in:  $(am
+09808   5f 5f 63 6f 6e 66 69 67  75 72 65 5f 64 65 70 73    __configure_deps
+09824   29 20 0a 09 63 64 20 24  28 74 6f 70 5f 73 72 63    ) ..cd $(top_src
+09840   64 69 72 29 20 26 26 20  24 28 41 55 54 4f 48 45    dir) && $(AUTOHE
+09856   41 44 45 52 29 0a 09 72  6d 20 2d 66 20 73 74 61    ADER)..rm -f sta
+09872   6d 70 2d 68 31 0a 09 74  6f 75 63 68 20 24 40 0a    mp-h1..touch $@.
+09888   0a 64 69 73 74 63 6c 65  61 6e 2d 68 64 72 3a 0a    .distclean-hdr:.
+09904   09 2d 72 6d 20 2d 66 20  63 6f 6e 66 69 67 2e 68    .-rm -f config.h
+09920   20 73 74 61 6d 70 2d 68  31 0a 0a 6d 6f 73 74 6c     stamp-h1..mostl
+09936   79 63 6c 65 61 6e 2d 6c  69 62 74 6f 6f 6c 3a 0a    yclean-libtool:.
+09952   09 2d 72 6d 20 2d 66 20  2a 2e 6c 6f 0a 0a 63 6c    .-rm -f *.lo..cl
+09968   65 61 6e 2d 6c 69 62 74  6f 6f 6c 3a 0a 09 2d 72    ean-libtool:..-r
+09984   6d 20 2d 72 66 20 2e 6c  69 62 73 20 5f 6c 69 62    m -rf .libs _lib
+10000   73 0a 0a 64 69 73 74 63  6c 65 61 6e 2d 6c 69 62    s..distclean-lib
+10016   74 6f 6f 6c 3a 0a 09 2d  72 6d 20 2d 66 20 6c 69    tool:..-rm -f li
+10032   62 74 6f 6f 6c 0a 75 6e  69 6e 73 74 61 6c 6c 2d    btool.uninstall-
+10048   69 6e 66 6f 2d 61 6d 3a  0a 0a 23 20 54 68 69 73    info-am:..# This
+10064   20 64 69 72 65 63 74 6f  72 79 27 73 20 73 75 62     directory's sub
+10080   64 69 72 65 63 74 6f 72  69 65 73 20 61 72 65 20    directories are 
+10096   6d 6f 73 74 6c 79 20 69  6e 64 65 70 65 6e 64 65    mostly independe
+10112   6e 74 3b 20 79 6f 75 20  63 61 6e 20 63 64 0a 23    nt; you can cd.#
+10128   20 69 6e 74 6f 20 74 68  65 6d 20 61 6e 64 20 72     into them and r
+10144   75 6e 20 60 6d 61 6b 65  27 20 77 69 74 68 6f 75    un `make' withou
+10160   74 20 67 6f 69 6e 67 20  74 68 72 6f 75 67 68 20    t going through 
+10176   74 68 69 73 20 4d 61 6b  65 66 69 6c 65 2e 0a 23    this Makefile..#
+10192   20 54 6f 20 63 68 61 6e  67 65 20 74 68 65 20 76     To change the v
+10208   61 6c 75 65 73 20 6f 66  20 60 6d 61 6b 65 27 20    alues of `make' 
+10224   76 61 72 69 61 62 6c 65  73 3a 20 69 6e 73 74 65    variables: inste
+10240   61 64 20 6f 66 20 65 64  69 74 69 6e 67 20 4d 61    ad of editing Ma
+10256   6b 65 66 69 6c 65 73 2c  0a 23 20 28 31 29 20 69    kefiles,.# (1) i
+10272   66 20 74 68 65 20 76 61  72 69 61 62 6c 65 20 69    f the variable i
+10288   73 20 73 65 74 20 69 6e  20 60 63 6f 6e 66 69 67    s set in `config
+10304   2e 73 74 61 74 75 73 27  2c 20 65 64 69 74 20 60    .status', edit `
+10320   63 6f 6e 66 69 67 2e 73  74 61 74 75 73 27 0a 23    config.status'.#
+10336   20 20 20 20 20 28 77 68  69 63 68 20 77 69 6c 6c         (which will
+10352   20 63 61 75 73 65 20 74  68 65 20 4d 61 6b 65 66     cause the Makef
+10368   69 6c 65 73 20 74 6f 20  62 65 20 72 65 67 65 6e    iles to be regen
+10384   65 72 61 74 65 64 20 77  68 65 6e 20 79 6f 75 20    erated when you 
+10400   72 75 6e 20 60 6d 61 6b  65 27 29 3b 0a 23 20 28    run `make');.# (
+10416   32 29 20 6f 74 68 65 72  77 69 73 65 2c 20 70 61    2) otherwise, pa
+10432   73 73 20 74 68 65 20 64  65 73 69 72 65 64 20 76    ss the desired v
+10448   61 6c 75 65 73 20 6f 6e  20 74 68 65 20 60 6d 61    alues on the `ma
+10464   6b 65 27 20 63 6f 6d 6d  61 6e 64 20 6c 69 6e 65    ke' command line
+10480   2e 0a 24 28 52 45 43 55  52 53 49 56 45 5f 54 41    ..$(RECURSIVE_TA
+10496   52 47 45 54 53 29 3a 0a  09 40 66 61 69 6c 63 6f    RGETS):..@failco
+10512   6d 3d 27 65 78 69 74 20  31 27 3b 20 5c 0a 09 66    m='exit 1'; \..f
+10528   6f 72 20 66 20 69 6e 20  78 20 24 24 4d 41 4b 45    or f in x $$MAKE
+10544   46 4c 41 47 53 3b 20 64  6f 20 5c 0a 09 20 20 63    FLAGS; do \..  c
+10560   61 73 65 20 24 24 66 20  69 6e 20 5c 0a 09 20 20    ase $$f in \..  
+10576   20 20 2a 3d 2a 20 7c 20  2d 2d 5b 21 6b 5d 2a 29      *=* | --[!k]*)
+10592   3b 3b 20 5c 0a 09 20 20  20 20 2a 6b 2a 29 20 66    ;; \..    *k*) f
+10608   61 69 6c 63 6f 6d 3d 27  66 61 69 6c 3d 79 65 73    ailcom='fail=yes
+10624   27 3b 3b 20 5c 0a 09 20  20 65 73 61 63 3b 20 5c    ';; \..  esac; \
+10640   0a 09 64 6f 6e 65 3b 20  5c 0a 09 64 6f 74 5f 73    ..done; \..dot_s
+10656   65 65 6e 3d 6e 6f 3b 20  5c 0a 09 74 61 72 67 65    een=no; \..targe
+10672   74 3d 60 65 63 68 6f 20  24 40 20 7c 20 73 65 64    t=`echo $@ | sed
+10688   20 73 2f 2d 72 65 63 75  72 73 69 76 65 2f 2f 60     s/-recursive//`
+10704   3b 20 5c 0a 09 6c 69 73  74 3d 27 24 28 53 55 42    ; \..list='$(SUB
+10720   44 49 52 53 29 27 3b 20  66 6f 72 20 73 75 62 64    DIRS)'; for subd
+10736   69 72 20 69 6e 20 24 24  6c 69 73 74 3b 20 64 6f    ir in $$list; do
+10752   20 5c 0a 09 20 20 65 63  68 6f 20 22 4d 61 6b 69     \..  echo "Maki
+10768   6e 67 20 24 24 74 61 72  67 65 74 20 69 6e 20 24    ng $$target in $
+10784   24 73 75 62 64 69 72 22  3b 20 5c 0a 09 20 20 69    $subdir"; \..  i
+10800   66 20 74 65 73 74 20 22  24 24 73 75 62 64 69 72    f test "$$subdir
+10816   22 20 3d 20 22 2e 22 3b  20 74 68 65 6e 20 5c 0a    " = "."; then \.
+10832   09 20 20 20 20 64 6f 74  5f 73 65 65 6e 3d 79 65    .    dot_seen=ye
+10848   73 3b 20 5c 0a 09 20 20  20 20 6c 6f 63 61 6c 5f    s; \..    local_
+10864   74 61 72 67 65 74 3d 22  24 24 74 61 72 67 65 74    target="$$target
+10880   2d 61 6d 22 3b 20 5c 0a  09 20 20 65 6c 73 65 20    -am"; \..  else 
+10896   5c 0a 09 20 20 20 20 6c  6f 63 61 6c 5f 74 61 72    \..    local_tar
+10912   67 65 74 3d 22 24 24 74  61 72 67 65 74 22 3b 20    get="$$target"; 
+10928   5c 0a 09 20 20 66 69 3b  20 5c 0a 09 20 20 28 63    \..  fi; \..  (c
+10944   64 20 24 24 73 75 62 64  69 72 20 26 26 20 24 28    d $$subdir && $(
+10960   4d 41 4b 45 29 20 24 28  41 4d 5f 4d 41 4b 45 46    MAKE) $(AM_MAKEF
+10976   4c 41 47 53 29 20 24 24  6c 6f 63 61 6c 5f 74 61    LAGS) $$local_ta
+10992   72 67 65 74 29 20 5c 0a  09 20 20 7c 7c 20 65 76    rget) \..  || ev
+11008   61 6c 20 24 24 66 61 69  6c 63 6f 6d 3b 20 5c 0a    al $$failcom; \.
+11024   09 64 6f 6e 65 3b 20 5c  0a 09 69 66 20 74 65 73    .done; \..if tes
+11040   74 20 22 24 24 64 6f 74  5f 73 65 65 6e 22 20 3d    t "$$dot_seen" =
+11056   20 22 6e 6f 22 3b 20 74  68 65 6e 20 5c 0a 09 20     "no"; then \.. 
+11072   20 24 28 4d 41 4b 45 29  20 24 28 41 4d 5f 4d 41     $(MAKE) $(AM_MA
+11088   4b 45 46 4c 41 47 53 29  20 22 24 24 74 61 72 67    KEFLAGS) "$$targ
+11104   65 74 2d 61 6d 22 20 7c  7c 20 65 78 69 74 20 31    et-am" || exit 1
+11120   3b 20 5c 0a 09 66 69 3b  20 74 65 73 74 20 2d 7a    ; \..fi; test -z
+11136   20 22 24 24 66 61 69 6c  22 0a 0a 6d 6f 73 74 6c     "$$fail"..mostl
+11152   79 63 6c 65 61 6e 2d 72  65 63 75 72 73 69 76 65    yclean-recursive
+11168   20 63 6c 65 61 6e 2d 72  65 63 75 72 73 69 76 65     clean-recursive
+11184   20 64 69 73 74 63 6c 65  61 6e 2d 72 65 63 75 72     distclean-recur
+11200   73 69 76 65 20 5c 0a 6d  61 69 6e 74 61 69 6e 65    sive \.maintaine
+11216   72 2d 63 6c 65 61 6e 2d  72 65 63 75 72 73 69 76    r-clean-recursiv
+11232   65 3a 0a 09 40 66 61 69  6c 63 6f 6d 3d 27 65 78    e:..@failcom='ex
+11248   69 74 20 31 27 3b 20 5c  0a 09 66 6f 72 20 66 20    it 1'; \..for f 
+11264   69 6e 20 78 20 24 24 4d  41 4b 45 46 4c 41 47 53    in x $$MAKEFLAGS
+11280   3b 20 64 6f 20 5c 0a 09  20 20 63 61 73 65 20 24    ; do \..  case $
+11296   24 66 20 69 6e 20 5c 0a  09 20 20 20 20 2a 3d 2a    $f in \..    *=*
+11312   20 7c 20 2d 2d 5b 21 6b  5d 2a 29 3b 3b 20 5c 0a     | --[!k]*);; \.
+11328   09 20 20 20 20 2a 6b 2a  29 20 66 61 69 6c 63 6f    .    *k*) failco
+11344   6d 3d 27 66 61 69 6c 3d  79 65 73 27 3b 3b 20 5c    m='fail=yes';; \
+11360   0a 09 20 20 65 73 61 63  3b 20 5c 0a 09 64 6f 6e    ..  esac; \..don
+11376   65 3b 20 5c 0a 09 64 6f  74 5f 73 65 65 6e 3d 6e    e; \..dot_seen=n
+11392   6f 3b 20 5c 0a 09 63 61  73 65 20 22 24 40 22 20    o; \..case "$@" 
+11408   69 6e 20 5c 0a 09 20 20  64 69 73 74 63 6c 65 61    in \..  distclea
+11424   6e 2d 2a 20 7c 20 6d 61  69 6e 74 61 69 6e 65 72    n-* | maintainer
+11440   2d 63 6c 65 61 6e 2d 2a  29 20 6c 69 73 74 3d 27    -clean-*) list='
+11456   24 28 44 49 53 54 5f 53  55 42 44 49 52 53 29 27    $(DIST_SUBDIRS)'
+11472   20 3b 3b 20 5c 0a 09 20  20 2a 29 20 6c 69 73 74     ;; \..  *) list
+11488   3d 27 24 28 53 55 42 44  49 52 53 29 27 20 3b 3b    ='$(SUBDIRS)' ;;
+11504   20 5c 0a 09 65 73 61 63  3b 20 5c 0a 09 72 65 76     \..esac; \..rev
+11520   3d 27 27 3b 20 66 6f 72  20 73 75 62 64 69 72 20    =''; for subdir 
+11536   69 6e 20 24 24 6c 69 73  74 3b 20 64 6f 20 5c 0a    in $$list; do \.
+11552   09 20 20 69 66 20 74 65  73 74 20 22 24 24 73 75    .  if test "$$su
+11568   62 64 69 72 22 20 3d 20  22 2e 22 3b 20 74 68 65    bdir" = "."; the
+11584   6e 20 3a 3b 20 65 6c 73  65 20 5c 0a 09 20 20 20    n :; else \..   
+11600   20 72 65 76 3d 22 24 24  73 75 62 64 69 72 20 24     rev="$$subdir $
+11616   24 72 65 76 22 3b 20 5c  0a 09 20 20 66 69 3b 20    $rev"; \..  fi; 
+11632   5c 0a 09 64 6f 6e 65 3b  20 5c 0a 09 72 65 76 3d    \..done; \..rev=
+11648   22 24 24 72 65 76 20 2e  22 3b 20 5c 0a 09 74 61    "$$rev ."; \..ta
+11664   72 67 65 74 3d 60 65 63  68 6f 20 24 40 20 7c 20    rget=`echo $@ | 
+11680   73 65 64 20 73 2f 2d 72  65 63 75 72 73 69 76 65    sed s/-recursive
+11696   2f 2f 60 3b 20 5c 0a 09  66 6f 72 20 73 75 62 64    //`; \..for subd
+11712   69 72 20 69 6e 20 24 24  72 65 76 3b 20 64 6f 20    ir in $$rev; do 
+11728   5c 0a 09 20 20 65 63 68  6f 20 22 4d 61 6b 69 6e    \..  echo "Makin
+11744   67 20 24 24 74 61 72 67  65 74 20 69 6e 20 24 24    g $$target in $$
+11760   73 75 62 64 69 72 22 3b  20 5c 0a 09 20 20 69 66    subdir"; \..  if
+11776   20 74 65 73 74 20 22 24  24 73 75 62 64 69 72 22     test "$$subdir"
+11792   20 3d 20 22 2e 22 3b 20  74 68 65 6e 20 5c 0a 09     = "."; then \..
+11808   20 20 20 20 6c 6f 63 61  6c 5f 74 61 72 67 65 74        local_target
+11824   3d 22 24 24 74 61 72 67  65 74 2d 61 6d 22 3b 20    ="$$target-am"; 
+11840   5c 0a 09 20 20 65 6c 73  65 20 5c 0a 09 20 20 20    \..  else \..   
+11856   20 6c 6f 63 61 6c 5f 74  61 72 67 65 74 3d 22 24     local_target="$
+11872   24 74 61 72 67 65 74 22  3b 20 5c 0a 09 20 20 66    $target"; \..  f
+11888   69 3b 20 5c 0a 09 20 20  28 63 64 20 24 24 73 75    i; \..  (cd $$su
+11904   62 64 69 72 20 26 26 20  24 28 4d 41 4b 45 29 20    bdir && $(MAKE) 
+11920   24 28 41 4d 5f 4d 41 4b  45 46 4c 41 47 53 29 20    $(AM_MAKEFLAGS) 
+11936   24 24 6c 6f 63 61 6c 5f  74 61 72 67 65 74 29 20    $$local_target) 
+11952   5c 0a 09 20 20 7c 7c 20  65 76 61 6c 20 24 24 66    \..  || eval $$f
+11968   61 69 6c 63 6f 6d 3b 20  5c 0a 09 64 6f 6e 65 20    ailcom; \..done 
+11984   26 26 20 74 65 73 74 20  2d 7a 20 22 24 24 66 61    && test -z "$$fa
+12000   69 6c 22 0a 74 61 67 73  2d 72 65 63 75 72 73 69    il".tags-recursi
+12016   76 65 3a 0a 09 6c 69 73  74 3d 27 24 28 53 55 42    ve:..list='$(SUB
+12032   44 49 52 53 29 27 3b 20  66 6f 72 20 73 75 62 64    DIRS)'; for subd
+12048   69 72 20 69 6e 20 24 24  6c 69 73 74 3b 20 64 6f    ir in $$list; do
+12064   20 5c 0a 09 20 20 74 65  73 74 20 22 24 24 73 75     \..  test "$$su
+12080   62 64 69 72 22 20 3d 20  2e 20 7c 7c 20 28 63 64    bdir" = . || (cd
+12096   20 24 24 73 75 62 64 69  72 20 26 26 20 24 28 4d     $$subdir && $(M
+12112   41 4b 45 29 20 24 28 41  4d 5f 4d 41 4b 45 46 4c    AKE) $(AM_MAKEFL
+12128   41 47 53 29 20 74 61 67  73 29 3b 20 5c 0a 09 64    AGS) tags); \..d
+12144   6f 6e 65 0a 63 74 61 67  73 2d 72 65 63 75 72 73    one.ctags-recurs
+12160   69 76 65 3a 0a 09 6c 69  73 74 3d 27 24 28 53 55    ive:..list='$(SU
+12176   42 44 49 52 53 29 27 3b  20 66 6f 72 20 73 75 62    BDIRS)'; for sub
+12192   64 69 72 20 69 6e 20 24  24 6c 69 73 74 3b 20 64    dir in $$list; d
+12208   6f 20 5c 0a 09 20 20 74  65 73 74 20 22 24 24 73    o \..  test "$$s
+12224   75 62 64 69 72 22 20 3d  20 2e 20 7c 7c 20 28 63    ubdir" = . || (c
+12240   64 20 24 24 73 75 62 64  69 72 20 26 26 20 24 28    d $$subdir && $(
+12256   4d 41 4b 45 29 20 24 28  41 4d 5f 4d 41 4b 45 46    MAKE) $(AM_MAKEF
+12272   4c 41 47 53 29 20 63 74  61 67 73 29 3b 20 5c 0a    LAGS) ctags); \.
+12288   09 64 6f 6e 65 0a 0a 49  44 3a 20 24 28 48 45 41    .done..ID: $(HEA
+12304   44 45 52 53 29 20 24 28  53 4f 55 52 43 45 53 29    DERS) $(SOURCES)
+12320   20 24 28 4c 49 53 50 29  20 24 28 54 41 47 53 5f     $(LISP) $(TAGS_
+12336   46 49 4c 45 53 29 0a 09  6c 69 73 74 3d 27 24 28    FILES)..list='$(
+12352   53 4f 55 52 43 45 53 29  20 24 28 48 45 41 44 45    SOURCES) $(HEADE
+12368   52 53 29 20 24 28 4c 49  53 50 29 20 24 28 54 41    RS) $(LISP) $(TA
+12384   47 53 5f 46 49 4c 45 53  29 27 3b 20 5c 0a 09 75    GS_FILES)'; \..u
+12400   6e 69 71 75 65 3d 60 66  6f 72 20 69 20 69 6e 20    nique=`for i in 
+12416   24 24 6c 69 73 74 3b 20  64 6f 20 5c 0a 09 20 20    $$list; do \..  
+12432   20 20 69 66 20 74 65 73  74 20 2d 66 20 22 24 24      if test -f "$$
+12448   69 22 3b 20 74 68 65 6e  20 65 63 68 6f 20 24 24    i"; then echo $$
+12464   69 3b 20 65 6c 73 65 20  65 63 68 6f 20 24 28 73    i; else echo $(s
+12480   72 63 64 69 72 29 2f 24  24 69 3b 20 66 69 3b 20    rcdir)/$$i; fi; 
+12496   5c 0a 09 20 20 64 6f 6e  65 20 7c 20 5c 0a 09 20    \..  done | \.. 
+12512   20 24 28 41 57 4b 29 20  27 20 20 20 20 7b 20 66     $(AWK) '    { f
+12528   69 6c 65 73 5b 24 24 30  5d 20 3d 20 31 3b 20 7d    iles[$$0] = 1; }
+12544   20 5c 0a 09 20 20 20 20  20 20 20 45 4e 44 20 7b     \..       END {
+12560   20 66 6f 72 20 28 69 20  69 6e 20 66 69 6c 65 73     for (i in files
+12576   29 20 70 72 69 6e 74 20  69 3b 20 7d 27 60 3b 20    ) print i; }'`; 
+12592   5c 0a 09 6d 6b 69 64 20  2d 66 49 44 20 24 24 75    \..mkid -fID $$u
+12608   6e 69 71 75 65 0a 74 61  67 73 3a 20 54 41 47 53    nique.tags: TAGS
+12624   0a 0a 54 41 47 53 3a 20  74 61 67 73 2d 72 65 63    ..TAGS: tags-rec
+12640   75 72 73 69 76 65 20 24  28 48 45 41 44 45 52 53    ursive $(HEADERS
+12656   29 20 24 28 53 4f 55 52  43 45 53 29 20 63 6f 6e    ) $(SOURCES) con
+12672   66 69 67 2e 68 2e 69 6e  20 24 28 54 41 47 53 5f    fig.h.in $(TAGS_
+12688   44 45 50 45 4e 44 45 4e  43 49 45 53 29 20 5c 0a    DEPENDENCIES) \.
+12704   09 09 24 28 54 41 47 53  5f 46 49 4c 45 53 29 20    ..$(TAGS_FILES) 
+12720   24 28 4c 49 53 50 29 0a  09 74 61 67 73 3d 3b 20    $(LISP)..tags=; 
+12736   5c 0a 09 68 65 72 65 3d  60 70 77 64 60 3b 20 5c    \..here=`pwd`; \
+12752   0a 09 69 66 20 28 24 28  45 54 41 47 53 29 20 2d    ..if ($(ETAGS) -
+12768   2d 65 74 61 67 73 2d 69  6e 63 6c 75 64 65 20 2d    -etags-include -
+12784   2d 76 65 72 73 69 6f 6e  29 20 3e 2f 64 65 76 2f    -version) >/dev/
+12800   6e 75 6c 6c 20 32 3e 26  31 3b 20 74 68 65 6e 20    null 2>&1; then 
+12816   5c 0a 09 20 20 69 6e 63  6c 75 64 65 5f 6f 70 74    \..  include_opt
+12832   69 6f 6e 3d 2d 2d 65 74  61 67 73 2d 69 6e 63 6c    ion=--etags-incl
+12848   75 64 65 3b 20 5c 0a 09  20 20 65 6d 70 74 79 5f    ude; \..  empty_
+12864   66 69 78 3d 2e 3b 20 5c  0a 09 65 6c 73 65 20 5c    fix=.; \..else \
+12880   0a 09 20 20 69 6e 63 6c  75 64 65 5f 6f 70 74 69    ..  include_opti
+12896   6f 6e 3d 2d 2d 69 6e 63  6c 75 64 65 3b 20 5c 0a    on=--include; \.
+12912   09 20 20 65 6d 70 74 79  5f 66 69 78 3d 3b 20 5c    .  empty_fix=; \
+12928   0a 09 66 69 3b 20 5c 0a  09 6c 69 73 74 3d 27 24    ..fi; \..list='$
+12944   28 53 55 42 44 49 52 53  29 27 3b 20 66 6f 72 20    (SUBDIRS)'; for 
+12960   73 75 62 64 69 72 20 69  6e 20 24 24 6c 69 73 74    subdir in $$list
+12976   3b 20 64 6f 20 5c 0a 09  20 20 69 66 20 74 65 73    ; do \..  if tes
+12992   74 20 22 24 24 73 75 62  64 69 72 22 20 3d 20 2e    t "$$subdir" = .
+13008   3b 20 74 68 65 6e 20 3a  3b 20 65 6c 73 65 20 5c    ; then :; else \
+13024   0a 09 20 20 20 20 74 65  73 74 20 21 20 2d 66 20    ..    test ! -f 
+13040   24 24 73 75 62 64 69 72  2f 54 41 47 53 20 7c 7c    $$subdir/TAGS ||
+13056   20 5c 0a 09 20 20 20 20  20 20 74 61 67 73 3d 22     \..      tags="
+13072   24 24 74 61 67 73 20 24  24 69 6e 63 6c 75 64 65    $$tags $$include
+13088   5f 6f 70 74 69 6f 6e 3d  24 24 68 65 72 65 2f 24    _option=$$here/$
+13104   24 73 75 62 64 69 72 2f  54 41 47 53 22 3b 20 5c    $subdir/TAGS"; \
+13120   0a 09 20 20 66 69 3b 20  5c 0a 09 64 6f 6e 65 3b    ..  fi; \..done;
+13136   20 5c 0a 09 6c 69 73 74  3d 27 24 28 53 4f 55 52     \..list='$(SOUR
+13152   43 45 53 29 20 24 28 48  45 41 44 45 52 53 29 20    CES) $(HEADERS) 
+13168   63 6f 6e 66 69 67 2e 68  2e 69 6e 20 24 28 4c 49    config.h.in $(LI
+13184   53 50 29 20 24 28 54 41  47 53 5f 46 49 4c 45 53    SP) $(TAGS_FILES
+13200   29 27 3b 20 5c 0a 09 75  6e 69 71 75 65 3d 60 66    )'; \..unique=`f
+13216   6f 72 20 69 20 69 6e 20  24 24 6c 69 73 74 3b 20    or i in $$list; 
+13232   64 6f 20 5c 0a 09 20 20  20 20 69 66 20 74 65 73    do \..    if tes
+13248   74 20 2d 66 20 22 24 24  69 22 3b 20 74 68 65 6e    t -f "$$i"; then
+13264   20 65 63 68 6f 20 24 24  69 3b 20 65 6c 73 65 20     echo $$i; else 
+13280   65 63 68 6f 20 24 28 73  72 63 64 69 72 29 2f 24    echo $(srcdir)/$
+13296   24 69 3b 20 66 69 3b 20  5c 0a 09 20 20 64 6f 6e    $i; fi; \..  don
+13312   65 20 7c 20 5c 0a 09 20  20 24 28 41 57 4b 29 20    e | \..  $(AWK) 
+13328   27 20 20 20 20 7b 20 66  69 6c 65 73 5b 24 24 30    '    { files[$$0
+13344   5d 20 3d 20 31 3b 20 7d  20 5c 0a 09 20 20 20 20    ] = 1; } \..    
+13360   20 20 20 45 4e 44 20 7b  20 66 6f 72 20 28 69 20       END { for (i 
+13376   69 6e 20 66 69 6c 65 73  29 20 70 72 69 6e 74 20    in files) print 
+13392   69 3b 20 7d 27 60 3b 20  5c 0a 09 69 66 20 74 65    i; }'`; \..if te
+13408   73 74 20 2d 7a 20 22 24  28 45 54 41 47 53 5f 41    st -z "$(ETAGS_A
+13424   52 47 53 29 24 24 74 61  67 73 24 24 75 6e 69 71    RGS)$$tags$$uniq
+13440   75 65 22 3b 20 74 68 65  6e 20 3a 3b 20 65 6c 73    ue"; then :; els
+13456   65 20 5c 0a 09 20 20 74  65 73 74 20 2d 6e 20 22    e \..  test -n "
+13472   24 24 75 6e 69 71 75 65  22 20 7c 7c 20 75 6e 69    $$unique" || uni
+13488   71 75 65 3d 24 24 65 6d  70 74 79 5f 66 69 78 3b    que=$$empty_fix;
+13504   20 5c 0a 09 20 20 24 28  45 54 41 47 53 29 20 24     \..  $(ETAGS) $
+13520   28 45 54 41 47 53 46 4c  41 47 53 29 20 24 28 41    (ETAGSFLAGS) $(A
+13536   4d 5f 45 54 41 47 53 46  4c 41 47 53 29 20 24 28    M_ETAGSFLAGS) $(
+13552   45 54 41 47 53 5f 41 52  47 53 29 20 5c 0a 09 20    ETAGS_ARGS) \.. 
+13568   20 20 20 24 24 74 61 67  73 20 24 24 75 6e 69 71       $$tags $$uniq
+13584   75 65 3b 20 5c 0a 09 66  69 0a 63 74 61 67 73 3a    ue; \..fi.ctags:
+13600   20 43 54 41 47 53 0a 43  54 41 47 53 3a 20 63 74     CTAGS.CTAGS: ct
+13616   61 67 73 2d 72 65 63 75  72 73 69 76 65 20 24 28    ags-recursive $(
+13632   48 45 41 44 45 52 53 29  20 24 28 53 4f 55 52 43    HEADERS) $(SOURC
+13648   45 53 29 20 63 6f 6e 66  69 67 2e 68 2e 69 6e 20    ES) config.h.in 
+13664   24 28 54 41 47 53 5f 44  45 50 45 4e 44 45 4e 43    $(TAGS_DEPENDENC
+13680   49 45 53 29 20 5c 0a 09  09 24 28 54 41 47 53 5f    IES) \...$(TAGS_
+13696   46 49 4c 45 53 29 20 24  28 4c 49 53 50 29 0a 09    FILES) $(LISP)..
+13712   74 61 67 73 3d 3b 20 5c  0a 09 68 65 72 65 3d 60    tags=; \..here=`
+13728   70 77 64 60 3b 20 5c 0a  09 6c 69 73 74 3d 27 24    pwd`; \..list='$
+13744   28 53 4f 55 52 43 45 53  29 20 24 28 48 45 41 44    (SOURCES) $(HEAD
+13760   45 52 53 29 20 63 6f 6e  66 69 67 2e 68 2e 69 6e    ERS) config.h.in
+13776   20 24 28 4c 49 53 50 29  20 24 28 54 41 47 53 5f     $(LISP) $(TAGS_
+13792   46 49 4c 45 53 29 27 3b  20 5c 0a 09 75 6e 69 71    FILES)'; \..uniq
+13808   75 65 3d 60 66 6f 72 20  69 20 69 6e 20 24 24 6c    ue=`for i in $$l
+13824   69 73 74 3b 20 64 6f 20  5c 0a 09 20 20 20 20 69    ist; do \..    i
+13840   66 20 74 65 73 74 20 2d  66 20 22 24 24 69 22 3b    f test -f "$$i";
+13856   20 74 68 65 6e 20 65 63  68 6f 20 24 24 69 3b 20     then echo $$i; 
+13872   65 6c 73 65 20 65 63 68  6f 20 24 28 73 72 63 64    else echo $(srcd
+13888   69 72 29 2f 24 24 69 3b  20 66 69 3b 20 5c 0a 09    ir)/$$i; fi; \..
+13904   20 20 64 6f 6e 65 20 7c  20 5c 0a 09 20 20 24 28      done | \..  $(
+13920   41 57 4b 29 20 27 20 20  20 20 7b 20 66 69 6c 65    AWK) '    { file
+13936   73 5b 24 24 30 5d 20 3d  20 31 3b 20 7d 20 5c 0a    s[$$0] = 1; } \.
+13952   09 20 20 20 20 20 20 20  45 4e 44 20 7b 20 66 6f    .       END { fo
+13968   72 20 28 69 20 69 6e 20  66 69 6c 65 73 29 20 70    r (i in files) p
+13984   72 69 6e 74 20 69 3b 20  7d 27 60 3b 20 5c 0a 09    rint i; }'`; \..
+14000   74 65 73 74 20 2d 7a 20  22 24 28 43 54 41 47 53    test -z "$(CTAGS
+14016   5f 41 52 47 53 29 24 24  74 61 67 73 24 24 75 6e    _ARGS)$$tags$$un
+14032   69 71 75 65 22 20 5c 0a  09 20 20 7c 7c 20 24 28    ique" \..  || $(
+14048   43 54 41 47 53 29 20 24  28 43 54 41 47 53 46 4c    CTAGS) $(CTAGSFL
+14064   41 47 53 29 20 24 28 41  4d 5f 43 54 41 47 53 46    AGS) $(AM_CTAGSF
+14080   4c 41 47 53 29 20 24 28  43 54 41 47 53 5f 41 52    LAGS) $(CTAGS_AR
+14096   47 53 29 20 5c 0a 09 20  20 20 20 20 24 24 74 61    GS) \..     $$ta
+14112   67 73 20 24 24 75 6e 69  71 75 65 0a 0a 47 54 41    gs $$unique..GTA
+14128   47 53 3a 0a 09 68 65 72  65 3d 60 24 28 61 6d 5f    GS:..here=`$(am_
+14144   5f 63 64 29 20 24 28 74  6f 70 5f 62 75 69 6c 64    _cd) $(top_build
+14160   64 69 72 29 20 26 26 20  70 77 64 60 20 5c 0a 09    dir) && pwd` \..
+14176   20 20 26 26 20 63 64 20  24 28 74 6f 70 5f 73 72      && cd $(top_sr
+14192   63 64 69 72 29 20 5c 0a  09 20 20 26 26 20 67 74    cdir) \..  && gt
+14208   61 67 73 20 2d 69 20 24  28 47 54 41 47 53 5f 41    ags -i $(GTAGS_A
+14224   52 47 53 29 20 24 24 68  65 72 65 0a 0a 64 69 73    RGS) $$here..dis
+14240   74 63 6c 65 61 6e 2d 74  61 67 73 3a 0a 09 2d 72    tclean-tags:..-r
+14256   6d 20 2d 66 20 54 41 47  53 20 49 44 20 47 54 41    m -f TAGS ID GTA
+14272   47 53 20 47 52 54 41 47  53 20 47 53 59 4d 53 20    GS GRTAGS GSYMS 
+14288   47 50 41 54 48 20 74 61  67 73 0a 0a 64 69 73 74    GPATH tags..dist
+14304   64 69 72 3a 20 24 28 44  49 53 54 46 49 4c 45 53    dir: $(DISTFILES
+14320   29 0a 09 24 28 61 6d 5f  5f 72 65 6d 6f 76 65 5f    )..$(am__remove_
+14336   64 69 73 74 64 69 72 29  0a 09 6d 6b 64 69 72 20    distdir)..mkdir 
+14352   24 28 64 69 73 74 64 69  72 29 0a 09 40 73 72 63    $(distdir)..@src
+14368   64 69 72 73 74 72 69 70  3d 60 65 63 68 6f 20 22    dirstrip=`echo "
+14384   24 28 73 72 63 64 69 72  29 22 20 7c 20 73 65 64    $(srcdir)" | sed
+14400   20 27 73 7c 2e 7c 2e 7c  67 27 60 3b 20 5c 0a 09     's|.|.|g'`; \..
+14416   74 6f 70 73 72 63 64 69  72 73 74 72 69 70 3d 60    topsrcdirstrip=`
+14432   65 63 68 6f 20 22 24 28  74 6f 70 5f 73 72 63 64    echo "$(top_srcd
+14448   69 72 29 22 20 7c 20 73  65 64 20 27 73 7c 2e 7c    ir)" | sed 's|.|
+14464   2e 7c 67 27 60 3b 20 5c  0a 09 6c 69 73 74 3d 27    .|g'`; \..list='
+14480   24 28 44 49 53 54 46 49  4c 45 53 29 27 3b 20 66    $(DISTFILES)'; f
+14496   6f 72 20 66 69 6c 65 20  69 6e 20 24 24 6c 69 73    or file in $$lis
+14512   74 3b 20 64 6f 20 5c 0a  09 20 20 63 61 73 65 20    t; do \..  case 
+14528   24 24 66 69 6c 65 20 69  6e 20 5c 0a 09 20 20 20    $$file in \..   
+14544   20 24 28 73 72 63 64 69  72 29 2f 2a 29 20 66 69     $(srcdir)/*) fi
+14560   6c 65 3d 60 65 63 68 6f  20 22 24 24 66 69 6c 65    le=`echo "$$file
+14576   22 20 7c 20 73 65 64 20  22 73 7c 5e 24 24 73 72    " | sed "s|^$$sr
+14592   63 64 69 72 73 74 72 69  70 2f 7c 7c 22 60 3b 3b    cdirstrip/||"`;;
+14608   20 5c 0a 09 20 20 20 20  24 28 74 6f 70 5f 73 72     \..    $(top_sr
+14624   63 64 69 72 29 2f 2a 29  20 66 69 6c 65 3d 60 65    cdir)/*) file=`e
+14640   63 68 6f 20 22 24 24 66  69 6c 65 22 20 7c 20 73    cho "$$file" | s
+14656   65 64 20 22 73 7c 5e 24  24 74 6f 70 73 72 63 64    ed "s|^$$topsrcd
+14672   69 72 73 74 72 69 70 2f  7c 24 28 74 6f 70 5f 62    irstrip/|$(top_b
+14688   75 69 6c 64 64 69 72 29  2f 7c 22 60 3b 3b 20 5c    uilddir)/|"`;; \
+14704   0a 09 20 20 65 73 61 63  3b 20 5c 0a 09 20 20 69    ..  esac; \..  i
+14720   66 20 74 65 73 74 20 2d  66 20 24 24 66 69 6c 65    f test -f $$file
+14736   20 7c 7c 20 74 65 73 74  20 2d 64 20 24 24 66 69     || test -d $$fi
+14752   6c 65 3b 20 74 68 65 6e  20 64 3d 2e 3b 20 65 6c    le; then d=.; el
+14768   73 65 20 64 3d 24 28 73  72 63 64 69 72 29 3b 20    se d=$(srcdir); 
+14784   66 69 3b 20 5c 0a 09 20  20 64 69 72 3d 60 65 63    fi; \..  dir=`ec
+14800   68 6f 20 22 24 24 66 69  6c 65 22 20 7c 20 73 65    ho "$$file" | se
+14816   64 20 2d 65 20 27 73 2c  2f 5b 5e 2f 5d 2a 24 24    d -e 's,/[^/]*$$
+14832   2c 2c 27 60 3b 20 5c 0a  09 20 20 69 66 20 74 65    ,,'`; \..  if te
+14848   73 74 20 22 24 24 64 69  72 22 20 21 3d 20 22 24    st "$$dir" != "$
+14864   24 66 69 6c 65 22 20 26  26 20 74 65 73 74 20 22    $file" && test "
+14880   24 24 64 69 72 22 20 21  3d 20 22 2e 22 3b 20 74    $$dir" != "."; t
+14896   68 65 6e 20 5c 0a 09 20  20 20 20 64 69 72 3d 22    hen \..    dir="
+14912   2f 24 24 64 69 72 22 3b  20 5c 0a 09 20 20 20 20    /$$dir"; \..    
+14928   24 28 6d 6b 64 69 72 5f  70 29 20 22 24 28 64 69    $(mkdir_p) "$(di
+14944   73 74 64 69 72 29 24 24  64 69 72 22 3b 20 5c 0a    stdir)$$dir"; \.
+14960   09 20 20 65 6c 73 65 20  5c 0a 09 20 20 20 20 64    .  else \..    d
+14976   69 72 3d 27 27 3b 20 5c  0a 09 20 20 66 69 3b 20    ir=''; \..  fi; 
+14992   5c 0a 09 20 20 69 66 20  74 65 73 74 20 2d 64 20    \..  if test -d 
+15008   24 24 64 2f 24 24 66 69  6c 65 3b 20 74 68 65 6e    $$d/$$file; then
+15024   20 5c 0a 09 20 20 20 20  69 66 20 74 65 73 74 20     \..    if test 
+15040   2d 64 20 24 28 73 72 63  64 69 72 29 2f 24 24 66    -d $(srcdir)/$$f
+15056   69 6c 65 20 26 26 20 74  65 73 74 20 24 24 64 20    ile && test $$d 
+15072   21 3d 20 24 28 73 72 63  64 69 72 29 3b 20 74 68    != $(srcdir); th
+15088   65 6e 20 5c 0a 09 20 20  20 20 20 20 63 70 20 2d    en \..      cp -
+15104   70 52 20 24 28 73 72 63  64 69 72 29 2f 24 24 66    pR $(srcdir)/$$f
+15120   69 6c 65 20 24 28 64 69  73 74 64 69 72 29 24 24    ile $(distdir)$$
+15136   64 69 72 20 7c 7c 20 65  78 69 74 20 31 3b 20 5c    dir || exit 1; \
+15152   0a 09 20 20 20 20 66 69  3b 20 5c 0a 09 20 20 20    ..    fi; \..   
+15168   20 63 70 20 2d 70 52 20  24 24 64 2f 24 24 66 69     cp -pR $$d/$$fi
+15184   6c 65 20 24 28 64 69 73  74 64 69 72 29 24 24 64    le $(distdir)$$d
+15200   69 72 20 7c 7c 20 65 78  69 74 20 31 3b 20 5c 0a    ir || exit 1; \.
+15216   09 20 20 65 6c 73 65 20  5c 0a 09 20 20 20 20 74    .  else \..    t
+15232   65 73 74 20 2d 66 20 24  28 64 69 73 74 64 69 72    est -f $(distdir
+15248   29 2f 24 24 66 69 6c 65  20 5c 0a 09 20 20 20 20    )/$$file \..    
+15264   7c 7c 20 63 70 20 2d 70  20 24 24 64 2f 24 24 66    || cp -p $$d/$$f
+15280   69 6c 65 20 24 28 64 69  73 74 64 69 72 29 2f 24    ile $(distdir)/$
+15296   24 66 69 6c 65 20 5c 0a  09 20 20 20 20 7c 7c 20    $file \..    || 
+15312   65 78 69 74 20 31 3b 20  5c 0a 09 20 20 66 69 3b    exit 1; \..  fi;
+15328   20 5c 0a 09 64 6f 6e 65  0a 09 6c 69 73 74 3d 27     \..done..list='
+15344   24 28 44 49 53 54 5f 53  55 42 44 49 52 53 29 27    $(DIST_SUBDIRS)'
+15360   3b 20 66 6f 72 20 73 75  62 64 69 72 20 69 6e 20    ; for subdir in 
+15376   24 24 6c 69 73 74 3b 20  64 6f 20 5c 0a 09 20 20    $$list; do \..  
+15392   69 66 20 74 65 73 74 20  22 24 24 73 75 62 64 69    if test "$$subdi
+15408   72 22 20 3d 20 2e 3b 20  74 68 65 6e 20 3a 3b 20    r" = .; then :; 
+15424   65 6c 73 65 20 5c 0a 09  20 20 20 20 74 65 73 74    else \..    test
+15440   20 2d 64 20 22 24 28 64  69 73 74 64 69 72 29 2f     -d "$(distdir)/
+15456   24 24 73 75 62 64 69 72  22 20 5c 0a 09 20 20 20    $$subdir" \..   
+15472   20 7c 7c 20 24 28 6d 6b  64 69 72 5f 70 29 20 22     || $(mkdir_p) "
+15488   24 28 64 69 73 74 64 69  72 29 2f 24 24 73 75 62    $(distdir)/$$sub
+15504   64 69 72 22 20 5c 0a 09  20 20 20 20 7c 7c 20 65    dir" \..    || e
+15520   78 69 74 20 31 3b 20 5c  0a 09 20 20 20 20 64 69    xit 1; \..    di
+15536   73 74 64 69 72 3d 60 24  28 61 6d 5f 5f 63 64 29    stdir=`$(am__cd)
+15552   20 24 28 64 69 73 74 64  69 72 29 20 26 26 20 70     $(distdir) && p
+15568   77 64 60 3b 20 5c 0a 09  20 20 20 20 74 6f 70 5f    wd`; \..    top_
+15584   64 69 73 74 64 69 72 3d  60 24 28 61 6d 5f 5f 63    distdir=`$(am__c
+15600   64 29 20 24 28 74 6f 70  5f 64 69 73 74 64 69 72    d) $(top_distdir
+15616   29 20 26 26 20 70 77 64  60 3b 20 5c 0a 09 20 20    ) && pwd`; \..  
+15632   20 20 28 63 64 20 24 24  73 75 62 64 69 72 20 26      (cd $$subdir &
+15648   26 20 5c 0a 09 20 20 20  20 20 20 24 28 4d 41 4b    & \..      $(MAK
+15664   45 29 20 24 28 41 4d 5f  4d 41 4b 45 46 4c 41 47    E) $(AM_MAKEFLAG
+15680   53 29 20 5c 0a 09 20 20  20 20 20 20 20 20 74 6f    S) \..        to
+15696   70 5f 64 69 73 74 64 69  72 3d 22 24 24 74 6f 70    p_distdir="$$top
+15712   5f 64 69 73 74 64 69 72  22 20 5c 0a 09 20 20 20    _distdir" \..   
+15728   20 20 20 20 20 64 69 73  74 64 69 72 3d 22 24 24         distdir="$$
+15744   64 69 73 74 64 69 72 2f  24 24 73 75 62 64 69 72    distdir/$$subdir
+15760   22 20 5c 0a 09 20 20 20  20 20 20 20 20 64 69 73    " \..        dis
+15776   74 64 69 72 29 20 5c 0a  09 20 20 20 20 20 20 7c    tdir) \..      |
+15792   7c 20 65 78 69 74 20 31  3b 20 5c 0a 09 20 20 66    | exit 1; \..  f
+15808   69 3b 20 5c 0a 09 64 6f  6e 65 0a 09 2d 66 69 6e    i; \..done..-fin
+15824   64 20 24 28 64 69 73 74  64 69 72 29 20 2d 74 79    d $(distdir) -ty
+15840   70 65 20 64 20 21 20 2d  70 65 72 6d 20 2d 37 37    pe d ! -perm -77
+15856   37 20 2d 65 78 65 63 20  63 68 6d 6f 64 20 61 2b    7 -exec chmod a+
+15872   72 77 78 20 7b 7d 20 5c  3b 20 2d 6f 20 5c 0a 09    rwx {} \; -o \..
+15888   20 20 21 20 2d 74 79 70  65 20 64 20 21 20 2d 70      ! -type d ! -p
+15904   65 72 6d 20 2d 34 34 34  20 2d 6c 69 6e 6b 73 20    erm -444 -links 
+15920   31 20 2d 65 78 65 63 20  63 68 6d 6f 64 20 61 2b    1 -exec chmod a+
+15936   72 20 7b 7d 20 5c 3b 20  2d 6f 20 5c 0a 09 20 20    r {} \; -o \..  
+15952   21 20 2d 74 79 70 65 20  64 20 21 20 2d 70 65 72    ! -type d ! -per
+15968   6d 20 2d 34 30 30 20 2d  65 78 65 63 20 63 68 6d    m -400 -exec chm
+15984   6f 64 20 61 2b 72 20 7b  7d 20 5c 3b 20 2d 6f 20    od a+r {} \; -o 
+16000   5c 0a 09 20 20 21 20 2d  74 79 70 65 20 64 20 21    \..  ! -type d !
+16016   20 2d 70 65 72 6d 20 2d  34 34 34 20 2d 65 78 65     -perm -444 -exe
+16032   63 20 24 28 53 48 45 4c  4c 29 20 24 28 69 6e 73    c $(SHELL) $(ins
+16048   74 61 6c 6c 5f 73 68 29  20 2d 63 20 2d 6d 20 61    tall_sh) -c -m a
+16064   2b 72 20 7b 7d 20 7b 7d  20 5c 3b 20 5c 0a 09 7c    +r {} {} \; \..|
+16080   7c 20 63 68 6d 6f 64 20  2d 52 20 61 2b 72 20 24    | chmod -R a+r $
+16096   28 64 69 73 74 64 69 72  29 0a 64 69 73 74 2d 67    (distdir).dist-g
+16112   7a 69 70 3a 20 64 69 73  74 64 69 72 0a 09 74 61    zip: distdir..ta
+16128   72 64 69 72 3d 24 28 64  69 73 74 64 69 72 29 20    rdir=$(distdir) 
+16144   26 26 20 24 28 61 6d 5f  5f 74 61 72 29 20 7c 20    && $(am__tar) | 
+16160   47 5a 49 50 3d 24 28 47  5a 49 50 5f 45 4e 56 29    GZIP=$(GZIP_ENV)
+16176   20 67 7a 69 70 20 2d 63  20 3e 24 28 64 69 73 74     gzip -c >$(dist
+16192   64 69 72 29 2e 74 61 72  2e 67 7a 0a 09 24 28 61    dir).tar.gz..$(a
+16208   6d 5f 5f 72 65 6d 6f 76  65 5f 64 69 73 74 64 69    m__remove_distdi
+16224   72 29 0a 0a 64 69 73 74  2d 62 7a 69 70 32 3a 20    r)..dist-bzip2: 
+16240   64 69 73 74 64 69 72 0a  09 74 61 72 64 69 72 3d    distdir..tardir=
+16256   24 28 64 69 73 74 64 69  72 29 20 26 26 20 24 28    $(distdir) && $(
+16272   61 6d 5f 5f 74 61 72 29  20 7c 20 62 7a 69 70 32    am__tar) | bzip2
+16288   20 2d 39 20 2d 63 20 3e  24 28 64 69 73 74 64 69     -9 -c >$(distdi
+16304   72 29 2e 74 61 72 2e 62  7a 32 0a 09 24 28 61 6d    r).tar.bz2..$(am
+16320   5f 5f 72 65 6d 6f 76 65  5f 64 69 73 74 64 69 72    __remove_distdir
+16336   29 0a 0a 64 69 73 74 2d  74 61 72 5a 3a 20 64 69    )..dist-tarZ: di
+16352   73 74 64 69 72 0a 09 74  61 72 64 69 72 3d 24 28    stdir..tardir=$(
+16368   64 69 73 74 64 69 72 29  20 26 26 20 24 28 61 6d    distdir) && $(am
+16384   5f 5f 74 61 72 29 20 7c  20 63 6f 6d 70 72 65 73    __tar) | compres
+16400   73 20 2d 63 20 3e 24 28  64 69 73 74 64 69 72 29    s -c >$(distdir)
+16416   2e 74 61 72 2e 5a 0a 09  24 28 61 6d 5f 5f 72 65    .tar.Z..$(am__re
+16432   6d 6f 76 65 5f 64 69 73  74 64 69 72 29 0a 0a 64    move_distdir)..d
+16448   69 73 74 2d 73 68 61 72  3a 20 64 69 73 74 64 69    ist-shar: distdi
+16464   72 0a 09 73 68 61 72 20  24 28 64 69 73 74 64 69    r..shar $(distdi
+16480   72 29 20 7c 20 47 5a 49  50 3d 24 28 47 5a 49 50    r) | GZIP=$(GZIP
+16496   5f 45 4e 56 29 20 67 7a  69 70 20 2d 63 20 3e 24    _ENV) gzip -c >$
+16512   28 64 69 73 74 64 69 72  29 2e 73 68 61 72 2e 67    (distdir).shar.g
+16528   7a 0a 09 24 28 61 6d 5f  5f 72 65 6d 6f 76 65 5f    z..$(am__remove_
+16544   00 00 00 01 00 00 00 00  80 00 17 2c 2b 48 7c c2    ...........,+H|.
+16560   00 00 00 01 00 00 00 00  00 00 00 00 00 00 00 00    ................
+16576   00 00 00 00 00 00 00 01  00 00 00 00 00 00 00 00    ................
+16592   00 00 16 fb 64 69 73 74  64 69 72 29 0a 0a 64 69    ....distdir)..di
+16608   73 74 2d 7a 69 70 3a 20  64 69 73 74 64 69 72 0a    st-zip: distdir.
+16624   09 2d 72 6d 20 2d 66 20  24 28 64 69 73 74 64 69    .-rm -f $(distdi
+16640   72 29 2e 7a 69 70 0a 09  7a 69 70 20 2d 72 71 20    r).zip..zip -rq 
+16656   24 28 64 69 73 74 64 69  72 29 2e 7a 69 70 20 24    $(distdir).zip $
+16672   28 64 69 73 74 64 69 72  29 0a 09 24 28 61 6d 5f    (distdir)..$(am_
+16688   5f 72 65 6d 6f 76 65 5f  64 69 73 74 64 69 72 29    _remove_distdir)
+16704   0a 0a 64 69 73 74 20 64  69 73 74 2d 61 6c 6c 3a    ..dist dist-all:
+16720   20 64 69 73 74 64 69 72  0a 09 74 61 72 64 69 72     distdir..tardir
+16736   3d 24 28 64 69 73 74 64  69 72 29 20 26 26 20 24    =$(distdir) && $
+16752   28 61 6d 5f 5f 74 61 72  29 20 7c 20 47 5a 49 50    (am__tar) | GZIP
+16768   3d 24 28 47 5a 49 50 5f  45 4e 56 29 20 67 7a 69    =$(GZIP_ENV) gzi
+16784   70 20 2d 63 20 3e 24 28  64 69 73 74 64 69 72 29    p -c >$(distdir)
+16800   2e 74 61 72 2e 67 7a 0a  09 24 28 61 6d 5f 5f 72    .tar.gz..$(am__r
+16816   65 6d 6f 76 65 5f 64 69  73 74 64 69 72 29 0a 0a    emove_distdir)..
+16832   23 20 54 68 69 73 20 74  61 72 67 65 74 20 75 6e    # This target un
+16848   74 61 72 73 20 74 68 65  20 64 69 73 74 20 66 69    tars the dist fi
+16864   6c 65 20 61 6e 64 20 74  72 69 65 73 20 61 20 56    le and tries a V
+16880   50 41 54 48 20 63 6f 6e  66 69 67 75 72 61 74 69    PATH configurati
+16896   6f 6e 2e 20 20 54 68 65  6e 0a 23 20 69 74 20 67    on.  Then.# it g
+16912   75 61 72 61 6e 74 65 65  73 20 74 68 61 74 20 74    uarantees that t
+16928   68 65 20 64 69 73 74 72  69 62 75 74 69 6f 6e 20    he distribution 
+16944   69 73 20 73 65 6c 66 2d  63 6f 6e 74 61 69 6e 65    is self-containe
+16960   64 20 62 79 20 6d 61 6b  69 6e 67 20 61 6e 6f 74    d by making anot
+16976   68 65 72 0a 23 20 74 61  72 66 69 6c 65 2e 0a 64    her.# tarfile..d
+16992   69 73 74 63 68 65 63 6b  3a 20 64 69 73 74 0a 09    istcheck: dist..
+17008   63 61 73 65 20 27 24 28  44 49 53 54 5f 41 52 43    case '$(DIST_ARC
+17024   48 49 56 45 53 29 27 20  69 6e 20 5c 0a 09 2a 2e    HIVES)' in \..*.
+17040   74 61 72 2e 67 7a 2a 29  20 5c 0a 09 20 20 47 5a    tar.gz*) \..  GZ
+17056   49 50 3d 24 28 47 5a 49  50 5f 45 4e 56 29 20 67    IP=$(GZIP_ENV) g
+17072   75 6e 7a 69 70 20 2d 63  20 24 28 64 69 73 74 64    unzip -c $(distd
+17088   69 72 29 2e 74 61 72 2e  67 7a 20 7c 20 24 28 61    ir).tar.gz | $(a
+17104   6d 5f 5f 75 6e 74 61 72  29 20 3b 3b 5c 0a 09 2a    m__untar) ;;\..*
+17120   2e 74 61 72 2e 62 7a 32  2a 29 20 5c 0a 09 20 20    .tar.bz2*) \..  
+17136   62 75 6e 7a 69 70 32 20  2d 63 20 24 28 64 69 73    bunzip2 -c $(dis
+17152   74 64 69 72 29 2e 74 61  72 2e 62 7a 32 20 7c 20    tdir).tar.bz2 | 
+17168   24 28 61 6d 5f 5f 75 6e  74 61 72 29 20 3b 3b 5c    $(am__untar) ;;\
+17184   0a 09 2a 2e 74 61 72 2e  5a 2a 29 20 5c 0a 09 20    ..*.tar.Z*) \.. 
+17200   20 75 6e 63 6f 6d 70 72  65 73 73 20 2d 63 20 24     uncompress -c $
+17216   28 64 69 73 74 64 69 72  29 2e 74 61 72 2e 5a 20    (distdir).tar.Z 
+17232   7c 20 24 28 61 6d 5f 5f  75 6e 74 61 72 29 20 3b    | $(am__untar) ;
+17248   3b 5c 0a 09 2a 2e 73 68  61 72 2e 67 7a 2a 29 20    ;\..*.shar.gz*) 
+17264   5c 0a 09 20 20 47 5a 49  50 3d 24 28 47 5a 49 50    \..  GZIP=$(GZIP
+17280   5f 45 4e 56 29 20 67 75  6e 7a 69 70 20 2d 63 20    _ENV) gunzip -c 
+17296   24 28 64 69 73 74 64 69  72 29 2e 73 68 61 72 2e    $(distdir).shar.
+17312   67 7a 20 7c 20 75 6e 73  68 61 72 20 3b 3b 5c 0a    gz | unshar ;;\.
+17328   09 2a 2e 7a 69 70 2a 29  20 5c 0a 09 20 20 75 6e    .*.zip*) \..  un
+17344   7a 69 70 20 24 28 64 69  73 74 64 69 72 29 2e 7a    zip $(distdir).z
+17360   69 70 20 3b 3b 5c 0a 09  65 73 61 63 0a 09 63 68    ip ;;\..esac..ch
+17376   6d 6f 64 20 2d 52 20 61  2d 77 20 24 28 64 69 73    mod -R a-w $(dis
+17392   74 64 69 72 29 3b 20 63  68 6d 6f 64 20 61 2b 77    tdir); chmod a+w
+17408   20 24 28 64 69 73 74 64  69 72 29 0a 09 6d 6b 64     $(distdir)..mkd
+17424   69 72 20 24 28 64 69 73  74 64 69 72 29 2f 5f 62    ir $(distdir)/_b
+17440   75 69 6c 64 0a 09 6d 6b  64 69 72 20 24 28 64 69    uild..mkdir $(di
+17456   73 74 64 69 72 29 2f 5f  69 6e 73 74 0a 09 63 68    stdir)/_inst..ch
+17472   6d 6f 64 20 61 2d 77 20  24 28 64 69 73 74 64 69    mod a-w $(distdi
+17488   72 29 0a 09 64 63 5f 69  6e 73 74 61 6c 6c 5f 62    r)..dc_install_b
+17504   61 73 65 3d 60 24 28 61  6d 5f 5f 63 64 29 20 24    ase=`$(am__cd) $
+17520   28 64 69 73 74 64 69 72  29 2f 5f 69 6e 73 74 20    (distdir)/_inst 
+17536   26 26 20 70 77 64 20 7c  20 73 65 64 20 2d 65 20    && pwd | sed -e 
+17552   27 73 2c 5e 5b 5e 3a 5c  5c 2f 5d 3a 5b 5c 5c 2f    's,^[^:\\/]:[\\/
+17568   5d 2c 2f 2c 27 60 20 5c  0a 09 20 20 26 26 20 64    ],/,'` \..  && d
+17584   63 5f 64 65 73 74 64 69  72 3d 22 24 24 7b 54 4d    c_destdir="$${TM
+17600   50 44 49 52 2d 2f 74 6d  70 7d 2f 61 6d 2d 64 63    PDIR-/tmp}/am-dc
+17616   2d 24 24 24 24 2f 22 20  5c 0a 09 20 20 26 26 20    -$$$$/" \..  && 
+17632   63 64 20 24 28 64 69 73  74 64 69 72 29 2f 5f 62    cd $(distdir)/_b
+17648   75 69 6c 64 20 5c 0a 09  20 20 26 26 20 2e 2e 2f    uild \..  && ../
+17664   63 6f 6e 66 69 67 75 72  65 20 2d 2d 73 72 63 64    configure --srcd
+17680   69 72 3d 2e 2e 20 2d 2d  70 72 65 66 69 78 3d 22    ir=.. --prefix="
+17696   24 24 64 63 5f 69 6e 73  74 61 6c 6c 5f 62 61 73    $$dc_install_bas
+17712   65 22 20 5c 0a 09 20 20  20 20 24 28 44 49 53 54    e" \..    $(DIST
+17728   43 48 45 43 4b 5f 43 4f  4e 46 49 47 55 52 45 5f    CHECK_CONFIGURE_
+17744   46 4c 41 47 53 29 20 5c  0a 09 20 20 26 26 20 24    FLAGS) \..  && $
+17760   28 4d 41 4b 45 29 20 24  28 41 4d 5f 4d 41 4b 45    (MAKE) $(AM_MAKE
+17776   46 4c 41 47 53 29 20 5c  0a 09 20 20 26 26 20 24    FLAGS) \..  && $
+17792   28 4d 41 4b 45 29 20 24  28 41 4d 5f 4d 41 4b 45    (MAKE) $(AM_MAKE
+17808   46 4c 41 47 53 29 20 64  76 69 20 5c 0a 09 20 20    FLAGS) dvi \..  
+17824   26 26 20 24 28 4d 41 4b  45 29 20 24 28 41 4d 5f    && $(MAKE) $(AM_
+17840   4d 41 4b 45 46 4c 41 47  53 29 20 63 68 65 63 6b    MAKEFLAGS) check
+17856   20 5c 0a 09 20 20 26 26  20 24 28 4d 41 4b 45 29     \..  && $(MAKE)
+17872   20 24 28 41 4d 5f 4d 41  4b 45 46 4c 41 47 53 29     $(AM_MAKEFLAGS)
+17888   20 69 6e 73 74 61 6c 6c  20 5c 0a 09 20 20 26 26     install \..  &&
+17904   20 24 28 4d 41 4b 45 29  20 24 28 41 4d 5f 4d 41     $(MAKE) $(AM_MA
+17920   4b 45 46 4c 41 47 53 29  20 69 6e 73 74 61 6c 6c    KEFLAGS) install
+17936   63 68 65 63 6b 20 5c 0a  09 20 20 26 26 20 24 28    check \..  && $(
+17952   4d 41 4b 45 29 20 24 28  41 4d 5f 4d 41 4b 45 46    MAKE) $(AM_MAKEF
+17968   4c 41 47 53 29 20 75 6e  69 6e 73 74 61 6c 6c 20    LAGS) uninstall 
+17984   5c 0a 09 20 20 26 26 20  24 28 4d 41 4b 45 29 20    \..  && $(MAKE) 
+18000   24 28 41 4d 5f 4d 41 4b  45 46 4c 41 47 53 29 20    $(AM_MAKEFLAGS) 
+18016   64 69 73 74 75 6e 69 6e  73 74 61 6c 6c 63 68 65    distuninstallche
+18032   63 6b 5f 64 69 72 3d 22  24 24 64 63 5f 69 6e 73    ck_dir="$$dc_ins
+18048   74 61 6c 6c 5f 62 61 73  65 22 20 5c 0a 09 20 20    tall_base" \..  
+18064   20 20 20 20 20 20 64 69  73 74 75 6e 69 6e 73 74          distuninst
+18080   61 6c 6c 63 68 65 63 6b  20 5c 0a 09 20 20 26 26    allcheck \..  &&
+18096   20 63 68 6d 6f 64 20 2d  52 20 61 2d 77 20 22 24     chmod -R a-w "$
+18112   24 64 63 5f 69 6e 73 74  61 6c 6c 5f 62 61 73 65    $dc_install_base
+18128   22 20 5c 0a 09 20 20 26  26 20 28 7b 20 5c 0a 09    " \..  && ({ \..
+18144   20 20 20 20 20 20 20 28  63 64 20 2e 2e 2f 2e 2e           (cd ../..
+18160   20 26 26 20 75 6d 61 73  6b 20 30 37 37 20 26 26     && umask 077 &&
+18176   20 6d 6b 64 69 72 20 22  24 24 64 63 5f 64 65 73     mkdir "$$dc_des
+18192   74 64 69 72 22 29 20 5c  0a 09 20 20 20 20 20 20    tdir") \..      
+18208   20 26 26 20 24 28 4d 41  4b 45 29 20 24 28 41 4d     && $(MAKE) $(AM
+18224   5f 4d 41 4b 45 46 4c 41  47 53 29 20 44 45 53 54    _MAKEFLAGS) DEST
+18240   44 49 52 3d 22 24 24 64  63 5f 64 65 73 74 64 69    DIR="$$dc_destdi
+18256   72 22 20 69 6e 73 74 61  6c 6c 20 5c 0a 09 20 20    r" install \..  
+18272   20 20 20 20 20 26 26 20  24 28 4d 41 4b 45 29 20         && $(MAKE) 
+18288   24 28 41 4d 5f 4d 41 4b  45 46 4c 41 47 53 29 20    $(AM_MAKEFLAGS) 
+18304   44 45 53 54 44 49 52 3d  22 24 24 64 63 5f 64 65    DESTDIR="$$dc_de
+18320   73 74 64 69 72 22 20 75  6e 69 6e 73 74 61 6c 6c    stdir" uninstall
+18336   20 5c 0a 09 20 20 20 20  20 20 20 26 26 20 24 28     \..       && $(
+18352   4d 41 4b 45 29 20 24 28  41 4d 5f 4d 41 4b 45 46    MAKE) $(AM_MAKEF
+18368   4c 41 47 53 29 20 44 45  53 54 44 49 52 3d 22 24    LAGS) DESTDIR="$
+18384   24 64 63 5f 64 65 73 74  64 69 72 22 20 5c 0a 09    $dc_destdir" \..
+18400   20 20 20 20 20 20 20 20  20 20 20 20 64 69 73 74                dist
+18416   75 6e 69 6e 73 74 61 6c  6c 63 68 65 63 6b 5f 64    uninstallcheck_d
+18432   69 72 3d 22 24 24 64 63  5f 64 65 73 74 64 69 72    ir="$$dc_destdir
+18448   22 20 64 69 73 74 75 6e  69 6e 73 74 61 6c 6c 63    " distuninstallc
+18464   68 65 63 6b 3b 20 5c 0a  09 20 20 20 20 20 20 7d    heck; \..      }
+18480   20 7c 7c 20 7b 20 72 6d  20 2d 72 66 20 22 24 24     || { rm -rf "$$
+18496   64 63 5f 64 65 73 74 64  69 72 22 3b 20 65 78 69    dc_destdir"; exi
+18512   74 20 31 3b 20 7d 29 20  5c 0a 09 20 20 26 26 20    t 1; }) \..  && 
+18528   72 6d 20 2d 72 66 20 22  24 24 64 63 5f 64 65 73    rm -rf "$$dc_des
+18544   74 64 69 72 22 20 5c 0a  09 20 20 26 26 20 24 28    tdir" \..  && $(
+18560   4d 41 4b 45 29 20 24 28  41 4d 5f 4d 41 4b 45 46    MAKE) $(AM_MAKEF
+18576   4c 41 47 53 29 20 64 69  73 74 20 5c 0a 09 20 20    LAGS) dist \..  
+18592   26 26 20 72 6d 20 2d 72  66 20 24 28 44 49 53 54    && rm -rf $(DIST
+18608   5f 41 52 43 48 49 56 45  53 29 20 5c 0a 09 20 20    _ARCHIVES) \..  
+18624   26 26 20 24 28 4d 41 4b  45 29 20 24 28 41 4d 5f    && $(MAKE) $(AM_
+18640   4d 41 4b 45 46 4c 41 47  53 29 20 64 69 73 74 63    MAKEFLAGS) distc
+18656   6c 65 61 6e 63 68 65 63  6b 0a 09 24 28 61 6d 5f    leancheck..$(am_
+18672   5f 72 65 6d 6f 76 65 5f  64 69 73 74 64 69 72 29    _remove_distdir)
+18688   0a 09 40 28 65 63 68 6f  20 22 24 28 64 69 73 74    ..@(echo "$(dist
+18704   64 69 72 29 20 61 72 63  68 69 76 65 73 20 72 65    dir) archives re
+18720   61 64 79 20 66 6f 72 20  64 69 73 74 72 69 62 75    ady for distribu
+18736   74 69 6f 6e 3a 20 22 3b  20 5c 0a 09 20 20 6c 69    tion: "; \..  li
+18752   73 74 3d 27 24 28 44 49  53 54 5f 41 52 43 48 49    st='$(DIST_ARCHI
+18768   56 45 53 29 27 3b 20 66  6f 72 20 69 20 69 6e 20    VES)'; for i in 
+18784   24 24 6c 69 73 74 3b 20  64 6f 20 65 63 68 6f 20    $$list; do echo 
+18800   24 24 69 3b 20 64 6f 6e  65 29 20 7c 20 5c 0a 09    $$i; done) | \..
+18816   20 20 73 65 64 20 2d 65  20 27 31 7b 68 3b 73 2f      sed -e '1{h;s/
+18832   2e 2f 3d 2f 67 3b 70 3b  78 3b 7d 27 20 2d 65 20    ./=/g;p;x;}' -e 
+18848   27 24 24 7b 70 3b 78 3b  7d 27 0a 64 69 73 74 75    '$${p;x;}'.distu
+18864   6e 69 6e 73 74 61 6c 6c  63 68 65 63 6b 3a 0a 09    ninstallcheck:..
+18880   40 63 64 20 24 28 64 69  73 74 75 6e 69 6e 73 74    @cd $(distuninst
+18896   61 6c 6c 63 68 65 63 6b  5f 64 69 72 29 20 5c 0a    allcheck_dir) \.
+18912   09 26 26 20 74 65 73 74  20 60 24 28 64 69 73 74    .&& test `$(dist
+18928   75 6e 69 6e 73 74 61 6c  6c 63 68 65 63 6b 5f 6c    uninstallcheck_l
+18944   69 73 74 66 69 6c 65 73  29 20 7c 20 77 63 20 2d    istfiles) | wc -
+18960   6c 60 20 2d 6c 65 20 31  20 5c 0a 09 20 20 20 7c    l` -le 1 \..   |
+18976   7c 20 7b 20 65 63 68 6f  20 22 45 52 52 4f 52 3a    | { echo "ERROR:
+18992   20 66 69 6c 65 73 20 6c  65 66 74 20 61 66 74 65     files left afte
+19008   72 20 75 6e 69 6e 73 74  61 6c 6c 3a 22 20 3b 20    r uninstall:" ; 
+19024   5c 0a 09 20 20 20 20 20  20 20 20 69 66 20 74 65    \..        if te
+19040   73 74 20 2d 6e 20 22 24  28 44 45 53 54 44 49 52    st -n "$(DESTDIR
+19056   29 22 3b 20 74 68 65 6e  20 5c 0a 09 20 20 20 20    )"; then \..    
+19072   20 20 20 20 20 20 65 63  68 6f 20 22 20 20 28 63          echo "  (c
+19088   68 65 63 6b 20 44 45 53  54 44 49 52 20 73 75 70    heck DESTDIR sup
+19104   70 6f 72 74 29 22 3b 20  5c 0a 09 20 20 20 20 20    port)"; \..     
+19120   20 20 20 66 69 20 3b 20  5c 0a 09 20 20 20 20 20       fi ; \..     
+19136   20 20 20 24 28 64 69 73  74 75 6e 69 6e 73 74 61       $(distuninsta
+19152   6c 6c 63 68 65 63 6b 5f  6c 69 73 74 66 69 6c 65    llcheck_listfile
+19168   73 29 20 3b 20 5c 0a 09  20 20 20 20 20 20 20 20    s) ; \..        
+19184   65 78 69 74 20 31 3b 20  7d 20 3e 26 32 0a 64 69    exit 1; } >&2.di
+19200   73 74 63 6c 65 61 6e 63  68 65 63 6b 3a 20 64 69    stcleancheck: di
+19216   73 74 63 6c 65 61 6e 0a  09 40 69 66 20 74 65 73    stclean..@if tes
+19232   74 20 27 24 28 73 72 63  64 69 72 29 27 20 3d 20    t '$(srcdir)' = 
+19248   2e 20 3b 20 74 68 65 6e  20 5c 0a 09 20 20 65 63    . ; then \..  ec
+19264   68 6f 20 22 45 52 52 4f  52 3a 20 64 69 73 74 63    ho "ERROR: distc
+19280   6c 65 61 6e 63 68 65 63  6b 20 63 61 6e 20 6f 6e    leancheck can on
+19296   6c 79 20 72 75 6e 20 66  72 6f 6d 20 61 20 56 50    ly run from a VP
+19312   41 54 48 20 62 75 69 6c  64 22 20 3b 20 5c 0a 09    ATH build" ; \..
+19328   20 20 65 78 69 74 20 31  20 3b 20 5c 0a 09 66 69      exit 1 ; \..fi
+19344   0a 09 40 74 65 73 74 20  60 24 28 64 69 73 74 63    ..@test `$(distc
+19360   6c 65 61 6e 63 68 65 63  6b 5f 6c 69 73 74 66 69    leancheck_listfi
+19376   6c 65 73 29 20 7c 20 77  63 20 2d 6c 60 20 2d 65    les) | wc -l` -e
+19392   71 20 30 20 5c 0a 09 20  20 7c 7c 20 7b 20 65 63    q 0 \..  || { ec
+19408   68 6f 20 22 45 52 52 4f  52 3a 20 66 69 6c 65 73    ho "ERROR: files
+19424   20 6c 65 66 74 20 69 6e  20 62 75 69 6c 64 20 64     left in build d
+19440   69 72 65 63 74 6f 72 79  20 61 66 74 65 72 20 64    irectory after d
+19456   69 73 74 63 6c 65 61 6e  3a 22 20 3b 20 5c 0a 09    istclean:" ; \..
+19472   20 20 20 20 20 20 20 24  28 64 69 73 74 63 6c 65           $(distcle
+19488   61 6e 63 68 65 63 6b 5f  6c 69 73 74 66 69 6c 65    ancheck_listfile
+19504   73 29 20 3b 20 5c 0a 09  20 20 20 20 20 20 20 65    s) ; \..       e
+19520   78 69 74 20 31 3b 20 7d  20 3e 26 32 0a 63 68 65    xit 1; } >&2.che
+19536   63 6b 2d 61 6d 3a 20 61  6c 6c 2d 61 6d 0a 63 68    ck-am: all-am.ch
+19552   65 63 6b 3a 20 63 68 65  63 6b 2d 72 65 63 75 72    eck: check-recur
+19568   73 69 76 65 0a 61 6c 6c  2d 61 6d 3a 20 4d 61 6b    sive.all-am: Mak
+19584   65 66 69 6c 65 20 63 6f  6e 66 69 67 2e 68 0a 69    efile config.h.i
+19600   6e 73 74 61 6c 6c 64 69  72 73 3a 20 69 6e 73 74    nstalldirs: inst
+19616   61 6c 6c 64 69 72 73 2d  72 65 63 75 72 73 69 76    alldirs-recursiv
+19632   65 0a 69 6e 73 74 61 6c  6c 64 69 72 73 2d 61 6d    e.installdirs-am
+19648   3a 0a 69 6e 73 74 61 6c  6c 3a 20 69 6e 73 74 61    :.install: insta
+19664   6c 6c 2d 72 65 63 75 72  73 69 76 65 0a 69 6e 73    ll-recursive.ins
+19680   74 61 6c 6c 2d 65 78 65  63 3a 20 69 6e 73 74 61    tall-exec: insta
+19696   6c 6c 2d 65 78 65 63 2d  72 65 63 75 72 73 69 76    ll-exec-recursiv
+19712   65 0a 69 6e 73 74 61 6c  6c 2d 64 61 74 61 3a 20    e.install-data: 
+19728   69 6e 73 74 61 6c 6c 2d  64 61 74 61 2d 72 65 63    install-data-rec
+19744   75 72 73 69 76 65 0a 75  6e 69 6e 73 74 61 6c 6c    ursive.uninstall
+19760   3a 20 75 6e 69 6e 73 74  61 6c 6c 2d 72 65 63 75    : uninstall-recu
+19776   72 73 69 76 65 0a 0a 69  6e 73 74 61 6c 6c 2d 61    rsive..install-a
+19792   6d 3a 20 61 6c 6c 2d 61  6d 0a 09 40 24 28 4d 41    m: all-am..@$(MA
+19808   4b 45 29 20 24 28 41 4d  5f 4d 41 4b 45 46 4c 41    KE) $(AM_MAKEFLA
+19824   47 53 29 20 69 6e 73 74  61 6c 6c 2d 65 78 65 63    GS) install-exec
+19840   2d 61 6d 20 69 6e 73 74  61 6c 6c 2d 64 61 74 61    -am install-data
+19856   2d 61 6d 0a 0a 69 6e 73  74 61 6c 6c 63 68 65 63    -am..installchec
+19872   6b 3a 20 69 6e 73 74 61  6c 6c 63 68 65 63 6b 2d    k: installcheck-
+19888   72 65 63 75 72 73 69 76  65 0a 69 6e 73 74 61 6c    recursive.instal
+19904   6c 2d 73 74 72 69 70 3a  0a 09 24 28 4d 41 4b 45    l-strip:..$(MAKE
+19920   29 20 24 28 41 4d 5f 4d  41 4b 45 46 4c 41 47 53    ) $(AM_MAKEFLAGS
+19936   29 20 49 4e 53 54 41 4c  4c 5f 50 52 4f 47 52 41    ) INSTALL_PROGRA
+19952   4d 3d 22 24 28 49 4e 53  54 41 4c 4c 5f 53 54 52    M="$(INSTALL_STR
+19968   49 50 5f 50 52 4f 47 52  41 4d 29 22 20 5c 0a 09    IP_PROGRAM)" \..
+19984   20 20 69 6e 73 74 61 6c  6c 5f 73 68 5f 50 52 4f      install_sh_PRO
+20000   47 52 41 4d 3d 22 24 28  49 4e 53 54 41 4c 4c 5f    GRAM="$(INSTALL_
+20016   53 54 52 49 50 5f 50 52  4f 47 52 41 4d 29 22 20    STRIP_PROGRAM)" 
+20032   49 4e 53 54 41 4c 4c 5f  53 54 52 49 50 5f 46 4c    INSTALL_STRIP_FL
+20048   41 47 3d 2d 73 20 5c 0a  09 20 20 60 74 65 73 74    AG=-s \..  `test
+20064   20 2d 7a 20 27 24 28 53  54 52 49 50 29 27 20 7c     -z '$(STRIP)' |
+20080   7c 20 5c 0a 09 20 20 20  20 65 63 68 6f 20 22 49    | \..    echo "I
+20096   4e 53 54 41 4c 4c 5f 50  52 4f 47 52 41 4d 5f 45    NSTALL_PROGRAM_E
+20112   4e 56 3d 53 54 52 49 50  50 52 4f 47 3d 27 24 28    NV=STRIPPROG='$(
+20128   53 54 52 49 50 29 27 22  60 20 69 6e 73 74 61 6c    STRIP)'"` instal
+20144   6c 0a 6d 6f 73 74 6c 79  63 6c 65 61 6e 2d 67 65    l.mostlyclean-ge
+20160   6e 65 72 69 63 3a 0a 0a  63 6c 65 61 6e 2d 67 65    neric:..clean-ge
+20176   6e 65 72 69 63 3a 0a 09  2d 74 65 73 74 20 2d 7a    neric:..-test -z
+20192   20 22 24 28 43 4c 45 41  4e 46 49 4c 45 53 29 22     "$(CLEANFILES)"
+20208   20 7c 7c 20 72 6d 20 2d  66 20 24 28 43 4c 45 41     || rm -f $(CLEA
+20224   4e 46 49 4c 45 53 29 0a  0a 64 69 73 74 63 6c 65    NFILES)..distcle
+20240   61 6e 2d 67 65 6e 65 72  69 63 3a 0a 09 2d 74 65    an-generic:..-te
+20256   73 74 20 2d 7a 20 22 24  28 43 4f 4e 46 49 47 5f    st -z "$(CONFIG_
+20272   43 4c 45 41 4e 5f 46 49  4c 45 53 29 22 20 7c 7c    CLEAN_FILES)" ||
+20288   20 72 6d 20 2d 66 20 24  28 43 4f 4e 46 49 47 5f     rm -f $(CONFIG_
+20304   43 4c 45 41 4e 5f 46 49  4c 45 53 29 0a 09 2d 74    CLEAN_FILES)..-t
+20320   65 73 74 20 2d 7a 20 22  24 28 44 49 53 54 43 4c    est -z "$(DISTCL
+20336   45 41 4e 46 49 4c 45 53  29 22 20 7c 7c 20 72 6d    EANFILES)" || rm
+20352   20 2d 66 20 24 28 44 49  53 54 43 4c 45 41 4e 46     -f $(DISTCLEANF
+20368   49 4c 45 53 29 0a 0a 6d  61 69 6e 74 61 69 6e 65    ILES)..maintaine
+20384   72 2d 63 6c 65 61 6e 2d  67 65 6e 65 72 69 63 3a    r-clean-generic:
+20400   0a 09 40 65 63 68 6f 20  22 54 68 69 73 20 63 6f    ..@echo "This co
+20416   6d 6d 61 6e 64 20 69 73  20 69 6e 74 65 6e 64 65    mmand is intende
+20432   64 20 66 6f 72 20 6d 61  69 6e 74 61 69 6e 65 72    d for maintainer
+20448   73 20 74 6f 20 75 73 65  22 0a 09 40 65 63 68 6f    s to use"..@echo
+20464   20 22 69 74 20 64 65 6c  65 74 65 73 20 66 69 6c     "it deletes fil
+20480   65 73 20 74 68 61 74 20  6d 61 79 20 72 65 71 75    es that may requ
+20496   69 72 65 20 73 70 65 63  69 61 6c 20 74 6f 6f 6c    ire special tool
+20512   73 20 74 6f 20 72 65 62  75 69 6c 64 2e 22 0a 09    s to rebuild."..
+20528   2d 74 65 73 74 20 2d 7a  20 22 24 28 4d 41 49 4e    -test -z "$(MAIN
+20544   54 41 49 4e 45 52 43 4c  45 41 4e 46 49 4c 45 53    TAINERCLEANFILES
+20560   29 22 20 7c 7c 20 72 6d  20 2d 66 20 24 28 4d 41    )" || rm -f $(MA
+20576   49 4e 54 41 49 4e 45 52  43 4c 45 41 4e 46 49 4c    INTAINERCLEANFIL
+20592   45 53 29 0a 63 6c 65 61  6e 3a 20 63 6c 65 61 6e    ES).clean: clean
+20608   2d 72 65 63 75 72 73 69  76 65 0a 0a 63 6c 65 61    -recursive..clea
+20624   6e 2d 61 6d 3a 20 63 6c  65 61 6e 2d 67 65 6e 65    n-am: clean-gene
+20640   72 69 63 20 63 6c 65 61  6e 2d 6c 69 62 74 6f 6f    ric clean-libtoo
+20656   6c 20 6d 6f 73 74 6c 79  63 6c 65 61 6e 2d 61 6d    l mostlyclean-am
+20672   0a 0a 64 69 73 74 63 6c  65 61 6e 3a 20 64 69 73    ..distclean: dis
+20688   74 63 6c 65 61 6e 2d 72  65 63 75 72 73 69 76 65    tclean-recursive
+20704   0a 09 2d 72 6d 20 2d 66  20 24 28 61 6d 5f 5f 43    ..-rm -f $(am__C
+20720   4f 4e 46 49 47 5f 44 49  53 54 43 4c 45 41 4e 5f    ONFIG_DISTCLEAN_
+20736   46 49 4c 45 53 29 0a 09  2d 72 6d 20 2d 66 20 4d    FILES)..-rm -f M
+20752   61 6b 65 66 69 6c 65 0a  64 69 73 74 63 6c 65 61    akefile.distclea
+20768   6e 2d 61 6d 3a 20 63 6c  65 61 6e 2d 61 6d 20 64    n-am: clean-am d
+20784   69 73 74 63 6c 65 61 6e  2d 67 65 6e 65 72 69 63    istclean-generic
+20800   20 64 69 73 74 63 6c 65  61 6e 2d 68 64 72 20 5c     distclean-hdr \
+20816   0a 09 64 69 73 74 63 6c  65 61 6e 2d 6c 69 62 74    ..distclean-libt
+20832   6f 6f 6c 20 64 69 73 74  63 6c 65 61 6e 2d 74 61    ool distclean-ta
+20848   67 73 0a 0a 64 76 69 3a  20 64 76 69 2d 72 65 63    gs..dvi: dvi-rec
+20864   75 72 73 69 76 65 0a 0a  64 76 69 2d 61 6d 3a 0a    ursive..dvi-am:.
+20880   0a 68 74 6d 6c 3a 20 68  74 6d 6c 2d 72 65 63 75    .html: html-recu
+20896   72 73 69 76 65 0a 0a 69  6e 66 6f 3a 20 69 6e 66    rsive..info: inf
+20912   6f 2d 72 65 63 75 72 73  69 76 65 0a 0a 69 6e 66    o-recursive..inf
+20928   6f 2d 61 6d 3a 0a 0a 69  6e 73 74 61 6c 6c 2d 64    o-am:..install-d
+20944   61 74 61 2d 61 6d 3a 0a  0a 69 6e 73 74 61 6c 6c    ata-am:..install
+20960   2d 65 78 65 63 2d 61 6d  3a 0a 0a 69 6e 73 74 61    -exec-am:..insta
+20976   6c 6c 2d 69 6e 66 6f 3a  20 69 6e 73 74 61 6c 6c    ll-info: install
+20992   2d 69 6e 66 6f 2d 72 65  63 75 72 73 69 76 65 0a    -info-recursive.
+21008   0a 69 6e 73 74 61 6c 6c  2d 6d 61 6e 3a 0a 0a 69    .install-man:..i
+21024   6e 73 74 61 6c 6c 63 68  65 63 6b 2d 61 6d 3a 0a    nstallcheck-am:.
+21040   0a 6d 61 69 6e 74 61 69  6e 65 72 2d 63 6c 65 61    .maintainer-clea
+21056   6e 3a 20 6d 61 69 6e 74  61 69 6e 65 72 2d 63 6c    n: maintainer-cl
+21072   65 61 6e 2d 72 65 63 75  72 73 69 76 65 0a 09 2d    ean-recursive..-
+21088   72 6d 20 2d 66 20 24 28  61 6d 5f 5f 43 4f 4e 46    rm -f $(am__CONF
+21104   49 47 5f 44 49 53 54 43  4c 45 41 4e 5f 46 49 4c    IG_DISTCLEAN_FIL
+21120   45 53 29 0a 09 2d 72 6d  20 2d 72 66 20 24 28 74    ES)..-rm -rf $(t
+21136   6f 70 5f 73 72 63 64 69  72 29 2f 61 75 74 6f 6d    op_srcdir)/autom
+21152   34 74 65 2e 63 61 63 68  65 0a 09 2d 72 6d 20 2d    4te.cache..-rm -
+21168   66 20 4d 61 6b 65 66 69  6c 65 0a 6d 61 69 6e 74    f Makefile.maint
+21184   61 69 6e 65 72 2d 63 6c  65 61 6e 2d 61 6d 3a 20    ainer-clean-am: 
+21200   64 69 73 74 63 6c 65 61  6e 2d 61 6d 20 6d 61 69    distclean-am mai
+21216   6e 74 61 69 6e 65 72 2d  63 6c 65 61 6e 2d 67 65    ntainer-clean-ge
+21232   6e 65 72 69 63 0a 0a 6d  6f 73 74 6c 79 63 6c 65    neric..mostlycle
+21248   61 6e 3a 20 6d 6f 73 74  6c 79 63 6c 65 61 6e 2d    an: mostlyclean-
+21264   72 65 63 75 72 73 69 76  65 0a 0a 6d 6f 73 74 6c    recursive..mostl
+21280   79 63 6c 65 61 6e 2d 61  6d 3a 20 6d 6f 73 74 6c    yclean-am: mostl
+21296   79 63 6c 65 61 6e 2d 67  65 6e 65 72 69 63 20 6d    yclean-generic m
+21312   6f 73 74 6c 79 63 6c 65  61 6e 2d 6c 69 62 74 6f    ostlyclean-libto
+21328   6f 6c 0a 0a 70 64 66 3a  20 70 64 66 2d 72 65 63    ol..pdf: pdf-rec
+21344   75 72 73 69 76 65 0a 0a  70 64 66 2d 61 6d 3a 0a    ursive..pdf-am:.
+21360   0a 70 73 3a 20 70 73 2d  72 65 63 75 72 73 69 76    .ps: ps-recursiv
+21376   65 0a 0a 70 73 2d 61 6d  3a 0a 0a 75 6e 69 6e 73    e..ps-am:..unins
+21392   74 61 6c 6c 2d 61 6d 3a  20 75 6e 69 6e 73 74 61    tall-am: uninsta
+21408   6c 6c 2d 69 6e 66 6f 2d  61 6d 0a 0a 75 6e 69 6e    ll-info-am..unin
+21424   73 74 61 6c 6c 2d 69 6e  66 6f 3a 20 75 6e 69 6e    stall-info: unin
+21440   73 74 61 6c 6c 2d 69 6e  66 6f 2d 72 65 63 75 72    stall-info-recur
+21456   73 69 76 65 0a 0a 2e 50  48 4f 4e 59 3a 20 24 28    sive...PHONY: $(
+21472   52 45 43 55 52 53 49 56  45 5f 54 41 52 47 45 54    RECURSIVE_TARGET
+21488   53 29 20 43 54 41 47 53  20 47 54 41 47 53 20 61    S) CTAGS GTAGS a
+21504   6c 6c 20 61 6c 6c 2d 61  6d 20 61 6d 2d 2d 72 65    ll all-am am--re
+21520   66 72 65 73 68 20 63 68  65 63 6b 20 5c 0a 09 63    fresh check \..c
+21536   68 65 63 6b 2d 61 6d 20  63 6c 65 61 6e 20 63 6c    heck-am clean cl
+21552   65 61 6e 2d 67 65 6e 65  72 69 63 20 63 6c 65 61    ean-generic clea
+21568   6e 2d 6c 69 62 74 6f 6f  6c 20 63 6c 65 61 6e 2d    n-libtool clean-
+21584   72 65 63 75 72 73 69 76  65 20 5c 0a 09 63 74 61    recursive \..cta
+21600   67 73 20 63 74 61 67 73  2d 72 65 63 75 72 73 69    gs ctags-recursi
+21616   76 65 20 64 69 73 74 20  64 69 73 74 2d 61 6c 6c    ve dist dist-all
+21632   20 64 69 73 74 2d 62 7a  69 70 32 20 64 69 73 74     dist-bzip2 dist
+21648   2d 67 7a 69 70 20 5c 0a  09 64 69 73 74 2d 73 68    -gzip \..dist-sh
+21664   61 72 20 64 69 73 74 2d  74 61 72 5a 20 64 69 73    ar dist-tarZ dis
+21680   74 2d 7a 69 70 20 64 69  73 74 63 68 65 63 6b 20    t-zip distcheck 
+21696   64 69 73 74 63 6c 65 61  6e 20 5c 0a 09 64 69 73    distclean \..dis
+21712   74 63 6c 65 61 6e 2d 67  65 6e 65 72 69 63 20 64    tclean-generic d
+21728   69 73 74 63 6c 65 61 6e  2d 68 64 72 20 64 69 73    istclean-hdr dis
+21744   74 63 6c 65 61 6e 2d 6c  69 62 74 6f 6f 6c 20 5c    tclean-libtool \
+21760   0a 09 64 69 73 74 63 6c  65 61 6e 2d 72 65 63 75    ..distclean-recu
+21776   72 73 69 76 65 20 64 69  73 74 63 6c 65 61 6e 2d    rsive distclean-
+21792   74 61 67 73 20 64 69 73  74 63 6c 65 61 6e 63 68    tags distcleanch
+21808   65 63 6b 20 64 69 73 74  64 69 72 20 5c 0a 09 64    eck distdir \..d
+21824   69 73 74 75 6e 69 6e 73  74 61 6c 6c 63 68 65 63    istuninstallchec
+21840   6b 20 64 76 69 20 64 76  69 2d 61 6d 20 68 74 6d    k dvi dvi-am htm
+21856   6c 20 68 74 6d 6c 2d 61  6d 20 69 6e 66 6f 20 69    l html-am info i
+21872   6e 66 6f 2d 61 6d 20 5c  0a 09 69 6e 73 74 61 6c    nfo-am \..instal
+21888   6c 20 69 6e 73 74 61 6c  6c 2d 61 6d 20 69 6e 73    l install-am ins
+21904   74 61 6c 6c 2d 64 61 74  61 20 69 6e 73 74 61 6c    tall-data instal
+21920   6c 2d 64 61 74 61 2d 61  6d 20 69 6e 73 74 61 6c    l-data-am instal
+21936   6c 2d 65 78 65 63 20 5c  0a 09 69 6e 73 74 61 6c    l-exec \..instal
+21952   6c 2d 65 78 65 63 2d 61  6d 20 69 6e 73 74 61 6c    l-exec-am instal
+21968   6c 2d 69 6e 66 6f 20 69  6e 73 74 61 6c 6c 2d 69    l-info install-i
+21984   6e 66 6f 2d 61 6d 20 69  6e 73 74 61 6c 6c 2d 6d    nfo-am install-m
+22000   61 6e 20 5c 0a 09 69 6e  73 74 61 6c 6c 2d 73 74    an \..install-st
+22016   72 69 70 20 69 6e 73 74  61 6c 6c 63 68 65 63 6b    rip installcheck
+22032   20 69 6e 73 74 61 6c 6c  63 68 65 63 6b 2d 61 6d     installcheck-am
+22048   20 69 6e 73 74 61 6c 6c  64 69 72 73 20 5c 0a 09     installdirs \..
+22064   69 6e 73 74 61 6c 6c 64  69 72 73 2d 61 6d 20 6d    installdirs-am m
+22080   61 69 6e 74 61 69 6e 65  72 2d 63 6c 65 61 6e 20    aintainer-clean 
+22096   6d 61 69 6e 74 61 69 6e  65 72 2d 63 6c 65 61 6e    maintainer-clean
+22112   2d 67 65 6e 65 72 69 63  20 5c 0a 09 6d 61 69 6e    -generic \..main
+22128   74 61 69 6e 65 72 2d 63  6c 65 61 6e 2d 72 65 63    tainer-clean-rec
+22144   75 72 73 69 76 65 20 6d  6f 73 74 6c 79 63 6c 65    ursive mostlycle
+22160   61 6e 20 6d 6f 73 74 6c  79 63 6c 65 61 6e 2d 67    an mostlyclean-g
+22176   65 6e 65 72 69 63 20 5c  0a 09 6d 6f 73 74 6c 79    eneric \..mostly
+22192   63 6c 65 61 6e 2d 6c 69  62 74 6f 6f 6c 20 6d 6f    clean-libtool mo
+22208   73 74 6c 79 63 6c 65 61  6e 2d 72 65 63 75 72 73    stlyclean-recurs
+22224   69 76 65 20 70 64 66 20  70 64 66 2d 61 6d 20 70    ive pdf pdf-am p
+22240   73 20 70 73 2d 61 6d 20  5c 0a 09 74 61 67 73 20    s ps-am \..tags 
+22256   74 61 67 73 2d 72 65 63  75 72 73 69 76 65 20 75    tags-recursive u
+22272   6e 69 6e 73 74 61 6c 6c  20 75 6e 69 6e 73 74 61    ninstall uninsta
+22288   6c 6c 2d 61 6d 20 75 6e  69 6e 73 74 61 6c 6c 2d    ll-am uninstall-
+22304   69 6e 66 6f 2d 61 6d 0a  0a 24 28 50 52 4f 47 52    info-am..$(PROGR
+22320   41 4d 53 29 3a 20 24 28  4c 44 45 50 53 29 0a 23    AMS): $(LDEPS).#
+22336   20 54 65 6c 6c 20 76 65  72 73 69 6f 6e 73 20 5b     Tell versions [
+22352   33 2e 35 39 2c 33 2e 36  33 29 20 6f 66 20 47 4e    3.59,3.63) of GN
+22368   55 20 6d 61 6b 65 20 74  6f 20 6e 6f 74 20 65 78    U make to not ex
+22384   70 6f 72 74 20 61 6c 6c  20 76 61 72 69 61 62 6c    port all variabl
+22400   65 73 2e 0a 23 20 4f 74  68 65 72 77 69 73 65 20    es..# Otherwise 
+22416   61 20 73 79 73 74 65 6d  20 6c 69 6d 69 74 20 28    a system limit (
+22432   66 6f 72 20 53 79 73 56  20 61 74 20 6c 65 61 73    for SysV at leas
+22448   74 29 20 6d 61 79 20 62  65 20 65 78 63 65 65 64    t) may be exceed
+22464   65 64 2e 0a 2e 4e 4f 45  58 50 4f 52 54 3a 0a 00    ed...NOEXPORT:..
+22480   00 00 00 01 00 00 00 00                             ........
+*****
+*****
+169.254.8.27:38918 => 169.254.8.27:15000
+# of ContiguousBlocks = 1
+size of str = 248
+00000   80 00 00 4c 24 e5 94 45  00 00 00 00 00 00 00 02    ...L$..E........
+00016   00 06 1a 80 00 00 00 01  00 00 00 06 00 00 00 00    ................
+00032   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 14    ................
+00048   d2 29 21 2d 8b cb 62 23  bc e4 31 cc 98 14 06 2a    .)!-..b#..1....*
+00064   f9 7b c1 62 00 00 00 00  00 00 00 00 00 00 00 00    .{.b............
+00080   80 00 00 50 2c 23 51 da  00 00 00 00 00 00 00 02    ...P,#Q.........
+00096   00 06 1a 80 00 00 00 01  00 00 00 05 00 00 00 00    ................
+00112   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 14    ................
+00128   b2 05 e2 17 35 87 cd 79  96 0b 44 33 23 34 65 9d    ....5..y..D3#4e.
+00144   9f 45 7b 0e 00 00 40 00  00 00 00 00 00 00 00 00    .E{...@.........
+00160   00 00 00 00 80 00 00 50  2b 48 7c c2 00 00 00 00    .......P+H|.....
+00176   00 00 00 02 00 06 1a 80  00 00 00 01 00 00 00 05    ................
+00192   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
+00208   00 00 00 14 f4 13 77 ef  da 45 ee 79 55 a6 3b 37    ......w..E.yU.;7
+00224   d2 b5 75 65 a9 38 ab d2  00 00 16 fb 00 00 00 00    ..ue.8..........
+00240   00 00 00 00 00 00 00 00                             ........
+*****
+*****
+127.0.0.1:47237 => 127.0.0.1:22
+# of ContiguousBlocks = 1
+size of str = 1654
+00000   53 53 48 2d 32 2e 30 2d  4f 70 65 6e 53 53 48 5f    SSH-2.0-OpenSSH_
+00016   34 2e 33 70 32 20 44 65  62 69 61 6e 2d 38 75 62    4.3p2 Debian-8ub
+00032   75 6e 74 75 31 0a 00 00  02 c4 05 14 c0 df 51 e5    untu1.........Q.
+00048   67 c9 f0 bc 9a 6b 9d d3  cd 69 21 42 00 00 00 59    g....k...i!B...Y
+00064   64 69 66 66 69 65 2d 68  65 6c 6c 6d 61 6e 2d 67    diffie-hellman-g
+00080   72 6f 75 70 2d 65 78 63  68 61 6e 67 65 2d 73 68    roup-exchange-sh
+00096   61 31 2c 64 69 66 66 69  65 2d 68 65 6c 6c 6d 61    a1,diffie-hellma
+00112   6e 2d 67 72 6f 75 70 31  34 2d 73 68 61 31 2c 64    n-group14-sha1,d
+00128   69 66 66 69 65 2d 68 65  6c 6c 6d 61 6e 2d 67 72    iffie-hellman-gr
+00144   6f 75 70 31 2d 73 68 61  31 00 00 00 0f 73 73 68    oup1-sha1....ssh
+00160   2d 72 73 61 2c 73 73 68  2d 64 73 73 00 00 00 9d    -rsa,ssh-dss....
+00176   61 65 73 31 32 38 2d 63  62 63 2c 33 64 65 73 2d    aes128-cbc,3des-
+00192   63 62 63 2c 62 6c 6f 77  66 69 73 68 2d 63 62 63    cbc,blowfish-cbc
+00208   2c 63 61 73 74 31 32 38  2d 63 62 63 2c 61 72 63    ,cast128-cbc,arc
+00224   66 6f 75 72 31 32 38 2c  61 72 63 66 6f 75 72 32    four128,arcfour2
+00240   35 36 2c 61 72 63 66 6f  75 72 2c 61 65 73 31 39    56,arcfour,aes19
+00256   32 2d 63 62 63 2c 61 65  73 32 35 36 2d 63 62 63    2-cbc,aes256-cbc
+00272   2c 72 69 6a 6e 64 61 65  6c 2d 63 62 63 40 6c 79    ,rijndael-cbc@ly
+00288   73 61 74 6f 72 2e 6c 69  75 2e 73 65 2c 61 65 73    sator.liu.se,aes
+00304   31 32 38 2d 63 74 72 2c  61 65 73 31 39 32 2d 63    128-ctr,aes192-c
+00320   74 72 2c 61 65 73 32 35  36 2d 63 74 72 00 00 00    tr,aes256-ctr...
+00336   9d 61 65 73 31 32 38 2d  63 62 63 2c 33 64 65 73    .aes128-cbc,3des
+00352   2d 63 62 63 2c 62 6c 6f  77 66 69 73 68 2d 63 62    -cbc,blowfish-cb
+00368   63 2c 63 61 73 74 31 32  38 2d 63 62 63 2c 61 72    c,cast128-cbc,ar
+00384   63 66 6f 75 72 31 32 38  2c 61 72 63 66 6f 75 72    cfour128,arcfour
+00400   32 35 36 2c 61 72 63 66  6f 75 72 2c 61 65 73 31    256,arcfour,aes1
+00416   39 32 2d 63 62 63 2c 61  65 73 32 35 36 2d 63 62    92-cbc,aes256-cb
+00432   63 2c 72 69 6a 6e 64 61  65 6c 2d 63 62 63 40 6c    c,rijndael-cbc@l
+00448   79 73 61 74 6f 72 2e 6c  69 75 2e 73 65 2c 61 65    ysator.liu.se,ae
+00464   73 31 32 38 2d 63 74 72  2c 61 65 73 31 39 32 2d    s128-ctr,aes192-
+00480   63 74 72 2c 61 65 73 32  35 36 2d 63 74 72 00 00    ctr,aes256-ctr..
+00496   00 55 68 6d 61 63 2d 6d  64 35 2c 68 6d 61 63 2d    .Uhmac-md5,hmac-
+00512   73 68 61 31 2c 68 6d 61  63 2d 72 69 70 65 6d 64    sha1,hmac-ripemd
+00528   31 36 30 2c 68 6d 61 63  2d 72 69 70 65 6d 64 31    160,hmac-ripemd1
+00544   36 30 40 6f 70 65 6e 73  73 68 2e 63 6f 6d 2c 68    60@openssh.com,h
+00560   6d 61 63 2d 73 68 61 31  2d 39 36 2c 68 6d 61 63    mac-sha1-96,hmac
+00576   2d 6d 64 35 2d 39 36 00  00 00 55 68 6d 61 63 2d    -md5-96...Uhmac-
+00592   6d 64 35 2c 68 6d 61 63  2d 73 68 61 31 2c 68 6d    md5,hmac-sha1,hm
+00608   61 63 2d 72 69 70 65 6d  64 31 36 30 2c 68 6d 61    ac-ripemd160,hma
+00624   63 2d 72 69 70 65 6d 64  31 36 30 40 6f 70 65 6e    c-ripemd160@open
+00640   73 73 68 2e 63 6f 6d 2c  68 6d 61 63 2d 73 68 61    ssh.com,hmac-sha
+00656   31 2d 39 36 2c 68 6d 61  63 2d 6d 64 35 2d 39 36    1-96,hmac-md5-96
+00672   00 00 00 1a 6e 6f 6e 65  2c 7a 6c 69 62 40 6f 70    ....none,zlib@op
+00688   65 6e 73 73 68 2e 63 6f  6d 2c 7a 6c 69 62 00 00    enssh.com,zlib..
+00704   00 1a 6e 6f 6e 65 2c 7a  6c 69 62 40 6f 70 65 6e    ..none,zlib@open
+00720   73 73 68 2e 63 6f 6d 2c  7a 6c 69 62 00 00 00 00    ssh.com,zlib....
+00736   00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
+00752   00 14 06 22 00 00 04 00  00 00 04 00 00 00 20 00    ...".......... .
+00768   00 00 00 00 00 00 00 00  00 8c 06 20 00 00 00 80    ........... ....
+00784   32 47 9d 40 0a 28 29 ce  e7 e1 24 1e 8f 32 f2 b1    2G.@.()...$..2..
+00800   02 8f b6 9d e3 2e 49 e7  a4 50 d4 3b 45 32 2c 58    ......I..P.;E2,X
+00816   84 6d ce 73 de 9e 31 ed  15 99 30 b8 39 85 f0 2a    .m.s..1...0.9..*
+00832   74 7d 8e 84 17 e6 ce 9e  ad 05 37 35 41 9d d7 db    t}........75A...
+00848   03 b5 75 79 9f fa 1a 2d  31 9e d0 78 2a da 78 1c    ..uy...-1..x*.x.
+00864   e8 a8 c6 2d eb 57 3e cd  e5 0f 25 25 46 1a 7b 82    ...-.W>...%%F.{.
+00880   89 3b a3 e9 98 be cc 1e  99 87 27 a8 b0 51 ed 58    .;........'..Q.X
+00896   18 28 0e e3 24 80 0e ab  62 f0 06 9b 76 db a5 bd    .(..$...b...v...
+00912   00 00 00 00 00 00 00 00  00 0c 0a 15 00 00 00 00    ................
+00928   00 00 00 00 00 00 e9 30  64 c7 25 15 e0 f5 13 44    .......0d.%....D
+00944   f3 1d da fa f4 b9 27 af  4b f4 2c 52 fe b4 38 05    ......'.K.,R..8.
+00960   96 a7 c3 5d b3 c7 74 e1  7a 00 24 23 68 01 11 3e    ...]..t.z.$#h..>
+00976   f2 99 c0 5c b8 07 01 c1  f7 a9 38 48 8b 42 c7 04    ...\......8H.B..
+00992   1d 5b f0 aa ac 68 dc 48  e4 9f c1 85 eb 63 34 e7    .[...h.H.....c4.
+01008   3e 31 ca 85 73 5b e2 a9  4e 3b 7a d7 4f d2 45 94    >1..s[..N;z.O.E.
+01024   4b 38 8a 87 09 9b 81 5e  85 b9 fb d0 18 31 37 27    K8.....^.....17'
+01040   d5 12 98 71 3b a5 09 6a  00 52 c1 39 4d 9f be 18    ...q;..j.R.9M...
+01056   cd c5 e9 d4 c8 cf 9b 29  38 6b 08 bc 54 5b 72 d0    .......)8k..T[r.
+01072   c4 11 83 9e 6a 91 5d 26  5a 4d 76 8e b2 42 ac c8    ....j.]&ZMv..B..
+01088   4f 5f 3d f0 9a 00 cb 4e  55 78 00 e1 b5 1b 35 92    O_=....NUx....5.
+01104   48 f6 1d ca 39 c4 9d 89  1e a3 01 e4 2f e7 65 35    H...9......./.e5
+01120   50 7a 34 f8 6e 07 2a a9  e7 81 fb 03 73 bc e0 0e    Pz4.n.*.....s...
+01136   d1 2b d8 c3 fe e1 38 d6  c2 74 00 0d a7 57 87 a9    .+....8..t...W..
+01152   84 55 2c 68 60 95 a1 fb  f3 21 1b 42 de 87 14 df    .U,h`....!.B....
+01168   18 a9 94 48 af 36 47 0d  5f 44 dd 5d ce c8 0c de    ...H.6G._D.]....
+01184   b0 2e 43 2d c5 c9 b0 33  b9 93 58 98 08 bc 79 c4    ..C-...3..X...y.
+01200   09 77 88 07 0f fd fc b2  bf 1f ab fb 50 8e 6a 55    .w..........P.jU
+01216   27 74 43 34 40 3f d0 8e  f5 6c 96 2c b3 3f f8 b0    'tC4@?...l.,.?..
+01232   e3 06 cb 1d 6d 7f 52 44  de 45 1d a4 dd 94 81 b0    ....m.RD.E......
+01248   e1 54 e8 ed ad 1f 35 1e  02 49 29 a1 f9 09 68 aa    .T....5..I)...h.
+01264   73 d6 28 65 fd 58 d7 80  04 5c 3e a2 ed c2 e2 a3    s.(e.X...\>.....
+01280   ea 2b 3e 71 6e 15 e1 64  30 81 fe 09 b2 33 eb 68    .+>qn..d0....3.h
+01296   21 b4 07 b1 0e 56 0e 18  61 be af 9d 7a 60 0c 68    !....V..a...z`.h
+01312   20 f7 d4 7c 0b 03 02 d1  23 43 6b 7f 62 22 84 6b     ..|....#Ck.b".k
+01328   e3 71 0f b3 a0 5a ad 7c  60 cb 97 a1 10 19 5d d8    .q...Z.|`.....].
+01344   68 79 76 cb 1a cd b1 49  d2 5f c6 83 27 0b e5 02    hyv....I._..'...
+01360   2e 06 0c fe 62 c9 5e 84  1e 48 58 12 76 53 46 b4    ....b.^..HX.vSF.
+01376   45 63 f8 19 7b 81 10 23  42 75 4a bb df c4 ff 54    Ec..{..#BuJ....T
+01392   a5 a0 75 b6 db 02 bf 93  78 0e 98 a5 a7 e6 30 38    ..u.....x.....08
+01408   15 78 0f 08 2e a5 f9 92  1c 18 ab f2 6c 03 91 23    .x..........l..#
+01424   1b 06 0e d0 e8 c7 0b 3a  29 d2 b4 34 dd 11 3b d8    .......:)..4..;.
+01440   12 f1 ac c6 01 e0 f9 38  7d 40 da 10 9a ec be cd    .......8}@......
+01456   9c e3 5d 9b b4 89 60 33  00 61 0a c0 49 e8 09 8c    ..]...`3.a..I...
+01472   20 a0 41 81 d8 56 12 28  71 b8 8e 0e c3 8f b5 22     .A..V.(q......"
+01488   cb 36 8d 7a 8b 21 90 c9  7a 7f aa 02 dd 30 72 50    .6.z.!..z....0rP
+01504   1c 58 41 5c 01 aa b9 d9  9d ae 7a 48 d7 6d 19 52    .XA\......zH.m.R
+01520   78 46 fd af fe 66 30 da  64 18 42 74 6d ef 67 17    xF...f0.d.Btm.g.
+01536   d6 9d 5f dd b9 01 b6 cb  44 82 4d a3 37 6b 5b 40    .._.....D.M.7k[@
+01552   5c 28 a5 f6 45 f9 35 48  72 23 5a 11 4b 20 e2 23    \(..E.5Hr#Z.K .#
+01568   7c ad a8 4d 11 e0 51 80  ba 87 19 68 91 6d 6c 78    |..M..Q....h.mlx
+01584   fb eb 4e 40 3d 66 f7 86  b7 f0 ee d6 9b 90 8b f0    ..N@=f..........
+01600   c0 0a b8 80 e4 14 14 98  06 a3 ff 2d bc e5 fa 8e    ...........-....
+01616   7d 5b 62 af 07 0d 89 c7  3a 07 e8 e3 fe 62 56 23    }[b.....:....bV#
+01632   8b 9a fb ac 66 55 30 8f  54 e0 68 b3 00 a3 46 62    ....fU0.T.h...Fb
+01648   6a fd 3f ae 1c 0e                                   j.?...
+*****
+*****
+127.0.0.1:22 => 127.0.0.1:47237
+# of ContiguousBlocks = 1
+size of str = 2366
+00000   53 53 48 2d 32 2e 30 2d  4f 70 65 6e 53 53 48 5f    SSH-2.0-OpenSSH_
+00016   34 2e 33 70 32 20 44 65  62 69 61 6e 2d 38 75 62    4.3p2 Debian-8ub
+00032   75 6e 74 75 31 0a 00 00  02 bc 07 14 b4 f3 03 13    untu1...........
+00048   86 89 ef dd 05 8b 04 ae  7e 5d 11 79 00 00 00 59    ........~].y...Y
+00064   64 69 66 66 69 65 2d 68  65 6c 6c 6d 61 6e 2d 67    diffie-hellman-g
+00080   72 6f 75 70 2d 65 78 63  68 61 6e 67 65 2d 73 68    roup-exchange-sh
+00096   61 31 2c 64 69 66 66 69  65 2d 68 65 6c 6c 6d 61    a1,diffie-hellma
+00112   6e 2d 67 72 6f 75 70 31  34 2d 73 68 61 31 2c 64    n-group14-sha1,d
+00128   69 66 66 69 65 2d 68 65  6c 6c 6d 61 6e 2d 67 72    iffie-hellman-gr
+00144   6f 75 70 31 2d 73 68 61  31 00 00 00 0f 73 73 68    oup1-sha1....ssh
+00160   2d 72 73 61 2c 73 73 68  2d 64 73 73 00 00 00 9d    -rsa,ssh-dss....
+00176   61 65 73 31 32 38 2d 63  62 63 2c 33 64 65 73 2d    aes128-cbc,3des-
+00192   63 62 63 2c 62 6c 6f 77  66 69 73 68 2d 63 62 63    cbc,blowfish-cbc
+00208   2c 63 61 73 74 31 32 38  2d 63 62 63 2c 61 72 63    ,cast128-cbc,arc
+00224   66 6f 75 72 31 32 38 2c  61 72 63 66 6f 75 72 32    four128,arcfour2
+00240   35 36 2c 61 72 63 66 6f  75 72 2c 61 65 73 31 39    56,arcfour,aes19
+00256   32 2d 63 62 63 2c 61 65  73 32 35 36 2d 63 62 63    2-cbc,aes256-cbc
+00272   2c 72 69 6a 6e 64 61 65  6c 2d 63 62 63 40 6c 79    ,rijndael-cbc@ly
+00288   73 61 74 6f 72 2e 6c 69  75 2e 73 65 2c 61 65 73    sator.liu.se,aes
+00304   31 32 38 2d 63 74 72 2c  61 65 73 31 39 32 2d 63    128-ctr,aes192-c
+00320   74 72 2c 61 65 73 32 35  36 2d 63 74 72 00 00 00    tr,aes256-ctr...
+00336   9d 61 65 73 31 32 38 2d  63 62 63 2c 33 64 65 73    .aes128-cbc,3des
+00352   2d 63 62 63 2c 62 6c 6f  77 66 69 73 68 2d 63 62    -cbc,blowfish-cb
+00368   63 2c 63 61 73 74 31 32  38 2d 63 62 63 2c 61 72    c,cast128-cbc,ar
+00384   63 66 6f 75 72 31 32 38  2c 61 72 63 66 6f 75 72    cfour128,arcfour
+00400   32 35 36 2c 61 72 63 66  6f 75 72 2c 61 65 73 31    256,arcfour,aes1
+00416   39 32 2d 63 62 63 2c 61  65 73 32 35 36 2d 63 62    92-cbc,aes256-cb
+00432   63 2c 72 69 6a 6e 64 61  65 6c 2d 63 62 63 40 6c    c,rijndael-cbc@l
+00448   79 73 61 74 6f 72 2e 6c  69 75 2e 73 65 2c 61 65    ysator.liu.se,ae
+00464   73 31 32 38 2d 63 74 72  2c 61 65 73 31 39 32 2d    s128-ctr,aes192-
+00480   63 74 72 2c 61 65 73 32  35 36 2d 63 74 72 00 00    ctr,aes256-ctr..
+00496   00 55 68 6d 61 63 2d 6d  64 35 2c 68 6d 61 63 2d    .Uhmac-md5,hmac-
+00512   73 68 61 31 2c 68 6d 61  63 2d 72 69 70 65 6d 64    sha1,hmac-ripemd
+00528   31 36 30 2c 68 6d 61 63  2d 72 69 70 65 6d 64 31    160,hmac-ripemd1
+00544   36 30 40 6f 70 65 6e 73  73 68 2e 63 6f 6d 2c 68    60@openssh.com,h
+00560   6d 61 63 2d 73 68 61 31  2d 39 36 2c 68 6d 61 63    mac-sha1-96,hmac
+00576   2d 6d 64 35 2d 39 36 00  00 00 55 68 6d 61 63 2d    -md5-96...Uhmac-
+00592   6d 64 35 2c 68 6d 61 63  2d 73 68 61 31 2c 68 6d    md5,hmac-sha1,hm
+00608   61 63 2d 72 69 70 65 6d  64 31 36 30 2c 68 6d 61    ac-ripemd160,hma
+00624   63 2d 72 69 70 65 6d 64  31 36 30 40 6f 70 65 6e    c-ripemd160@open
+00640   73 73 68 2e 63 6f 6d 2c  68 6d 61 63 2d 73 68 61    ssh.com,hmac-sha
+00656   31 2d 39 36 2c 68 6d 61  63 2d 6d 64 35 2d 39 36    1-96,hmac-md5-96
+00672   00 00 00 15 6e 6f 6e 65  2c 7a 6c 69 62 40 6f 70    ....none,zlib@op
+00688   65 6e 73 73 68 2e 63 6f  6d 00 00 00 15 6e 6f 6e    enssh.com....non
+00704   65 2c 7a 6c 69 62 40 6f  70 65 6e 73 73 68 2e 63    e,zlib@openssh.c
+00720   6f 6d 00 00 00 00 00 00  00 00 00 00 00 00 00 00    om..............
+00736   00 00 00 00 00 00 00 00  00 94 08 1f 00 00 00 81    ................
+00752   00 ca ad dd ec 16 67 fc  68 b5 fa 15 d5 3c 4e 15    ......g.h....<N.
+00768   32 dd 24 56 1a 1a 2d 47  a1 2c 01 ab ea 1e 00 73    2.$V..-G.,.....s
+00784   1f 69 21 aa c4 07 42 31  1f df 9e 63 4b b7 13 1b    .i!...B1...cK...
+00800   ee 1a f2 40 26 15 54 38  9a 91 04 25 e0 44 e8 8c    ...@&.T8...%.D..
+00816   83 59 b0 10 f5 ad 2b 80  e2 9c b1 a5 b0 27 b1 9d    .Y....+......'..
+00832   9e 01 a6 f6 3a 6f 45 e5  d7 ed 2f f6 a2 a0 08 50    ....:oE.../....P
+00848   50 a7 d0 cf 30 7c 3d b5  1d 24 90 35 59 07 b4 42    P...0|=..$.5Y..B
+00864   7c 23 a9 8d f1 eb 8a be  f2 ba 20 9b b7 b1 c6 af    |#........ .....
+00880   33 00 00 00 01 02 00 00  00 00 00 00 00 00 00 00    3...............
+00896   02 bc 0a 21 00 00 01 15  00 00 00 07 73 73 68 2d    ...!........ssh-
+00912   72 73 61 00 00 00 01 23  00 00 01 01 00 bf 09 69    rsa....#.......i
+00928   fc 43 93 5f 04 9b 3d 38  9e 44 df c0 bd bf 5e 6a    .C._..=8.D....^j
+00944   71 fc a3 fe 89 b9 1d 53  54 42 82 f7 94 27 08 bc    q......STB...'..
+00960   75 b4 b3 cf 57 5f b5 35  8f 0b 09 c8 97 27 bc 9c    u...W_.5.....'..
+00976   0d 94 57 b0 c3 88 0c 8e  55 83 d0 93 79 f2 1a 39    ..W.....U...y..9
+00992   83 54 b9 da a1 c0 00 e8  5e af e0 51 d9 7d 7f b9    .T......^..Q.}..
+01008   4a 6c 46 d3 07 9c b0 9a  5e a0 ac 23 c9 42 41 10    JlF.....^..#.BA.
+01024   8f 4d 30 00 f8 fc 9a 57  e3 50 a0 7c fc 6b cc c7    .M0....W.P.|.k..
+01040   7e 43 f2 6c e3 e8 50 07  27 28 15 3a d5 fe e9 45    ~C.l..P.'(.:...E
+01056   56 7f a2 45 af aa 76 cc  0f 95 fd 74 0d 75 f1 5e    V..E..v....t.u.^
+01072   cf 29 44 71 7c 1f 36 4d  77 42 8e 24 b8 85 1b 1e    .)Dq|.6MwB.$....
+01088   06 b8 6b ab e3 3a 44 27  f0 b1 19 be eb b9 7b 2f    ..k..:D'......{/
+01104   7d 4b 3b 06 f1 a6 82 c1  65 bc 2b ec c7 db 12 21    }K;.....e.+....!
+01120   70 64 71 63 b5 0b fc a2  04 a1 9d 60 fd c7 bf 93    pdqc.......`....
+01136   4a 5c 94 81 d8 54 b9 32  5c d0 b1 7a 35 14 a1 a9    J\...T.2\..z5...
+01152   b6 7d c3 ba 27 81 05 04  6b 40 2c 38 b8 e3 db 05    .}..'...k@,8....
+01168   53 53 ec 26 2f be 22 e2  11 10 ac 25 6f 00 00 00    SS.&/."....%o...
+01184   80 23 c1 9a 28 77 d5 a2  d9 40 68 0e 2b f2 4c 75    .#..(w...@h.+.Lu
+01200   88 82 74 ab 68 fd 30 20  f1 0d c2 48 66 cf 25 0e    ..t.h.0 ...Hf.%.
+01216   48 1f c6 9f 0b c4 8e 30  71 d5 73 38 af 33 cd f5    H......0q.s8.3..
+01232   a8 99 a2 39 5a b4 22 eb  ef b7 6e c9 4e 31 99 67    ...9Z."...n.N1.g
+01248   4d 5b f1 27 7b 0b 2b 2d  aa 8f dd ce 3a b0 36 9e    M[.'{.+-....:.6.
+01264   c0 15 a0 4f 1a c7 6a c4  22 fd 7b cc 33 5f b6 ee    ...O..j.".{.3_..
+01280   05 74 ed 75 98 ae 90 28  fb d8 b9 1e bb ec 49 93    .t.u...(......I.
+01296   bb ac 8d a1 45 b5 3b cb  3f 58 90 d3 f1 78 84 ae    ....E.;.?X...x..
+01312   59 00 00 01 0f 00 00 00  07 73 73 68 2d 72 73 61    Y........ssh-rsa
+01328   00 00 01 00 36 6d 82 65  92 0a 98 ef b5 d3 18 01    ....6m.e........
+01344   38 90 75 3e e9 c7 fd 80  9f c5 cd b2 5e 32 c9 be    8.u>........^2..
+01360   7b ef 90 c5 fc 47 c3 07  23 a8 47 06 bf 3c 4c d6    {....G..#.G..<L.
+01376   09 2b f1 5e 27 1e 35 48  01 e4 ad cf c2 c6 27 3f    .+.^'.5H......'?
+01392   5c c9 62 6a b5 ca fb 87  b8 5e 70 8e 38 45 85 60    \.bj.....^p.8E.`
+01408   09 5b da b3 dc 4e 1d 0f  ae 84 bd be 48 02 e5 f7    .[...N......H...
+01424   9d 3e 78 e2 93 df 86 15  30 45 5c 0e 01 de 62 23    .>x.....0E\...b#
+01440   ff cc 84 db 4e df b5 b3  6a 94 d9 58 b8 f4 cd fe    ....N...j..X....
+01456   de cd ed cf 00 c6 77 14  6a f9 9e fb 8d e5 26 fc    ......w.j.....&.
+01472   04 a7 99 5e 21 ec 31 bc  4c 1f bb ba 73 f7 4e c9    ...^!.1.L...s.N.
+01488   89 2b 0c f9 c3 0d 55 36  c0 6e 3f 9f 6a 3c 6f 3b    .+....U6.n?.j<o;
+01504   fd 05 f1 2b e7 44 04 68  ad e0 7e 84 84 52 2c bf    ...+.D.h..~..R,.
+01520   62 e3 10 ef 42 bb ca 99  5e a9 07 42 eb 6f 09 29    b...B...^..B.o.)
+01536   4b 2d 6a 7f b1 d9 a5 b3  20 9c 78 7f bc 7c 1f ee    K-j..... .x..|..
+01552   ef 7a 58 cc 12 00 8c c5  ce 3d 05 a5 9c 3a 03 da    .zX......=...:..
+01568   1d 33 85 b5 29 a0 1f 4c  f8 19 06 ec 3b 8f c6 66    .3..)..L....;..f
+01584   66 9d 69 8b 00 00 00 00  00 00 00 00 00 00 00 00    f.i.............
+01600   00 0c 0a 15 00 00 00 00  00 00 00 00 00 00 e6 9d    ................
+01616   65 1c f8 0e ab 10 72 4d  90 01 ce 2d 83 a6 fd 69    e.....rM...-...i
+01632   1a 8b 81 20 f6 47 4c 50  a0 ba 0b f8 96 ff a3 65    ... .GLP.......e
+01648   89 0d 5d 44 3d a7 c9 ec  f7 57 e2 02 03 f7 f7 7f    ..]D=....W......
+01664   24 20 26 3d 39 1c 5e be  17 e3 ff 1b 89 00 d6 6f    $ &=9.^........o
+01680   8b 98 9a 1d 0a b4 11 f9  e7 83 d7 ef 60 f3 ea 96    ............`...
+01696   67 53 79 4e ef 26 0c db  5c c8 97 28 6e 37 d1 62    gSyN.&..\..(n7.b
+01712   9d 55 26 12 eb 44 89 c2  67 ee af 8a bc 90 ac bd    .U&..D..g.......
+01728   91 2d b5 ad 9f 0b e0 ae  59 17 56 97 92 15 29 5b    .-......Y.V...)[
+01744   b9 47 03 11 5f e5 0a cb  9e 91 20 06 74 bb 90 71    .G.._..... .t..q
+01760   83 7c 68 b6 c9 1f 29 c1  6e 84 5d 39 10 9c b6 d8    .|h...).n.]9....
+01776   1f b1 90 93 be 66 4f 36  b5 12 e3 bf 43 6d 1a 97    .....fO6....Cm..
+01792   96 2a b3 6b d3 4b 77 75  f9 0e e3 06 9d 6e 5a d2    .*.k.Kwu.....nZ.
+01808   e9 08 51 0e c9 f4 1e 1c  ae 1c d5 59 8b e7 5a 86    ..Q........Y..Z.
+01824   d0 71 32 30 e6 b4 49 28  f7 66 29 e5 62 92 6d 4d    .q20..I(.f).b.mM
+01840   2b de 71 d1 95 79 2e eb  5d e5 64 fd 73 3d bf 19    +.q..y..].d.s=..
+01856   2d 44 3e 4e 70 70 ef 05  16 71 85 6f 08 27 4e 59    -D>Npp...q.o.'NY
+01872   29 c2 02 97 71 0b fd a4  7b a8 1e 3a 30 04 13 79    )...q...{..:0..y
+01888   ea b9 7f 83 9a 5c 89 f5  a0 4c d9 6b cc d4 1a 28    .....\...L.k...(
+01904   67 7b de 4b c8 f9 6d b7  4f ff f2 bd 94 e7 a6 db    g{.K..m.O.......
+01920   68 9c 34 94 eb 34 40 95  33 d6 6e e5 de 8c 20 75    h.4..4@.3.n... u
+01936   42 ad b9 7d d8 74 16 62  1f 84 cb 7e 92 fe 01 dd    B..}.t.b...~....
+01952   0f 95 89 a6 95 ab c2 98  8b a6 85 a7 9f 1f 1c 96    ................
+01968   8b 57 4a 1e c7 47 3c a4  7f 1f b4 8f b4 43 b7 66    .WJ..G<......C.f
+01984   01 1d e1 0b 7a d2 e6 07  29 bb a5 94 4c e9 cf c2    ....z...)...L...
+02000   67 42 a9 3a 3f 8d 9d 5c  cc 94 0f 78 59 26 70 fa    gB.:?..\...xY&p.
+02016   98 ef 51 ad a9 40 34 df  b2 1b d1 f3 cf e8 d9 7c    ..Q..@4........|
+02032   11 c0 74 ea c3 a2 4f 0f  cd 8c 30 95 82 49 b7 b3    ..t...O...0..I..
+02048   29 77 cd 00 26 f0 51 c1  b6 82 a9 40 26 ae da 30    )w..&.Q....@&..0
+02064   00 8a a6 92 2f d5 e5 eb  f9 2f 88 2b 29 e9 08 ee    ..../..../.+)...
+02080   d1 fc 53 b3 cc a0 84 e6  a1 be e8 16 10 bb a8 f9    ..S.............
+02096   f7 b0 b2 5f b4 53 3b 64  02 a2 36 84 d0 97 97 56    ..._.S;d..6....V
+02112   55 7c 8a 8d 58 f8 2e 10  85 4a 80 d7 f2 4c 0f eb    U|..X....J...L..
+02128   1f 80 d5 c7 09 18 c4 6d  a8 fc 33 ac 58 5a fc 13    .......m..3.XZ..
+02144   90 47 f3 05 c4 8f c5 d1  a0 71 4b 34 a2 c8 c8 c6    .G.......qK4....
+02160   50 00 7a d0 80 a5 66 c3  74 30 3f f7 f4 f6 d2 fe    P.z...f.t0?.....
+02176   e9 82 d4 35 c0 a8 17 7e  91 a9 3d 3b c9 14 a8 07    ...5...~..=;....
+02192   ad 34 74 43 4f 5e 6b 01  8a 38 85 98 d8 a3 22 b2    .4tCO^k..8....".
+02208   e7 af 58 b9 b4 74 b7 b7  a6 69 61 76 2c 4d 7b d3    ..X..t...iav,M{.
+02224   8b b8 b3 57 4d 27 75 aa  7f e4 c4 a1 7d 43 2f 4d    ...WM'u.....}C/M
+02240   0c ae 2e d5 9b 61 c9 c7  59 28 3b 16 45 99 21 52    .....a..Y(;.E.!R
+02256   2a fb bf 76 e0 a0 e9 03  4b aa 01 b6 f1 3f 64 e8    *..v....K....?d.
+02272   e4 1b 20 05 5a 95 22 a7  45 29 99 b0 72 61 0e e7    .. .Z.".E)..ra..
+02288   12 5a 25 80 e0 b7 c7 9b  1a 0d 69 6a 1a f8 fe 53    .Z%.......ij...S
+02304   b2 8a f8 6f f9 ff 99 67  02 fd 7f 9a 8c 06 f7 79    ...o...g.......y
+02320   e7 07 4e 61 a0 b5 b4 d2  6f 87 a5 13 2e 19 f8 12    ..Na....o.......
+02336   aa 75 a1 5d cd cb 58 c9  1d c9 9b d7 e8 45 7d e5    .u.]..X......E}.
+02352   67 a2 34 7c b4 78 70 02  42 46 4e a6 82 4c          g.4|.xp.BFN..L
+*****
+#####
+
+Finished
diff -Naur src_dot_original/sniffer/types.h src/sniffer/types.h
--- src_dot_original/sniffer/types.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/types.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,65 @@
+////////////////////////////////////////////////////////////////////////////////
+// Mercury and Colyseus Software Distribution 
+// 
+// Copyright (C) 2004-2005 Ashwin Bharambe (ashu@cs.cmu.edu)
+//               2004-2005 Jeffrey Pang    (jeffpang@cs.cmu.edu)
+//                    2004 Mukesh Agrawal  (mukesh@cs.cmu.edu)
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License as
+// published by the Free Software Foundation; either version 2, or (at
+// your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful, but
+// WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA
+////////////////////////////////////////////////////////////////////////////////
+#ifndef __TYPES__H
+#define __TYPES__H
+
+// basic types and utility macros
+
+typedef unsigned char      byte;
+typedef unsigned char      ubyte;
+typedef unsigned char      uint8;
+typedef unsigned short     uint16; 
+typedef unsigned int       uint32;
+typedef unsigned long long uint64;
+
+typedef          char      sbyte;
+typedef          char      sint8;
+typedef          short     sint16; 
+typedef          int       sint32;
+typedef          long long sint64;
+
+typedef float              real;
+typedef float              real32;
+typedef double             real64;
+//typedef long double        real64;
+
+typedef unsigned int guint;
+typedef uint32 guint32;
+typedef uint16 guint16;
+typedef uint8  guint8;
+
+#ifndef MAX
+#define MAX(x,y) ((x)>(y)?(x):(y))
+#endif
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+#endif
+// vim: set sw=4 sts=4 ts=8 noet: 
+// Local Variables:
+// Mode: c++
+// c-basic-offset: 4
+// tab-width: 8
+// indent-tabs-mode: t
+// End:
diff -Naur src_dot_original/sniffer/util.cc src/sniffer/util.cc
--- src_dot_original/sniffer/util.cc	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/util.cc	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,136 @@
+
+#include <stdarg.h>
+#include <cstdlib>
+#include <cstdio>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "util.h"
+#include "ethertype.h"
+
+MAC::MAC(const u_char *ether) {
+    val = ((((((((((((uint64_t) (ether[0]))
+		    << 8) | ether[1])
+		  << 8) | ether[2])
+		<< 8) | ether[3])
+	      << 8) | ether[4])
+	    << 8) | ether[5]);
+}
+MAC::MAC(uint64_t val) : val(val) {
+}
+MAC::MAC(const MAC& o) : val(o.val) {
+}
+
+MAC MAC::broadcast = MAC(0xffffffffffffULL);
+MAC MAC::null = MAC((uint64_t)0);
+
+std::ostream& operator<<(std::ostream& out, const MAC& mac) {
+    char buf[24];
+    sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", 
+	    (int)((mac.val>>40)&0xff),
+	    (int)((mac.val>>32)&0xff),
+	    (int)((mac.val>>24)&0xff),
+	    (int)((mac.val>>16)&0xff),
+	    (int)((mac.val>>8)&0xff),
+	    (int)((mac.val)&0xff)
+	    );
+    out << buf;
+    return out;
+}
+
+std::ostream& operator<<(std::ostream& out, const struct in_addr& ip) {
+    out << inet_ntoa(ip);
+    return out;
+}
+
+char *va(char *format, ...)
+{
+    va_list		argptr;
+    static int index = 0;
+    static char	buf[8][512];
+    
+    char *b = *(buf + index);
+
+    va_start (argptr, format);
+    vsprintf (b, format,argptr);
+    va_end (argptr);
+
+    index = (index + 1) % 8;
+
+    return b;	
+}
+
+const struct tok ethertype_values[] = { 
+    { ETHERTYPE_IP,		"IPv4" },
+    { ETHERTYPE_MPLS,		"MPLS unicast" },
+    { ETHERTYPE_MPLS_MULTI,	"MPLS multicast" },
+    { ETHERTYPE_IPV6,		"IPv6" },
+    { ETHERTYPE_8021Q,		"802.1Q" },
+    { ETHERTYPE_VMAN,		"VMAN" },
+    { ETHERTYPE_PUP,            "PUP" },
+    { ETHERTYPE_ARP,            "ARP"},
+    { ETHERTYPE_REVARP,         "Reverse ARP"},
+    { ETHERTYPE_NS,             "NS" },
+    { ETHERTYPE_SPRITE,         "Sprite" },
+    { ETHERTYPE_TRAIL,          "Trail" },
+    { ETHERTYPE_MOPDL,          "MOP DL" },
+    { ETHERTYPE_MOPRC,          "MOP RC" },
+    { ETHERTYPE_DN,             "DN" },
+    { ETHERTYPE_LAT,            "LAT" },
+    { ETHERTYPE_SCA,            "SCA" },
+    { ETHERTYPE_LANBRIDGE,      "Lanbridge" },
+    { ETHERTYPE_DECDNS,         "DEC DNS" },
+    { ETHERTYPE_DECDTS,         "DEC DTS" },
+    { ETHERTYPE_VEXP,           "VEXP" },
+    { ETHERTYPE_VPROD,          "VPROD" },
+    { ETHERTYPE_ATALK,          "Appletalk" },
+    { ETHERTYPE_AARP,           "Appletalk ARP" },
+    { ETHERTYPE_IPX,            "IPX" },
+    { ETHERTYPE_PPP,            "PPP" },
+    { ETHERTYPE_SLOW,           "Slow Protocols" },
+    { ETHERTYPE_PPPOED,         "PPPoE D" },
+    { ETHERTYPE_PPPOES,         "PPPoE S" },
+    { ETHERTYPE_EAPOL,          "EAPOL" },
+    { ETHERTYPE_JUMBO,          "Jumbo" },
+    { ETHERTYPE_LOOPBACK,       "Loopback" },
+    { ETHERTYPE_ISO,            "OSI" },
+    { ETHERTYPE_GRE_ISO,        "GRE-OSI" },
+    { 0, NULL}
+};
+
+/*
+ * Convert a token value to a string; use "fmt" if not found.
+ */
+const char *
+tok2strbuf(register const struct tok *lp, register const char *fmt,
+	   register int v, char *buf, size_t bufsize)
+{
+	if (lp != NULL) {
+		while (lp->s != NULL) {
+			if (lp->v == v)
+				return (lp->s);
+			++lp;
+		}
+	}
+	if (fmt == NULL)
+		fmt = "#%d";
+
+	(void)snprintf(buf, bufsize, fmt, v);
+	return (const char *)buf;
+}
+
+/*
+ * Convert a token value to a string; use "fmt" if not found.
+ */
+const char *
+tok2str(register const struct tok *lp, register const char *fmt,
+	register int v)
+{
+	static char buf[4][128];
+	static int idx = 0;
+	char *ret;
+
+	ret = buf[idx];
+	idx = (idx+1) & 3;
+	return tok2strbuf(lp, fmt, v, ret, sizeof(buf[0]));
+}
diff -Naur src_dot_original/sniffer/util.h src/sniffer/util.h
--- src_dot_original/sniffer/util.h	1969-12-31 19:00:00.000000000 -0500
+++ src/sniffer/util.h	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,41 @@
+
+#include <ostream>
+
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+//typedef unsigned long long uint64_t;
+
+struct MAC {
+    uint64_t val;
+    MAC() {}
+    MAC(const uint8_t *stream);
+    MAC(uint64_t val);
+    MAC(const MAC& o);
+
+    bool operator==(const MAC& o) const {
+	return val == o.val;
+    }
+    bool operator!=(const MAC& o) const {
+	return val != o.val;
+    }
+    bool operator<(const MAC& o) const {
+	return val < o.val;
+    }
+
+    static MAC broadcast;
+    static MAC null;
+};
+
+std::ostream& operator<<(std::ostream& out, const MAC& mac);
+std::ostream& operator<<(std::ostream& out, const struct in_addr& ip);
+
+char *va(char *format, ...);
+
+struct tok {
+	int v;			/* value */
+	const char *s;		/* string */
+};
+
+extern const char *
+tok2str(register const struct tok *lp, register const char *fmt,
+	register int v);
diff -Naur src_dot_original/test/gcp_test.conf src/test/gcp_test.conf
--- src_dot_original/test/gcp_test.conf	2008-08-10 16:58:43.000000000 -0400
+++ src/test/gcp_test.conf	2008-06-18 20:05:04.000000000 -0400
@@ -3,3 +3,9 @@
 
 [transfer]
 gtc null 12000
+
+[sniffer]
+tcp /tmp/gtcd_sniff_1.sock
+
+[routing]
+15000 16000
diff -Naur src_dot_original/test/gcp_test.sh src/test/gcp_test.sh
--- src_dot_original/test/gcp_test.sh	2008-08-10 16:58:43.000000000 -0400
+++ src/test/gcp_test.sh	2008-06-18 20:05:04.000000000 -0400
@@ -1,7 +1,7 @@
 #!/bin/tcsh
 
-#set CONF="test/gcp_test.conf"
-set CONF="test/gcp_test_set.conf"
+set CONF="test/gcp_test.conf"
+#set CONF="test/gcp_test_set.conf"
 #set CONF="test/gcp_test_opt.conf"
 
 if ($#argv != 1) then
@@ -12,6 +12,7 @@
 rm -rf /tmp/tmp-dot /tmp/.dot /tmp/dot-recv-file
 
 killall -9 gtcd && sleep 0.2 && killall -9 sleep 
+tcsh -x test/routers_gtcd.sh
 xterm -T receiver -geometry 80x24+510+10 -e /bin/sh -c "gtcd/gtcd -f $CONF || sleep 24d" &
 xterm -T sender -geometry 80x24+10+10 -e /bin/sh -c 'test/other_gcp.sh' &
 sleep 6 
diff -Naur src_dot_original/test/other_gcp.conf src/test/other_gcp.conf
--- src_dot_original/test/other_gcp.conf	2008-08-10 16:58:40.000000000 -0400
+++ src/test/other_gcp.conf	2008-06-18 20:05:04.000000000 -0400
@@ -3,3 +3,9 @@
 
 [transfer]
 gtc null 15000
+
+[sniffer]
+tcp /tmp/gtcd_sniff_2.sock
+
+[routing]
+12000 16000
diff -Naur src_dot_original/test/other_gcp.sh src/test/other_gcp.sh
--- src_dot_original/test/other_gcp.sh	2008-08-10 16:58:40.000000000 -0400
+++ src/test/other_gcp.sh	2008-06-18 20:05:04.000000000 -0400
@@ -1,7 +1,7 @@
 #!/bin/tcsh
 
-#set CONF="test/other_gcp.conf"
-set CONF="test/other_gcp_set.conf"
+set CONF="test/other_gcp.conf"
+#set CONF="test/other_gcp_set.conf"
 #set CONF="test/other_gcp_opt.conf"
 
 setenv DOT_CACHE_HOME tmp-dot
diff -Naur src_dot_original/test/router1_gtcd.conf src/test/router1_gtcd.conf
--- src_dot_original/test/router1_gtcd.conf	1969-12-31 19:00:00.000000000 -0500
+++ src/test/router1_gtcd.conf	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,12 @@
+[storage]
+disk
+
+[transfer]
+gtc null 16000
+
+[sniffer]
+tcp /tmp/gtcd_sniff_r1.sock
+
+[routing]
+12000 12000
+15000 15000
diff -Naur src_dot_original/test/router1_gtcd.sh src/test/router1_gtcd.sh
--- src_dot_original/test/router1_gtcd.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/test/router1_gtcd.sh	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,7 @@
+#!/bin/tcsh
+
+set CONF="test/router1_gtcd.conf"
+
+setenv DOT_CACHE_HOME tmp-dot
+#setenv XFER_GTC_PORT 15001
+gtcd/gtcd -f $CONF -p /tmp/gtcd_router1 || sleep 24d
diff -Naur src_dot_original/test/router2_gtcd.conf src/test/router2_gtcd.conf
--- src_dot_original/test/router2_gtcd.conf	1969-12-31 19:00:00.000000000 -0500
+++ src/test/router2_gtcd.conf	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,12 @@
+[storage]
+disk
+
+[transfer]
+gtc null 17000
+
+[sniffer]
+tcp /tmp/gtcd_sniff_r2.sock
+
+[routing]
+12000 16000
+15000 15000
diff -Naur src_dot_original/test/router2_gtcd.sh src/test/router2_gtcd.sh
--- src_dot_original/test/router2_gtcd.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/test/router2_gtcd.sh	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,7 @@
+#!/bin/tcsh
+
+set CONF="test/router2_gtcd.conf"
+
+setenv DOT_CACHE_HOME tmp-dot
+#setenv XFER_GTC_PORT 15001
+gtcd/gtcd -f $CONF -p /tmp/gtcd_router2 || sleep 24d
diff -Naur src_dot_original/test/routers_gtcd.sh src/test/routers_gtcd.sh
--- src_dot_original/test/routers_gtcd.sh	1969-12-31 19:00:00.000000000 -0500
+++ src/test/routers_gtcd.sh	2008-06-18 20:05:04.000000000 -0400
@@ -0,0 +1,4 @@
+#!/bin/tcsh
+
+xterm -T router1 -geometry 80x24+510+10 -e /bin/sh -c 'test/router1_gtcd.sh' || sleep 6 &
+xterm -T router2 -geometry 80x24+510+10 -e /bin/sh -c 'test/router2_gtcd.sh' || sleep 6 &
